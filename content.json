{"meta":{"title":"🛫起飞了","subtitle":"SCI.CI","description":"创造","author":"啓飞","url":"https://sci.ci","root":"/"},"pages":[{"title":"about","date":"2019-10-24T14:41:10.000Z","updated":"2020-08-29T16:09:54.006Z","comments":true,"path":"about/index.html","permalink":"https://sci.ci/about/index.html","excerpt":"","text":"教育经历 硕士 可持续能源供应 RWTH 2020/04 - 至今 语言学习德国2019/10 - 2020/03 本科 机械设计制造及其自动化国内某大学2015/09 - 2019/06 联系方式 电子邮箱&#x69;&#x6d;&#x40;&#x78;&#x69;&#101;&#x71;&#x69;&#102;&#x65;&#x69;&#46;&#x63;&#x6f;&#109; 地址Aachen, Nordrhein-Westfalen, GermanyBLZ:52074 微信TakeOff_Xie QQ975322731"},{"title":"archives","date":"2019-07-19T14:39:20.000Z","updated":"2019-10-23T21:16:56.000Z","comments":true,"path":"archives/index.html","permalink":"https://sci.ci/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-19T14:40:27.000Z","updated":"2020-08-26T16:50:22.630Z","comments":true,"path":"tags/index.html","permalink":"https://sci.ci/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T14:42:10.000Z","updated":"2019-10-26T18:16:10.000Z","comments":true,"path":"friends/index.html","permalink":"https://sci.ci/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：飞吧 地址：https://fei.bar 简介：分享生活和学习 头像：https://fei.bar/medias/avatars/profile.jpg"},{"title":"所有分类","date":"2019-07-19T14:39:20.000Z","updated":"2020-08-26T16:50:41.582Z","comments":true,"path":"categories/index.html","permalink":"https://sci.ci/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-07-26T15:17:02.000Z","updated":"2019-10-24T18:34:36.000Z","comments":true,"path":"contact/index.html","permalink":"https://sci.ci/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，或者加我联系方式： QQ：975322731 微信：TakeOff_Xie 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。当然不介意你加我~~ 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：飞吧 地址：https://fei.bar 简介：分享生活和学习。 头像：https://fei.bar/medias/avatars/profile.jpg"},{"title":"我的朋友们","date":"2019-07-19T14:42:10.000Z","updated":"2020-06-05T15:07:38.929Z","comments":true,"path":"friends/index-DESKTOP-N8PHHQN.html","permalink":"https://sci.ci/friends/index-DESKTOP-N8PHHQN.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：飞吧 地址：https://fei.bar 简介：分享生活和学习 头像：https://fei.bar/medias/avatars/profile.jpg"}],"posts":[{"title":"ifvod去除广告","slug":"ifvod去除广告","date":"2021-02-16T09:55:46.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2021/02/16/ifvod去除广告/","link":"","permalink":"https://sci.ci/2021/02/16/ifvod%E5%8E%BB%E9%99%A4%E5%B9%BF%E5%91%8A/","excerpt":"","text":"ifvod视频会在视频的开始、25分钟、50分钟的时候插入广告，现在仅需简单的两步，就能去除ifvod播放广告。 1：安装浏览器插件点击下面的链接，将ReRes插件添加至Chrome。 https://chrome.google.com/webstore/detail/reres/gieocpkbblidnocefjakldecahgeeica 安装好后，在浏览器拓展程序中，将出现ReRes插件。 在浏览器地址栏输入 1chrome:&#x2F;&#x2F;extensions&#x2F; 查看插件，确保插件已经激活，激活时，右下角的滑动按钮状态如图所示。 点击浏览器窗口右上角的ReRes图标，应该会出现下图所示的弹窗。当然此时应当还没有任何规则。 2：添加规则如图所示，点击添加规则按钮 在If URL match:一栏填入 1https:&#x2F;&#x2F;www.ifvod.tv&#x2F;7-es2015.5cef6194389ec0967828.js 在Response:一栏填入 1https:&#x2F;&#x2F;qn.xieqifei.com&#x2F;7-es2015.5cef6194389ec0967828.js 点击保存。 至此，你在ifvod观看视频，将不会有任何视频广告插入。 3：原理ifvod广告是通过js代码嵌入到播放器中的。我仔细阅读了，它的播放器代码，也就是，上面替换掉的js文件，我修改了其中，关于广告投放部分的代码。。 ReRes插件是我在网上随便找的一个插件，它的作用是，当浏览器请求一个资源时，如果它符合我在ReRes上设定的url规则，就将它重定向到另一个资源文件。这样就能实现篡改ifvod的播放器源代码。 也许你可以通过对比修改前后的js文件，来了解我具体是如何修改的。。不过，我并不推荐你阅读这个两万行代码的文件，它会让你崩溃。。我也没有完全阅读这些代码，而是通过一些逆向工程的推断，来找到核心代码，这需要一些耐心。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://sci.ci/tags/Javascript/"}]},{"title":"爬取Youtube搜索结果","slug":"爬取Youtube搜索结果","date":"2021-02-06T13:46:38.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2021/02/06/爬取Youtube搜索结果/","link":"","permalink":"https://sci.ci/2021/02/06/%E7%88%AC%E5%8F%96Youtube%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/","excerpt":"","text":"1：绪最近在做一个音乐下载软件，通过搜索音乐名称，下载youtube上信息匹配度最高的视频，提取其中的音频，来获取音乐。开源软件youtube-dl已经完成了视频下载和音频提取的全部工作，我要做的就是，获取目标视频的id或者视频链接，然后调用youtube-dl下载。 2：接口谷歌官方其实已经提供了获取YouTube搜索结果的api，直接调用即可。 12345678910#调用谷歌api获取youtube搜索结果，返回匹配度最高的视频链接def get_video_url_in_youtube_form_api(appKey,music_name): print(&quot;从google api获取数据&quot;) url = &quot;https://youtube.googleapis.com/youtube/v3/search?q=&quot;+music_name+&quot;&amp;key=&quot;+appKey resp = requests.get(url) resp_json = resp.json() if resp.status_code ==200: return &quot;https://www.youtube.com/watch?v=&quot;+resp_json[&#x27;items&#x27;][0][&#x27;id&#x27;][&#x27;videoId&#x27;] else: return 500 但是，谷歌api是有调用上限的，也就是10000个单位，每次搜索将消耗100个单位。那么我们总共可以通过api获取搜索结果的次数就是100个。这对于个人来说，实际上已经足够了，但是，如果要向他人提供服务，就不够了。 那么就只能上手爬虫了。 3：爬取搜索结果12345678910111213141516#利用爬虫获取youtube搜索结果def get_video_url_in_youtube_from_crawler(keyword): url=&quot;https://m.youtube.com/results?search_query=&quot;+keyword print(&quot;通过爬虫获取数据&quot;) resp = requests.get(url) if resp.status_code==200: result_json = re.findall(r&#x27;ytInitialData = (.*);&lt;/script&gt;&#x27;, resp.text)[0] result_obj = json.loads(result_json) try: video_url = &quot;https://www.youtube.com/watch?v=&quot;+result_obj[&#x27;contents&#x27;][&#x27;twoColumnSearchResultsRenderer&#x27;][&#x27;primaryContents&#x27;][&#x27;sectionListRenderer&#x27;][&#x27;contents&#x27;][0][&#x27;itemSectionRenderer&#x27;][&#x27;contents&#x27;][0][&#x27;videoRenderer&#x27;][&#x27;videoId&#x27;] except KeyError: return 500 return video_url else: return 500 通过url和搜索值，构造搜索链接。获取返回的html代码。对html格式化后，可以发现，有一串包含搜索结果的json数据，藏在一个js代码中间，通过正则，将它提取出来。 谷歌是有反爬虫的机制的，就是说，如果频繁通过上述程序请求数据，获取到的json不一定能获得想要的内容。这里需要使用Exception来避免报错，假如爬取失败，应当再调用api。如果有代理隧道，那么爬虫就更好了。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"ESP8266从0到1","slug":"ESP8266从0到1","date":"2020-11-26T19:49:52.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/11/26/ESP8266从0到1/","link":"","permalink":"https://sci.ci/2020/11/26/ESP8266%E4%BB%8E0%E5%88%B01/","excerpt":"","text":"0：前语推荐太极创客，学习ESP8266模块的更多知识。 1：连线ESP8266通过串口与电脑或者其他单片机实现交互，串口的使用比较简单。以最简单的ESP8266模块为例进行介绍。其他模块可能已经有了usb type-c或者其他接口，就直接用对应接口的线和设备连接就可以了。下图的模块，没有usb接口，因此需要我们自己连线。 模块共引出了8个引脚，其中， VCC：接3.3V电压，为模块供电。 GUD：接地 GPIO0：平时直接悬空。需要刷固件的时候接地。 CH_PD：通过一个10K电阻接3.3V电压，表示模块处于工作状态。否则将不工作。 串口通信引脚， RXD：串口输入，表示这个引脚会接收其他模块传入的信息。与其他模块的TX引脚相连。 TXD：串口输出，接其他模块的RX引脚，把数据传给其他模块。 通过FTDI USB to TTL模块，可以将ESP直接和电脑连接。只需要将对应引脚与FTDI模块相连即可。 2：简单开始下图为一个FTDI模块。将其引脚与ESP模块各引脚相连。 下载FTDI模块的芯片驱动，直接搜索对应芯片就能找到。安装驱动后，将连接好的FTDI模块插入电脑，在电脑设备管理器中，能找到端口一栏，多了这个模块的端口比如(COM6) 随意下载一个串口助手，选择FTDI模块的端口，设置波特率为115200，结束符为NL和CR。其他的默认。 在串口助手上发送：AT 串口助手的窗口会返回：OK，或者ERROR。 如果返回OK，那么就可以通过AT指令操作ESP芯片连接WIFI或者作为AP让别人连wifi了。 如果返回ERROR，那么就需要更新固件，以让ESP支持AT指令。 未必一定要直接将ESP与电脑连接，也可以和其他单片机连接，通过对其他单片机编程，向ESP发送AT指令。重要的是，理解ESP的工作方式。 3：更新固件如果你不小心将ESP配置错了，又不知道怎么去将它出厂设置，或者你发送AT指令总是返回ERROR，那么你就需要学习如何更新芯片固件。 更新固件需要用到FTDI模块，将FTDI和ESP连接，FTDI连接电脑。 首先下载Flash下载工具。只有Windows系统能用。 然后下载最新版本的ESP8266 NONOS SDK。并解压。 接线，需要注意，GPIO0引脚必须接地。 序号 引脚名称 I/O 描述 DC特性 备注 1 UTXD AT 串口发送输出 3.3V 开机时禁止下拉 2 GND 地 3 CH_PD(EN) 模块断电信号 3.3V 1）高电平工作； 2）低电平模块供电关掉； 4 GPIO2 预留，默认悬空 3.3V 开机上电时必须为高电平，禁止硬件下拉；内部默认已拉高 5 GPIO16 I 复位信号(RESET) 3.3V 低电平复位，高电平工作（默认高）； 6 GPIO0 模块状态灯/工作模式选择 3.3V 1）默认WiFiStatus：WiFi工作状态指示灯控制信号；2）工作模式选择：上拉：FlashBoot，工作模式；下拉：UARTDownload，下载模式（下载固件）； 7 VCC I 模块采用单电源供电，通过 1 个VCC 电源引脚供电，电压范围：3.0V-3.6V,电流&gt;600mA Vmax=3.6VVmin=3.0VVnorm=3.3V 电源供电能力请大于600mA;否则可能会引起模块工作异常，或者无线性能不好。 8 URXD AT 串口发送输入 3.3V 打开flash_download_tool_v3.8.5.exe。选择Developer模式。 选择8266芯片 然后在之前解压的SDK中找到C:\\Users……\\ESP8266_NONOS_SDK-3.0.4\\bin\\boot_v1.6.bin文件刷入地址0x00000中 然后点击START按钮开始，如果显示等待上电，在保证GPIO0接地的情况下，将RST引脚接地再断开。 至此固件等待刷新完毕。 4：AT指令完整的AT指令PDF 常见的指令： 基础命令 测试：AT 复位：AT+RST 恢复出厂设置：AT+RESTORE 查询本机IP和MAC：AT+CIFSR 模式命令 查询模式：AT+CWMODE? 设置模式 1:STA 2:AP 3:both：AT+CWMODE=1 （STA）查询当前可用AP ：AT+CWLAP （STA）加入可用AP ：AT+CWJAP=“ssid”,“psw” （STA）退出当前AP ：AT+CWQAP （AP）设置AP参数，ssid+psw+chn+ecn+n+01 ：AT+CWSAP=“哈哈”,“12345678”,3,3,4,0 （AP）查询AP参数：AT+CWSAP? 客户端|服务器设置 查询是否多连接 是1，否0 ：AT+CIPMUX? 设置启动多连接1，单链接0（重启后默认0）：AT+CIPMUX=1 （多连接）关闭服务器，就是开启多连接客户端，默认是0 ：AT+CIPSERVER=0 （多连接）开启服务器,:开启+端口号port。 此时客户端要连本机，远程地址为 IP+Port ：AT+CIPSERVER=1,8080 （多连接）发送数据 id+Byte：AT+CIPSEND=0,10 （多连接）关闭TCP/UDP连接，id：AT+CIPCLOSE=0 （客户端单连接）建立TCP/UDP连接：AT+CIPSTART=“TCP”,“192.168.4.2”,100 （客户端单连接）发送数据，Byte ：AT+CIPSEND=10 （客户端单连接）使能穿透模式：AT+CIPMODE=1 （客户端单连接）进入透传模式发送：AT+CIPSEND （客户端单连接）退出透传：+++ （客户端单连接）关闭TCP/UDP连接：AT+CIPCLOSE （客户端多连接）建立TCP/UDP连接，id，TCP/UDP，IP，端口：AT+CIPSTART=0,“TCP”,“192.168.4.2”,100 其他如果需要用到ESP通过软串口连接Arduino单片机，就需要修改ESP的波特率，ESP默认波特率是115200，而软串口只能是9600，修改波特率AT指令 AT+CIOBAUD=9600 如果返回ERROR，可以尝试 AT+UART=9600,8,1,0,0 5：使用Arduino IDE编写程序ESP8266是可以直接使用Arduino IDE上烧录程序的。为了在Arduino IDE上直接编写程序，首先需要导入ESP8266的库。 在IDE的文件-&gt;首选项里边的附加开发板管理网址输入https://github.com/esp8266/Arduino/releases/download/2.5.0/package_esp8266com_index.json 或者http://arduino.esp8266.com/stable/package_esp8266com_index.json 之后点击好。 在 工具-&gt;开发板选择最上方开发板管理器，之后搜索esp即可出现esp8266，选择版本之后进行安装即可。 在Arduino IDE 菜单&gt;工具&gt;开发板&gt;开发板管理器 中选择你正在使用的8266开发板。 如果你不清楚自己使用的是哪个开发板，可以选择generic esp8266 module，这是通用板子。 选择正确的端口。如果不知道自己板子连接电脑上的是哪个端口，可以打开电脑的设备管理器，其中有端口一栏，有详细信息。 上载程序前，将GPIO0引脚下拉接地，并将RST引脚接地在放开，上载程序时，GPIO0引脚需保持接地状态。上载完毕，将GPIO0引脚放空，并再次将RST引脚接地放开，切换到运行状态。 6：Https请求程序这里以企业微信api发送应用消息为例，简述https请求中的get和post请求。http请求更为简单。网上资料也更多。 要调取企业微信api首先需要仔细阅读其开发文档。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;Arduino.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;WiFiClientSecureBearSSL.h&gt;#include &lt;ArduinoJson.h&gt;//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;SSID&quot; //WiFi名称 #define password &quot;PASSWORD&quot; //WiFi密码//https://qyapi.weixin.qq.com网站的指纹。//esp通过https访问网站，都需要自己通过浏览器获取指纹，获取方法可自行搜索，在参考资料中也有文章，指纹一般几个月就需要更新一次。浏览器打开https://qyapi.weixin.qq.com/cgi-bin/gettoken获取指纹，而不只是只有主机名。const char fingerprint[] PROGMEM = &quot;790e6e32485bb89503ac6da87d948f5e634322a7&quot;;//HTTPS端口443const int httpsPort = 443; // 企业微信api相关String tokenUrl = &quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken&quot;;String sendMsgUrl = &quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=&quot;;//以下信息需要替换，这里的均不可用String corpid = &quot;ww98b3k1b63788a7ad&quot;;//你的企业idString corpsecret = &quot;Kh8asfasfaTrbSwRBGK5H0osnfasakjkmSYCqV3Tgcs&quot;;//你的企业应用密钥String agentid = &quot;1000002&quot;;//你的企业应用id//获取企业微信access_tokenString get_token()&#123; String token = &quot;123&quot;; String requestUrl = tokenUrl + &quot;?corpid=&quot;+corpid+&quot;&amp;corpsecret=&quot;+corpsecret; //https需要创建一个加密路径 std::unique_ptr&lt;BearSSL::WiFiClientSecure&gt;client(new BearSSL::WiFiClientSecure); client-&gt;setFingerprint(fingerprint); //创建一个HTTP客户端 HTTPClient https; //http和https的区别就是https.begin中的*client。如果没有*client,那么发送出去的就是http请求 //建立连接 if (https.begin(*client, requestUrl)) &#123; // HTTPS Serial.print(&quot;[HTTPS] GET...\\n&quot;); // 发送get请求 int httpCode = https.GET(); //如果httpCode小于零则连接错误 if (httpCode &gt; 0) &#123; Serial.printf(&quot;[HTTPS] GET... code: %d\\n&quot;, httpCode); // file found at server if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) &#123; //将返回的json序列，放到json变量 String json = https.getString(); Serial.println(json); // 创建DynamicJsonDocument对象，json中的参数为4个。 const size_t capacity = JSON_OBJECT_SIZE(4) + 290; DynamicJsonDocument doc(capacity); //反序列化数据 deserializeJson(doc, json); if(doc[&quot;errcode&quot;].as&lt;int&gt;()==0)&#123; token = doc[&quot;access_token&quot;].as&lt;String&gt;(); &#125; &#125; &#125; else &#123; Serial.printf(&quot;[HTTPS] GET... failed, error: %s\\n&quot;, https.errorToString(httpCode).c_str()); &#125; https.end(); &#125; else &#123; Serial.printf(&quot;[HTTPS] Unable to connect\\n&quot;); &#125; return token;&#125; //调用企业微信api，发送信息。 void send_msg(String msg)&#123; //调用get_token函数，获取token String token = get_token(); //token=123表示get_token()函数请求token失败。 //如果失败，可能还需要其他步骤，比如重新获取。这里没有完善。 if (token == &quot;123&quot;)&#123; Serial.println(&quot;not get token&quot;); return; &#125;else&#123; Serial.println(&quot;got token&quot;); &#125; //构造请求url String requestUrl = sendMsgUrl + token; std::unique_ptr&lt;BearSSL::WiFiClientSecure&gt;client(new BearSSL::WiFiClientSecure); client-&gt;setFingerprint(fingerprint); HTTPClient httpClient; //与微信服务器建立连接 httpClient.begin(*client,requestUrl); //构建json数据，用于发送请求内容 String json = &quot;&#123;\\&quot;touser\\&quot;:\\&quot;@all\\&quot;,\\&quot;msgtype\\&quot;:\\&quot;text\\&quot;,\\&quot;agentid\\&quot;:1000002,\\&quot;text\\&quot;:&#123;\\&quot;content\\&quot;:\\&quot;&quot;+msg+&quot;\\&quot;&#125;,\\&quot;safe\\&quot;:0,\\&quot;enable_id_trans\\&quot;:0,\\&quot;enable_duplicate_check\\&quot;:0,\\&quot;duplicate_check_interval\\&quot;:1800&#125;&quot;; //发送请求内容 Serial.println(json); //将请求数据放到POST()中。 int httpCode = httpClient.POST(json); //这里没有读取服务器返回的json数据，最好还是提取出来，判断是否发送成功。可自行添加代码 if (httpCode &gt; 0) &#123; //将服务器响应头打印到串口 Serial.println(&quot;[HTTP] POST... code:&quot;+ httpCode); //将从服务器获取的数据打印到串口 if (httpCode == HTTP_CODE_OK) &#123; Serial.println(&quot;Send success&quot;); Serial.println(&quot;return str:&quot;+httpClient.getString()); &#125; &#125; else &#123; Serial.println(&quot;send failure&quot;); &#125; //关闭ESP8266与服务器连接 httpClient.end(); &#125;//Wifi initvoid wifi_init()&#123; Serial.begin(9600); WiFi.mode(WIFI_STA); //设置ESP8266为无线终端工作模式 WiFi.begin(ssid, password); //连接WiFi Serial.println(&quot;&quot;); Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;); // 等待连接 while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。 Serial.println(&quot;&quot;); Serial.print(&quot;Connected to &quot;); Serial.println(ssid); Serial.print(&quot;IP address: &quot;); Serial.println(WiFi.localIP()); &#125;void setup() &#123; wifi_init(); send_msg(&quot;hello world!&quot;);&#125;void loop() &#123;&#125; ArduinoJSON库需要在IDE库管理中搜索安装， 其他库都是随ESP8266库一起安装的。 json格式化和转义：http://www.bejson.com/ ArduinoJson Assistant：https://arduinojson.org/v6/assistant/ 关于ArduinoJSON详细教程可见参考资料章节 7：低功耗方案ESP8266提供三种省电模式。 当我们的程序在某个时间段不需要使用wifi模块时，可让它进入睡眠模式， Modem-Sleep模式：wifi与路由器保持连接，只在间断的时间里发送一个消息以保持连接。 Light-Sleep模式：在Modem-Sleep的基础上，关闭CPU。在esp循环任务长时间不需要esp工作时，会自动进入此模式。 Deep-Sleep模式：断开wifi。可用户配置。 deepsleep模式提供定时器唤醒和外部IO唤醒两种方案。 定时器唤醒 将RST引脚接GPIO16。 123456789101112131415161718192021/* * ESP8266 Deep sleep mode example * Rui Santos * Complete Project Details https://randomnerdtutorials.com */ void setup() &#123; Serial.begin(115200); Serial.setTimeout(2000); // Wait for serial to initialize. while(!Serial) &#123; &#125; // Deep sleep mode for 30 seconds, the ESP8266 wakes up by itself when GPIO 16 (D0 in NodeMCU board) is connected to the RESET pin Serial.println(&quot;I&#x27;m awake, but I&#x27;m going into deep sleep mode for 30 seconds&quot;); ESP.deepSleep(30e6); &#125;void loop() &#123;&#125; ESP-01芯片，GPIO16引脚并没有引出，所以，很难将RST引脚与其相接。 外部唤醒。 将RST与外部单片机的IO口相接，当外部IO给RST一个低电平时，芯片将重启激活。 例如使用按钮来提供低电平 1234567891011121314151617181920/* * ESP8266 Deep sleep mode example * Rui Santos * Complete Project Details https://randomnerdtutorials.com */ void setup() &#123; Serial.begin(115200); Serial.setTimeout(2000); // Wait for serial to initialize. while(!Serial) &#123; &#125; // Deep sleep mode until RESET pin is connected to a LOW signal (for example pushbutton or magnetic reed switch) Serial.println(&quot;I&#x27;m awake, but I&#x27;m going into deep sleep mode until RESET pin is connected to a LOW signal&quot;); ESP.deepSleep(0); &#125;void loop() &#123;&#125; 有的ESP模块上面带有LED灯，采用低功耗方案，务必将LED移除。 8：与其他单片机通讯ESP通过串口可与其他单片机传递信息，将ESP的TX引脚连接其他单片机RX引脚，ESP的RX连接其他单片机的TX。 注意，ESP8266是3.3V供电，VCC需要接3.3V。如果其他单片机是5V供电，ESP的RX引脚需要分压之后连接其他单片机的TX，否则进入ESP的5V电压会烧坏芯片。ESP的TX则不用分压。 下图为ESP连接Arduino Nano的接线图，途中，ESP RX引脚，通过1K和2K的电阻分压，其实也可以直接在ESP TX引脚和单片机RX引脚之间连接一个550左右的电阻。 9：参考资料《乐鑫ESP8266烧录固件、升级最新固件、刷MQTT固件》 《ESP8266 WIFI模块常用AT指令汇总》 《Arduino安装ESP8266的开发环境》 《ESP8266 JSON解析》 《物联网开发实用知识 – 查看网站证书指纹》 《ESP8266 Deep Sleep with Arduino IDE (NodeMCU)》","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://sci.ci/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"ESP8266","slug":"ESP8266","permalink":"https://sci.ci/tags/ESP8266/"}]},{"title":"基于ESP8266WIFI模块和MPU6050传感器在Arduino上开发智能信箱","slug":"基于ESP8266WIFI模块和MPU6050加速度计在Arduino上开发智能信箱","date":"2020-11-24T22:37:07.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/11/24/基于ESP8266WIFI模块和MPU6050加速度计在Arduino上开发智能信箱/","link":"","permalink":"https://sci.ci/2020/11/24/%E5%9F%BA%E4%BA%8EESP8266WIFI%E6%A8%A1%E5%9D%97%E5%92%8CMPU6050%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1%E5%9C%A8Arduino%E4%B8%8A%E5%BC%80%E5%8F%91%E6%99%BA%E8%83%BD%E4%BF%A1%E7%AE%B1/","excerpt":"","text":"1：开篇在德国，每家每户都有一个信箱，家庭的电气暖账单，亲人的问候，个人的信件都会装到这个小小的箱子里。。相较于送货到人的快递，信件往往被我们所忽略，常宅在家的我，一两个星期才会检查一次信箱。虽然信件通常不重要，但检查信箱还是有点麻烦。于是，我设计了一个小小的模块，让它代替我检查信箱，每当有新的信件进入信箱，它就发送一条微信消息，提醒我取信件。 1.1 ESP8266-01 Wifi模块wifi模块是物联网中不可或缺的一部分，通过它连上家里的wifi，向网络发送请求。调用企业微信api，来发送微信消息。 ESP8266通过串口通信与Arduino单片机通信，由3.3V直流电压供电。 1.2 GY-521模块GY-521指围绕MPU6050芯片所设计的电路板。 MPU6050芯片集成了加速度计、陀螺仪、温度传感器。通过i2c与Arduino单片机通信。工作电压为5V。 使用MPU6050检测信箱口的运动状态，判断是否有新的信件投入。 1.3 ArduinoArduino是目前非常火的开源单片机，其周边开发板大多开源，因此，一块Arduino开发板价格非常便宜，Arduino pro mini仅十块钱。我采用的是Arduino nano。其带有usb接口，比较方便调试。但是耗电会比pro mini高。 在投入使用时，考虑到电池优化，建议使用pro mini。这样整个系统的运行时长会更久。 此外，Arduino拥有庞大的社区，大部分传感器模块都有其适配支持的开源库。开发更加容易，且不用花费大量时间阅读硬件说明书。对于追求性能优化而不是仅功能实践的人来说，还是有必要阅读传感器数据手册的。 Arduino用于接收传感器的数据，并处理计算，判断是否信箱口有动作，如果有，则通过wifi模块发送微信。 2：电路设计这里只是简单的画了一个电路设计图，因为不需要再去制作PCB板，也就不用设计PCB板图。只要购买相应的模块，然后对照电路图连线即可。 面包板图 2.1 电源设计 5V电源 通过4个AA电池串联，获得一个4x1.5V的直流电，理论电压为6V，而实际上都会小于6V。因为单片机供电要求在4.5~5.5V之间，如有必要可在电池正极接一个稳压二极管。稳压二极管由硅材料制成，其正向导通时，在PN结之间产生一个0.7V左右的压降。因此从稳压二极管输出的电压就能够满足单片机供电需求。我直接连接VCC供电是没有问题的。 当然也可以使用9~12V的电源连接VIN接口供电，或者直接使用充电宝，通过usb接口供电。需要注意的是，usb供电会额外增加电能损耗。 3V3电源 ESP8266模块使用3V3电源，4个干电池，无法提供3V电源，使用LM1117-3.3芯片将5V降压为3V。输入和输出口各加一个2.2uF的电容，用于稳压。 2.2 各模块接线GY521模块SCL、SDA分别为I2C的时钟和数据总线，与ArduinoSCL和SDA相连。GY521 Int引脚接Arduino D2(INT0)引脚。 Arduino D6引脚，输出控制电平，通过一个稳压二极管，将5V高电平转3V高电平。 3：程序设计3.1 wifi模块当WIFI模块启动时，会发送一条微信消息。然后进入睡眠，当RST引脚接收到低电平-&gt;高电平时，WIFI模块将被唤醒。 我猜测我的WIFI模块是存在某种问题的，当它被唤醒时，并不会进行运行loop中的内容，而是进行了未知操作。因此，我在Arduino中不得不，向RST引脚发出两次低电平，第一次用于激活WIFI模块，第二次重置WIFI模块，因为它重启的时候，就会发送一条微信消息。所以也能实现既定功能。 ESP8266发送https请求时，不会自动获取服务器证书，所以需要自己从服务器去获取，可以直接从浏览器拷贝下来。这里没有使用证书，而是指纹，作用相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;Arduino.h&gt;#include &lt;ESP8266WiFi.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;WiFiClientSecureBearSSL.h&gt;#include &lt;ArduinoJson.h&gt;//WiFi连接信息（注意：需要自行修改以下内容否则ESP8266无法连接WiFi）#define ssid &quot;SSIDU&quot; //WiFi名称 #define password &quot;Password&quot; //WiFi密码//https://qyapi.weixin.qq.com服务器的指纹const char fingerprint[] PROGMEM = &quot;790e6e32485bb89503ac6da87d948f5e634322a7&quot;;//HTTPS端口443const int httpsPort = 443; // 企业微信api相关String tokenUrl = &quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken&quot;;String sendMsgUrl = &quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=&quot;;String corpid = &quot;ww98b********d&quot;;String corpsecret = &quot;Kh8eKMZ**********wzQoPb0SYCqV3Tgcs&quot;;String agentid = &quot;1000002&quot;;//发起Https请求//获取企业微信access_tokenString get_token()&#123; String token = &quot;123&quot;; String requestUrl = tokenUrl + &quot;?corpid=&quot;+corpid+&quot;&amp;corpsecret=&quot;+corpsecret; std::unique_ptr&lt;BearSSL::WiFiClientSecure&gt;client(new BearSSL::WiFiClientSecure); client-&gt;setFingerprint(fingerprint); HTTPClient https; if (https.begin(*client, requestUrl)) &#123; // HTTPS Serial.print(&quot;[HTTPS] GET...\\n&quot;); // start connection and send HTTP header int httpCode = https.GET(); // httpCode will be negative on error if (httpCode &gt; 0) &#123; // HTTP header has been send and Server response header has been handled Serial.printf(&quot;[HTTPS] GET... code: %d\\n&quot;, httpCode); // file found at server if (httpCode == HTTP_CODE_OK || httpCode == HTTP_CODE_MOVED_PERMANENTLY) &#123; String json = https.getString(); Serial.println(json); // 创建DynamicJsonDocument对象，json中的参数为4个。 const size_t capacity = JSON_OBJECT_SIZE(4) + 290; DynamicJsonDocument doc(capacity); //反序列化数据 deserializeJson(doc, json); if(doc[&quot;errcode&quot;].as&lt;int&gt;()==0)&#123; token = doc[&quot;access_token&quot;].as&lt;String&gt;(); &#125; &#125; &#125; else &#123; Serial.printf(&quot;[HTTPS] GET... failed, error: %s\\n&quot;, https.errorToString(httpCode).c_str()); &#125; https.end(); &#125; else &#123; Serial.printf(&quot;[HTTPS] Unable to connect\\n&quot;); &#125; return token;&#125; //调用企业微信api，发送信息。 void send_msg(String msg)&#123; //调用get_token函数，获取token String token = get_token(); //token=123表示get_token()函数请求token失败。 //如果失败，可能还需要其他步骤，比如重新获取。这里没有完善。 if (token == &quot;123&quot;)&#123; Serial.println(&quot;not get token&quot;); return; &#125;else&#123; Serial.println(&quot;got token&quot;); &#125; //构造请求url String requestUrl = sendMsgUrl + token; std::unique_ptr&lt;BearSSL::WiFiClientSecure&gt;client(new BearSSL::WiFiClientSecure); client-&gt;setFingerprint(fingerprint); HTTPClient httpClient; httpClient.addHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); //与微信服务器建立连接 httpClient.begin(*client,requestUrl); //构建json数据，用于发送请求内容 String json = &quot;&#123;\\&quot;touser\\&quot;:\\&quot;@all\\&quot;,\\&quot;msgtype\\&quot;:\\&quot;text\\&quot;,\\&quot;agentid\\&quot;:1000002,\\&quot;text\\&quot;:&#123;\\&quot;content\\&quot;:\\&quot;&quot;+msg+&quot;\\&quot;&#125;,\\&quot;safe\\&quot;:0,\\&quot;enable_id_trans\\&quot;:0,\\&quot;enable_duplicate_check\\&quot;:0,\\&quot;duplicate_check_interval\\&quot;:1800&#125;&quot;; //发送请求内容 Serial.println(json); int httpCode = httpClient.POST(json); //未完善，可能发送请求成功，但api调用失败，后续完善。 if (httpCode &gt; 0) &#123; //将服务器响应头打印到串口 Serial.println(&quot;[HTTP] POST... code:&quot;+ httpCode); //将从服务器获取的数据打印到串口 if (httpCode == HTTP_CODE_OK) &#123; Serial.println(&quot;Send success&quot;); Serial.println(&quot;return str:&quot;+httpClient.getString()); &#125; &#125; else &#123; Serial.println(&quot;send failure&quot;); &#125; //关闭ESP8266与服务器连接 httpClient.end(); &#125;//Wifi initvoid wifi_init()&#123; WiFi.mode(WIFI_STA); //设置ESP8266为无线终端工作模式 WiFi.begin(ssid, password); //连接WiFi Serial.println(&quot;&quot;); Serial.println(&quot;Connecting&quot;); Serial.println(&quot;&quot;); // 等待连接 while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; //成功连接后通过串口监视器显示WiFi名称以及ESP8266的IP地址。 Serial.println(&quot;&quot;); Serial.print(&quot;Connected to &quot;); Serial.println(ssid); Serial.print(&quot;IP address: &quot;); Serial.println(WiFi.localIP()); &#125;void setup() &#123; Serial.begin(9600); wifi_init();&#125;void loop() &#123; send_msg(&quot;你有一封新信件，请及时提取！&quot;); delay(3000); ESP.deepSleep(0);&#125; 3.2 Arduino和GY521在这里，Arduino会对MPU6050芯片进行初始化设置，然后进入睡眠模式。在MPU中，我们将除了Z轴加速度采样以外的所有检测模块都关闭，以提高电池的持久力。并当Z轴检测到大于阈值的运动时，产生运动中断，中断将GY521的INT引脚拉低，INT引脚连接Arduino INT0引脚也就是2号引脚，Arduino将在中断发生时被唤醒。唤醒后的Arduino，通过6号引脚，向ESPwifi模块的RST发送两个低电平脉冲，用于激活并重置ESP。 MPU6050是提供一些低电平方案的，比如CYCLE模式，此模式下可以设置MPU的采样频率，最低可达1.25Hz，但设置此模式，MPU6050的运动检测功能将受限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;MPU6050.h&gt;#include &quot;Wire.h&quot;#include &lt;avr/sleep.h&gt;//定义Arduino引脚，2号为中断引脚，当2号引脚输入低电平，Arduino从睡眠被唤醒//6号引脚为输出，当6号输出低电平，ESP8266模块被激活。#define INTERRUPT_PIN 2#define ESP_ACTIVATE_PIN 6#define MPU6050_ADDRESS 0x68#define SIGNAL_PATH_RESET 0x68#define INT_PIN_CFG 0x37#define ACCEL_CONFIG 0x1C#define MOT_THR 0x1F // Motion detection threshold bits [7:0]#define MOT_DUR 0x20 // Duration counter threshold for motion interrupt generation, 1 kHz rate, LSB = 1 ms#define MOT_DETECT_CTRL 0x69#define INT_ENABLE 0x38#define WHO_AM_I_MPU6050 0x75 // Should return 0x68#define INT_STATUS 0x3AMPU6050 mpu;void mpu6050_init()&#123; Wire.begin();//开启i2c通讯 mpu.initialize(); //电源管理，将陀螺仪全部关闭，只留z轴加速度 //如果全部设置为待机，运动检测中断将无法工作 mpu.setStandbyXAccelEnabled(true); mpu.setStandbyXGyroEnabled(true); mpu.setStandbyYAccelEnabled(true); mpu.setStandbyYGyroEnabled(true); mpu.setStandbyZAccelEnabled(false);//保持z轴加速度检测活跃 mpu.setStandbyZGyroEnabled(true); //关闭温度传感器 mpu.setTempSensorEnabled(false); // mpu.setAccelerometerPowerOnDelay(3);//设置加速度计开机延迟 mpu.setInterruptMode(true); // 中断时中断引脚发出低电平 mpu.setIntZeroMotionEnabled(false);//关闭零运动中断检测 mpu.setIntMotionEnabled(true); // 运动检测中断使能 mpu.setInterruptLatch(true); // 电平保持，直到清除 mpu.setInterruptLatchClear(false);//清除中断引脚电平的方法，false表示只有读取status寄存器才能清除，true读取任意寄存器都可以清除。 mpu.setMotionDetectionThreshold(2);//检测阈值，阈值越大，需要的震动越大，才能产生中断，单位mg mpu.setMotionDetectionDuration(20);//运动持续的时长，越大，则运动需要持续越久，才能产生中断。单位ms mpu.setMotionDetectionCounterDecrement(1); //Write register 28 (==0x1C) to set the Digital High Pass Filter, bits 3:0. For example set it to 0x01 for 5Hz. (These 3 bits are grey in the data sheet, but they are used! Leaving them 0 means the filter always outputs 0.) writeByte(MPU6050_ADDRESS, ACCEL_CONFIG, 0x01); Serial.println(&quot;MPU init finish&quot;);&#125;void sleepNow() &#123; set_sleep_mode(SLEEP_MODE_PWR_DOWN);//设置Arduino睡眠模式为power down sleep_enable(); //使能睡眠 delay(500); Serial.println(&quot;now sleep!&quot;); delay(2000); Serial.println(&quot;Interrupt attached!&quot;); attachInterrupt(0, wakeUp,LOW);//开启中断，0表示INT0，对应2号引脚，wakeUP是中断发生时的处理函数，LOW：2号引脚低电平时触发 delay(500); delay(500); sleep_cpu(); //进入睡眠&#125;//中断处理函数void wakeUp() &#123; detachInterrupt(0);//清除中断，防止中断处理过程中，再次进入中断 sleep_disable();//接触睡眠模式 digitalWrite(ESP_ACTIVATE_PIN,LOW);//设置激活引脚为低电平，用于激活芯片 Serial.println(&quot;wake up! reset esp&quot;);&#125;//I2c通讯，写入一个字节到寄存器void writeByte(uint8_t address, uint8_t subAddress, uint8_t data) &#123; Wire.begin(); Wire.beginTransmission(address); // Initialize the Tx buffer Wire.write(subAddress); // Put slave register address in Tx buffer Wire.write(data); // Put data in Tx buffer Wire.endTransmission(); // Send the Tx buffer&#125;//初始画arduinovoid arduino_init()&#123; Serial.begin(9600);//设置UART通信波特率，使用串口接收。 pinMode(INTERRUPT_PIN,INPUT);//设置INT0，即2号引脚为输入，确保初始化的时候，引脚上有高电平。 pinMode(ESP_ACTIVATE_PIN,OUTPUT);//设置6号引脚为输出，用于激活ESP模块 digitalWrite(ESP_ACTIVATE_PIN,HIGH);//设置输出为高电平，ESP的RESET引脚以低电平激活或重置芯片。 Serial.println(&quot;arduino init finish!&quot;);&#125;void setup()&#123; arduino_init(); mpu6050_init();&#125;void loop()&#123; sleepNow();//进入睡眠 int16_t zAccel = mpu.getAccelerationZ(); Serial.println(zAccel); bool detect = mpu.getIntMotionStatus();//读取中断状态，以清除中断引脚电平。不清除，MPU中断引脚会一直保持低电平。 Serial.println(detect); //在中断函数中，发送了一个低电平激活芯片，在这里再发送一个低电平，用于重置芯片。最后回到高电平。 //不能再中断函数中，发送两个电平，因为中断函数中无法使用delay()方法。而低电平必须保持一定时间才能激活ESP。 delay(500); digitalWrite(ESP_ACTIVATE_PIN,HIGH); delay(500); digitalWrite(ESP_ACTIVATE_PIN,LOW); Serial.println(&quot;rest esp&quot;); delay(500); digitalWrite(ESP_ACTIVATE_PIN,HIGH); delay(1000);&#125;","categories":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://sci.ci/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"tags":[{"name":"Arduino","slug":"Arduino","permalink":"https://sci.ci/tags/Arduino/"},{"name":"ESP8266","slug":"ESP8266","permalink":"https://sci.ci/tags/ESP8266/"},{"name":"MPU6050","slug":"MPU6050","permalink":"https://sci.ci/tags/MPU6050/"}]},{"title":"人工智能——激活函数","slug":"人工智能——激活函数","date":"2020-11-15T09:00:48.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/11/15/人工智能——激活函数/","link":"","permalink":"https://sci.ci/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/","excerpt":"","text":"1：什么是激活函数 以一个简单的神经元为例。在没有激活函数时，神经元输出z等于$z=x_1w_1+x_2w_2+x_3w_3+b$ 而激活函数将z作为输入，得到新的神经元输出$f(z)$ 这里的$f(z)$即激活函数。激活函数的主要作用是使输出非线性化，即曲线化或者分段化（对应分段函数）。 2：为什么要激活函数从$z=x_1w_1+x_2w_2+x_3w_3+b$不难看出，在没有激活函数时，我们的神经元输出，总是与输入$x_1,x_2,x_3$成线性关系。。 简单点的例子，$z = x_1*w+b$。 可以知道，这是一条直线。可以解决一个简单的二分类问题。 如果这个二分类不是用直线分割的呢？ 比如，一个圆形，圆内的点是1，圆外是0。我们用直线就很难将他们区分开了。 当然，也可以使用无数条小的直线来划分这两个区域，但是对比直接使用曲线，就复杂多了。 为了让我们的输出函数，符合非线性特征，引入了激活函数的概念。 3：哪些激活函数 Sigmoid函数 Sigmoid函数只会输出0到1之间的正数，当输入无穷小时，输出为0，输入无穷大时，输出为1。 缺点： 基于反向传播（根据链式求导法则）的参数更新，随着网络层数的增加，w更新的梯度会越来越小，并逐渐接近于零。也就是所谓的梯度消失。 下图是链式求导法则求w梯度的过程。这是某个神经网络中的一部分神经元。 其中，$net_{o1}=h1w5+h2w6+b2$ $out_{o1}=Sigmoid(net_{o1})$ 误差函数为$E_{o1}=\\frac{target-out_{o1}}{2}$ 获得$w_5$更新所需的梯度就是求$E_{o1}$对$w_5$求导。 根据链式法则，$$\\frac{\\partial E_{o1}}{\\part w_5} = \\frac{\\part E_{o1}}{\\part out_{o1}}* \\frac{\\part out_{o1}}{\\part net_{o1}}* \\frac{\\part net_{o1}}{\\part w_5}$$其中$\\frac{\\part out_{o1}}{\\part net_{o1}}$就是Sigmoid函数求导。 根据Sigmoid函数求导公式，$$\\frac{\\part g(z)}{\\part z} = g(z)(1-g(z))$$ 上式，$g(z)$为Sigmoid函数，其导数最大值为0.25. 当神经元个数逐渐增多，前向w梯度，是后向w梯度做链式法则的结果，那么会有许多个$g’(z)$相乘。则，前向w的梯度会逐渐趋近于0。 tanh函数 相比于Sigmod函数，其输出均值为0。 缺点： 仍然存在梯度消失现象。 Relu函数 目前最常用的函数，只需判断输入是否大于零，小于零的输入，输出为0 4：参考资料《CNN入门讲解：什么是激活函数（Activation Function）》 《常用激活函数（激励函数）理解与总结》 《BP（反向传播算法）公式推导及例题解析》 《sigmoid函数的求导》","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://sci.ci/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://sci.ci/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"AI","permalink":"https://sci.ci/tags/AI/"}]},{"title":"北大人工智能实践——TensorFlow2","slug":"北大人工智能实践——TensorFlow2","date":"2020-11-12T15:10:33.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/11/12/北大人工智能实践——TensorFlow2/","link":"","permalink":"https://sci.ci/2020/11/12/%E5%8C%97%E5%A4%A7%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94TensorFlow2/","excerpt":"","text":"1：人工智能三学派 准备数据 搭建网络 优化参数 应用网络 2：神经网络设计过程鸢尾花的分类： 通过测量花萼长、花萼宽。 if语句case语句——专家系统把专家的经验告知计算机，计算机执行逻辑判断。给出分类 神经网络：采集大量数据对构成数据集。 3：张量生成张量（Tensor）：多维数组（列表） 阶：张量的维数 阶 名字 例子 0 标量 S=1 2 3 1 向量 v=[1,2,3] 2 矩阵 n 张量 创建张量 1234a = tf.constan(张量内容,dtype = 数据类型)print(a)print(a.dtype)print(a.shape) 1234tf.zeros(维度)tf.ones(维度)tf.fill(维度，指定值)c = tf.fill([2,2],9) //两行两列 123tf.random.normal(维度,mean=均值,stddev=标准差)tf.random.truncated_normal(维度，mean=均值,stddev=标准差)tf.random.uniform(维度,minval=最小值,maxval=最大值) 4：常用函数123tf.cast(张量名,dtype&#x3D;数据类型) &#x2F;&#x2F;强制转换数据类型tf.reduce_min() &#x2F;&#x2F;计算最大值tf.reduce_max() 12tf.reduce_mean(张量名,axis=操作轴) //计算张量延指定维度平均值tf.reduce_sum(张量名,axis=操作轴) //计算沿指定维度的和 未指定操作轴，则为对全部数进行操作 变量： 1tf.Variable(初始值) 数学运算 12345678tf.add()tf.subtract()tf.multiply()tf.divide()&#x2F;&#x2F;只有维度相同才能进行四则运算tf.square(张量名) 平方tf.pow() &#x2F;&#x2F;n次方tf.sqrt() &#x2F;&#x2F;开方 矩阵乘 1tf.matmul(矩阵1，矩阵2) 特征和标签对应： 123features &#x3D; tf.constant([12,23,10,14])labels &#x3D; tf.constant([0,1,1,0])dataset &#x3D; tf.data.Dataset.from_tensor_slices((features,labels)) 计算梯度 1234with tf.GradientTape() as tape: w = tf.Variable(tf.constant(3.0)) loss = tf.pow(w,2)grad = tape.gradient(loss,w) enumerate 123seq = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;]for i,element in enumerate(seq): print(i,element) 独热编码： 标记类别：1表示是，0表示否 1tf.one_hot(待转换数据，depth&#x3D;几分类) 输出符合概率分布： 1234tf.nn.softmax(x)y = tf.constant([1.01,2.01,-0.66])y_pro = tf.nn.softmax(y) 参数自更新： 123w &#x3D; tf.Variable(4)w.assign_sub(1) &#x2F;&#x2F;w-&#x3D;1print(w) 返回最大值索引 1tf.argmax(张量名，axis&#x3D;操作轴) 条件语句： 1tf.where(条件语句,真返回A,假返回B) 返回[0,1)之间的随机数 1np.random.RandomState.rand(维度) 将两个数组按垂直方向叠加（一维—&gt;二维）： 1np.vstack(数组1，数组2) 12345x,y = np.mgrid[1:3:1,2:4:0.5] //x=[[1 1 1 1] [2 2 2 2]] y=[[2 2.5 3 3.5] [2 2.5 3 3.5]] gird = np.c_[x.ravel(),y.ravel()] //ravel()降维到一维，np.c_[数组1，数组2]配对。 5：神经网络(NN)复杂度NN复杂度：多用NN层数和NN参数的个数表示。 空间复杂度 时间复杂度 学习率:$$w_{t+1} = w_t+lrgradient$$指数衰减学习率:$$指数衰减学习率=初始学习率学习率衰减率^{当前轮数/多少轮衰减一次}\\\\epoch= 40\\\\LR_BASE= 0.2\\\\LR_DECAY= 0.99\\\\LR_STEP=1$$ 123456for epoch in range(epoch): lr = LR_BASE*LR_DECAY**(epoch/LR_STEP) with tf.GradientTape() as tape: loss = tf.square(w+1) grads = tape.gradient(loss,w) w.assign_sub(lr*grads) 6：激活函数$$y = f(wx+b)$$ Sigmoid函数 $$f(x)=\\frac{1}{1+e^{-x}}$$ 1tf.nn.sigmoid(x) 易造成梯度消失 输出非0均值，收敛慢 幂运算复杂，训练时间长 Tanh函数 $$f(x) = \\frac{1-e^{-2x}}{1+e^{-2x}}$$ 1tf.math.tanh(x) Relu函数 $$\\begin{align}f(x)=&amp; max(x,0)\\\\=&amp; \\begin{cases}0\\qquad x&lt;0\\x\\qquad x&gt;=0\\end{cases}\\end{align}$$ 1tf.nn.relu(x) Leaky Relu函数 $$f(x)=max(ax,x)$$ 1tf.nn.leaky_relu(x) 初学者： 首选Relu函数 学习率设置较小值 输入特征标准化，让输入特征满足以0为均值，1为标准差的正态分布 初始参数中心化，让随机生成的参数满足以0为均值，sqrt(2/当前层输入特征个数)为标准差的正态分布 7：损失函数loss：预测值(y)与已知答案(y_)的差距 均方误差mse： $$MSE(y_,y)=\\frac{\\sum^n_{i=1}(y-y_)^2}{n}$$ 1loss_mse = tf.reduce_mean(tf.square(y-y_)) 自定义损失函数 y_:标准答案 y:预测答案$$f(y_,y)=\\begin{cases}PROFIT*(y_-y)\\quad y&lt;y_ \\ 预测的y少了，损失利润\\COST*(y-y_)\\quad y&gt;=y_ \\ 预测的y多了，损失成本\\end{cases}$$ 1loss_diy = tf.reduce_sum(tf.where(tf.greater(y,y_),COST(y-y_),PROFIT(y_-y))) //y&gt;y_?,为真COST，为假PROFIT 交叉熵损失函数CE：表征两个概率分布之间的距离 $$H(y_,y)=-\\sum y_*lny$$ 1tf.losses.categorical_crossentropy(y_,y) softmax和交叉熵结合 softmax计算概率分布 1tf.nn.softmax_cross_entropy_with_logits(y_,y) 8：缓解过拟合 正则化缓解过拟合 正则化在损失函数中引入模型复杂度指标，利用给W加权值，弱化训练数据的噪声。 $$loss=loss(y与y_)+REGULARIZER*losss(w)$$ L2正则化 1234567891011with tf.GradientTape() as tape: h1 &#x3D; tf.matmul(x_train,w1)+b1 h1 &#x3D; tf.nn.relu(h1) y &#x3D; tf.matmul(h1,w2) + b2 loss_mse &#x3D; tf.reduce_mean(tf.square(y_train - y)) loss_regularization &#x3D; [] loss_regularization.append(tf.nn.l2_loss(w1)) loss_regularization.append(tf.nn.l2_loss(w2)) loss_regularization &#x3D; tf.reduce_sum(loss_regularization) loss &#x3D; loss_mse + 0.03*loss_regularization 9：优化器$m_t$：一阶动量(与梯度相关的函数) $V_t$：二阶动量(与梯度平方相关的函数) 下降梯度$\\eta_t=lr*m_t/\\sqrt{V_t}$ 更新参数$w_{t+1}=w_t-\\eta_t$ 不同的优化器，只是定义了不同的动量函数 SGD，梯度下降法 $m_t=g_t$ $V_t=1$ $w_{t+1}=w_t-lr*g_t$ SGDM，SGD基础上增加了一阶动量 $m_t=\\beta*m_{t-1}+(1-\\beta)*g_t$ $V_t=1$ Adagrad，在SGD基础上增加二阶动量 $m_t=g_t$ $V_t=\\sum^t_{\\tau=1}g^2_\\tau$ RMSProp，SGD基础上增加二阶动量 $m_t=g_t$ $V_t=\\beta*V_{t-1}+(1-\\beta)*g^2_t$ Adam，同时结合SGDM一阶动量和RMSProp二阶动量 $m_t=\\beta*m_{t-1}+(1-\\beta)*g_t$ 修正一阶动量的偏差：$\\hat{m_t}=\\frac{m_t}{1-\\beta^t_1}$ $V_t=\\beta*V_{t-1}+(1-\\beta)*g^2_t$ 修正二阶动量的偏差：$\\hat{V_t}=\\frac{V_t}{1-\\beta^t_2}$ 10：搭建八股网络-Sequentialtf.keras搭建网络八股 六步法： import train,test model = tf.keras.models.Sequential model.compile model.fit model.summary Sequential，描述各层网络 拉直层：tf.keras.layers.Flatten() 全连接层：tf.keras.layers.Dense(神经元个数,activation=”激活函数”,kernel_regularizer=哪种正则化) activation：relu、softmax、sigmoid、tanh kernel_regularizer：tf.keras.regularizers.l1()、tf.keras.regularizers.l2() 卷积层：tf.keras.layers.Conv2D(filters = 卷积核个数,kernel_size = 卷积核尺寸,strides = 卷积步长,padding = “valid”or”same”) LSTM层：tf.keras.layers.LSTM() Compile 1model.compile(optimizer = 优化器,loss=损失函数,metrics=[&quot;准确率&quot;]) Fit 1model.fit(训练集的输入特征，训练集的标签，bathc_size&#x3D;,epochs&#x3D;,validation_data&#x3D;(测试集的输入特征，测试集的标签)，validation_split&#x3D;从训练集划分多少比例给测试集，validation_freq&#x3D;多少次epoch测试一次) Summary 1model.summary() 11：搭建网络八股-class123456789class MyModel(Model): def __init__(self): super(MyModel,self).__init__() 定义网络结构块 def call(self,x): 调用网络结构块，实现前向传播 reutrn y model = MyModel() 12：MNIST数据集提供6万张28*28像素点的0-9手写数字图片和标签，用于训练 1万张28*28像素点的0-9手写数组图片和标签，用于测试 导入MNIST数据集 12mnist &#x3D; tf.keras.datasets.mnist(x_train,y_train),(x_test,y_test)&#x3D;mnist.load_data() 作为输入特征，将数据拉伸为一维数组 1tf.keras.layers.Flatten() 13：Fasion_MNIST数据集123456789101112131415import tensorflow as tffasion = tf.keras.datasets.fashion_mnist(x_train, y_train),(x_test,y_test) = fasion.load_data()x_train,x_test = x_train/255.0,x_test/255.0model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(), tf.keras.layers.Dense(128,activation=&#x27;relu&#x27;), tf.keras.layers.Dense(10,activation = &#x27;softmax&#x27;)])model.compile(optimizer=&quot;adam&quot;,loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),metrics=[&#x27;sparse_categorical_accuracy&#x27;])model.fit(x_train,y_train,batch_size = 32,epochs=5,validation_data=(x_test,y_test),validation_freq = 1)model.summary() 14：自制数据集 在mnist_image_label文件夹下有两个文件夹mnist_train_jpg_60000和mnist_test_jpg_10000 每个文件夹分别放了对应个数的图片以及一个.txt文件，文件内容如上，jpg名+空格+标签 现在需要重写(x_train,y_train),(x_test,y_test)=mnist.load_data()中的load_data()方法。 123456789101112131415161718def generateds(path,txt): f = open(txt,&#x27;r&#x27;) contents = f.readlines() f.close() x,y_ = [],[] for content in contents: value = content.split() img_path = path+value[0] img = Image.open(img_path) img = np.array(img.convert(&#x27;L&#x27;)) img = img/255. x.append(img) y_.append(value[1]) print(&#x27;loading:&#x27;+content) x = np.array(x) y_ = np.array(y_) y_ = y_.astype(np.int64) return x,y_ 保存数据集 1np.save(保存路径带拓展,保存的内容) 15：数据增强12345678image_gen_train = tf.keras.preprocessing.image.ImageDataGenerator( rescale = 所有数据将乘以该数值 rotation = 随机旋转角度值范围 width_shift_range = 随机宽度偏移量 height_shift_range = 随机高度偏移量 horizontal_flip = 是否随机水平翻转 zoom_range = 随机缩放的范围[1-n,1+n])image_gen_train.fit(x_train) fit()中的数据是四位数据，所以需要对其reshape x_train = x_train.reshape(x_train.shape[0],28,28,1) 最后的1表示灰度值。 model.fit()方法内修改为 1model.fit(image_gen_train.flow(x_train,y_train,batch_size = 32),epochs=5,validation_data=(x_test,y_test),validation_freq = 1) 16：断点续训读取模型： load_weights(路径文件名) 1234checkpoint_save_path = &quot;./checkpoint/mnist.ckpt&quot;if os.path.exists(checkpoint_save_path + &#x27;.index&#x27;) print(&#x27;-----load the model------&#x27;) model.load_weights(checkpoint_save_path) 保存模型 12345callback = tf.keras.callbacks.ModelCheckpoint( filepath = 路径文件名, save_weights_only=True/False, save_best_only = True/False)history = model.fit(……callbacks = [cp_callback]) 17：参数提取model.trainable_variables 返回模型中可训练的参数 设置print输出格式 1np.set_printoptions(threshold = 超过多少省略显示) #threshold=np.inf表示无限 12345678np.set_printoptions(threshold = np.inf)print(model.trainable_variables)file = open(&#x27;./weights.txt&#x27;,&#x27;w&#x27;)for v in model.trainable_variables: file.write(str(v.name)+&#x27;\\n&#x27;) file.write(str(v.shape)+&#x27;\\n&#x27;) file.write(str(v.numpy())+&#x27;\\n&#x27;)file.close() 18：acc曲线和loss曲线可视化12345history = model.fit()acc = history.history[&#x27;sparse_categorical_accuracy&#x27;] #训练集准确率val_acc = history.history[&#x27;val_sparse_categorical_accuracy&#x27;] #测试集准确率loss = history.history[&#x27;loss&#x27;] #训练集lossval_loss = history.history[&#x27;val_loss&#x27;] #测试集loss 画图 123456789101112plt.subplot(1,2,1)plt.plot(acc,label=&quot;Training Accuracy&quot;)plt.plot(val_acc,label=&quot;Validation Accuracy&quot;)plt.title(&quot;Training and Validation Accuracy&quot;)plt.legend()plt.subplot(1,2,2)plt.plot(loss,label=&quot;Training Loss&quot;)plt.plot(val_loss,label=&quot;Validation Loss&quot;)plt.title(&#x27;Training and Validation Loss&#x27;)plt.legend()plt.show() 19：样例预测predict(输入特征,batch_size=整数) 123456789#复现模型model = tf.keras.models.Sequential([ tf.keras.layers.Flatten(), tf.keras.layers.Dense(128,activation = &#x27;relu&#x27;), tf.keras.layers.Dense(10,activation = &#x27;softmax&#x27;)])#加载参数model.load_weights(model_save_path)#预测结果result = model.predict(x_predict) 20：卷积计算过程原始彩色图片——&gt;若干层特征提取——&gt;全连接网络 主要模块：(CBAPD) 卷积(Convolutional)-&gt;批标准化(BN)-&gt;激活(Activation)-&gt;池化(Pooling)-&gt;舍弃(Dropout) 21：感受野感受野：卷积神经网络各输出特征图中的每个像素点，在原始输入图片上映射区域的大小。 比如： 1： 5x5原始图，使用3x3卷积核，生成的3x3特征图，那么其感受野是3. 将生成的3x3特征图，再次使用3x3卷积核作用，生成1x1特征图，那么这个特征图相对于原始图，感受野为5. 2： 5x5原始图，使用5x5卷积核，生成1x1特征图，其感受野同样为5 长款x大于10时，两层3x3卷积核性能优于一层5x5卷积核 22：全零填充特征图一圈填充零。 特征图边长$$padding=\\begin{cases}SAME(全0填充)\\ \\frac{入长}{步长}\\ (向上取整)\\VALID(不全0填充)\\ \\frac{入长-核长+1}{步长}\\ (向上取整)\\end{cases}$$ 23：描述卷积层12345678tf.keras.layers.Conv2D( filter = 卷积核个数, kernel_size = 卷积核尺寸， #正方形写核长整数，或（核高，核宽） strides = 滑动步长, #横纵相同写步长整数，或（纵向步长，横向步长） padding = &quot;same&quot; or &quot;valid&quot; #全零填充same，非全零valid activation = &quot;relu&quot; or &quot;sigmoid&quot;, input_shape = (高，宽，通道数) #输入特征图维度，可省) 24：批标准化（Batch Normalization）标准化：使数据符合0均值，1为标准差的分布 批标准化：对一小批数据，做标准化$$H’^k_i = \\frac{H^k_i-\\mu^k_{batch}}{\\sigma_{batch}^k}$$k：第k个卷积核 i：第i个像素点 H’：批标准化之后 H：批标准化之前 上述式子，要求批标准化之前的特征数据即满足正态分布。 通常使用：$$x^k_i=\\gamma_kH’^k_i+\\beta_k$$$\\gamma_k$:缩放因子 $\\beta_k$:偏移因子 调整分布的宽窄和偏移。 BN层位于，卷积层之后，激活层之前。 1tf.keras.layers.BatchNormalization() 25：池化池化用于减少特征数据量。 最大池化，均值池化 123456tf.keras.layers.MaxPool2D( pool_size=池化核尺寸 strides=池化步长 padding=&#x27;valid&#x27; or &#x27;same&#x27; #全零填充？)tf.keras.layers.AveragePooling2D() 26：舍弃（dropout）在神经网络训练时，将一部分神经元按照一定概率从神经网络中暂时舍弃，神经网络使用时，被舍弃的神经元恢复连接。 1tf.keras.layers.Dropout(舍弃概率) 27：Cifar10数据集五万张32*32像素点的是分类彩色图片和标签，用于训练 测试1万张 28：LeNet输入：32*32","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://sci.ci/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"如何利用ADB开发王者荣耀外挂","slug":"如何利用ADB开发王者荣耀外挂","date":"2020-10-24T09:51:01.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/24/如何利用ADB开发王者荣耀外挂/","link":"","permalink":"https://sci.ci/2020/10/24/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8ADB%E5%BC%80%E5%8F%91%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E5%A4%96%E6%8C%82/","excerpt":"","text":"1：思路ADB全称安卓设备调试工具，是谷歌官方提供帮助安卓开发者调试自身应用的一个轻量级工具包，总大小只有几兆。通过shell指令可以实现对安装了安卓系统的手机进行控制，包括开关机，开关应用程序，控制屏幕、音量、相机等操作。利用ADB控制屏幕的功能，可以通过程序来实现快速换装、婉儿一键上天等操作。由于ADB是一种模拟人在屏幕上操作的工具，不会修改王者荣耀的内部文件，也不用root手机，所有是不会被王者荣耀检测到，也不会被封号。只需要简单配置让安装了ADB的电脑连接手机，即可实现程序控制王者角色。因为ADB支持通过TCP/IP协议，可以让电脑脱离数据线远程调试手机。 那么这个外挂完整的工作过程是什么样的呢？ 在电脑上安装ADB工具，并将其目录放到系统环境或用户环境变量中。开启手机的USB调试功能，通过ADB远程调试功能连接手机。 编写一个安卓应用程序，程序使用安卓的悬浮窗功能。在王者荣耀面板上层悬浮一个按钮。点击按钮，发送一个http的get请求。 在安装了ADB的电脑上安装一个http服务器用于接收悬浮按钮发送的get请求。简单的http服务器是基于python内自带的http server。 http服务器接收到请求后，执行已经写好的ADB指令，控制手机，实现婉儿一键上天。 看看使用效果吧！ 2：ADB工具及调试手机2.1 下载ADB在网上下载ADB工具包：下载地址（需要连接外网） 解压后，获得一个名为platform-tools的工具包，包内含有adb.exe程序，即为安卓调试工具。 2.2 设置环境在windows中搜索huanjing打开环境变量面板。 依次点击环境变量，点击系统变量下的名为Path的一行，点击编辑. 点击新建，将platform-tools文件夹的完整路径添加到变量中，例：我的工具包存放在C:\\Users\\9752\\.AndroidStudio3.5\\platform-tools 点击确认，然后关闭此窗口。 在windows中搜索cmd，打开终端窗口，输入adb回车。 出现上文，则配置成功。 2.3 连接手机打开手机开发者模式 通常是手机设置中，找到版本信息或者内核信息，然后点击七下，在设置中就会出现开发者模式了。具体方法可以自行谷歌。 打开开发者模式的USB调试 通过原装数据线连接电脑，有的非原装数据线只能充电不能传输数据。 连接电脑后，需要在手机上允许此电脑调试，最好一律允许此电脑调试。 在终端中输入adb devices查看是否连接上了手机。 2.4 开启远程调试 也可不用远程，直接使用数据线也是可以的。 让手机和电脑处在相同的WiFi下 电脑通过数据线连接手机后，终端输入 1adb tcpip 5555 拔掉数据线。在WiFi设置里，查看手机的局域网ip地址，通常是192.168.xxx.xxx，或者10.xxx.xxx.xxx 修改为你的手机ip地址，连接手机： 1adb connect 192.168.xxx.xxx:5555 2.5 主要用到的ADB指令123456789// 模拟点击，屏幕上横坐标纵坐标分别为100 120的位置// 要查看具体坐标值，可以打开开发者选项-&gt;指针位置adb shell input tap 100 120// 模拟滑动，从位置（0,1000）滑动到(800,600)adb shell input swipe 0 1000 800 600// 模拟长按，在位置（100,200）长按500毫秒adb shell input swipe 100 200 100 200 500// 开启adb服务 其中位置信息，需要在手机上获取。 在开发者模式中打开显示指针 通过按住屏幕，就能实时显示按压住的位置的x轴和y轴信息。 此时已经可以尝试用ADB指令控制屏幕了。 2.6 控制婉儿上天不同的手机，需要自己寻找合适的坐标点来实现婉儿的技能释放。 123456789向前移动：abd shell input swipe 450 1105 544 983 600向后移动：adb shell input swipe 450 1105 217 1400 800普工：adb shell input tap 2726 1226一技能：adb shell input swipe 2290 1267 2748 790 100二技能：adb shell input swipe 2451 1010 2793 670 100三技能：adb shell input swipe 2721 860 2721 860 200向前直线上天：adb shell &quot;input swipe 2451 1010 2793 670 100&amp;&amp;input swipe 2721 860 2721 860 200&amp;&amp;input swipe 450 1105 544 983 600&amp;&amp;input tap 2726 1226&amp;&amp;input swipe 2290 1267 2748 790 100&amp;&amp;input swipe 450 1105 743 781 1000&quot;原地上天：adb shell &quot;input swipe 2451 1010 2793 670 100&amp;&amp;input swipe 2721 860 2721 860 200&amp;&amp;input swipe 450 1105 544 983 600&amp;&amp;input tap 2726 1226&amp;&amp;input swipe 2290 1267 2100 1376 100&amp;&amp;input swipe 450 1105 217 1400 800&amp;&amp;input swipe 450 1105 777 1150 500&quot; 2.7 一键换装123456打开商店： adb shell input tap 2873 102装备： adb shell input tap 2173 1278出售： adb shell input tap 2525 1153关闭商店： adb shell input tap 2624 167购买预选：adb shell input tap 2832 243完整操作链：adb shell &quot;input tap 2873 102&amp;&amp;input tap 2173 1278&amp;&amp;input tap 2525 1153&amp;&amp;input tap 2624 167&amp;&amp;input tap 2832 243&quot; 3：搭建http服务器在电脑上安装好python环境。 新建一个takeoff.py文件。编辑文件： 12345678910111213141516171819202122232425262728293031import osfrom http.server import BaseHTTPRequestHandlerfrom urllib import parseclass GetHandler(BaseHTTPRequestHandler): def do_GET(self): parsed_path = parse.urlparse(self.path) query = parse.parse_qs(parsed_path.query) if query[&#x27;skill&#x27;][0] == &#x27;1&#x27;: os.system(&#x27;adb shell &quot;input swipe 2451 1010 2793 670 100&amp;&amp;input swipe 2721 860 2721 860 200&amp;&amp;input swipe 450 1105 544 983 600&amp;&amp;input tap 2726 1226&amp;&amp;input swipe 2290 1267 2748 790 100&amp;&amp;input swipe 450 1105 743 781 1000&quot;&#x27;) message = &#x27;执行直线起飞指令&#x27; elif query[&#x27;skill&#x27;][0] == &#x27;2&#x27;: os.system(&#x27;adb shell &quot;input swipe 2451 1010 2793 670 100&amp;&amp;input swipe 2721 860 2721 860 200&amp;&amp;input swipe 450 1105 544 983 600&amp;&amp;input tap 2726 1226&amp;&amp;input swipe 2290 1267 2100 1376 100&amp;&amp;input swipe 450 1105 217 1400 800&amp;&amp;input swipe 450 1105 777 1150 500&quot;&#x27;) message = &#x27;执行原地起飞指令&#x27; elif query[&#x27;skill&#x27;][0] == &#x27;3&#x27;: os.system(&#x27;adb shell &quot;input tap 2873 102&amp;&amp;input tap 2173 1278&amp;&amp;input tap 2525 1153&amp;&amp;input tap 2624 167&amp;&amp;input tap 2832 243&quot;&#x27;) message = &#x27;执行快速换装指令&#x27; else: message = &#x27;无指令运行&#x27; self.send_response(200) self.send_header(&#x27;Content-Type&#x27;, &#x27;text/plain; charset=utf-8&#x27;) self.end_headers() self.wfile.write(message.encode(&#x27;utf-8&#x27;))if __name__ == &#x27;__main__&#x27;: from http.server import HTTPServer server = HTTPServer((&#x27;0.0.0.0&#x27;, 9797), GetHandler) print(&#x27;服务器启动成功, 使用&lt;Ctrl-C&gt; 来停止。。&#x27;) server.serve_forever() 需要将os.system()中的内容替换为自己的。 修改上面的程序很重要，因为不同分辨率手机，需要的adb指令是不一样的，如果不修改，基本上不可能会实现理想的操作，除非你跟我用的相同的手机，三星S10+。 通过python运行这个文件就已经建立好了http服务器。 123python3 filepath/takeoff.py#filepath修改为takeoff.py的路径。比如C:/Users/999/Desktop/takeoff.py#显示，服务器启动成功, 使用&lt;Ctrl-C&gt; 来停止。。则启动成功 查看电脑的局域网ip地址，终端输入 1ipconfig 通常是192.168.xxx.xxx，或者10.xxx.xxx.xxx 在电脑浏览器中，访问：192.168.xxx.xxx:9797/?skill=1就能实现直线上天了。skill =2和skill=3分别对应原地上天和一键换装。 此时，如果在手机浏览器上访问192.168.xxx.xxx:9797/?skill=1，应该是访问不通的，因为windows自带的防火墙，是不允许局域网下的其他设备访问未开放的端口的。你需要关闭局域网防火墙。 关闭防火墙是存在一定风险的，如果你用的公共场所的WiFi，我建议不要关闭。如果是家庭WiFi，记得在使用完后再次开启防火墙。 windows搜索fanghuoqiang注意不要用汉字搜索，用拼音。打开防火墙和网络保护 如果是家庭WiFi，则点击专用网络。 将防火墙关闭。 此时在手机浏览器上也能访问到http服务器了。 4：王者局内悬浮按钮新建一个安卓项目，开发一个悬浮按钮，在王者内点击按钮，就能给http服务器发送请求，然后服务器通过adb再返过来控制局内角色。 开发新项目，我直接选择站在巨人肩膀上。https://github.com/dongzhong/TestForFloatingWindow 直接对这个仓库里提供的悬浮窗功能进行修改。。关键程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//FloatingButtonService2.javaprivate void showFloatingWindow() &#123; if (Settings.canDrawOverlays(this)) &#123; button2 = new Button(getApplicationContext()); button2.setText(&quot;装&quot;);//按键上的字，表示按下这个按钮一键换装 button2.setBackgroundColor(Color.argb(120,0,255,0)); windowManager.addView(button2, layoutParams); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; send(); &#125; &#125;); button2.setOnTouchListener(new FloatingOnTouchListener()); &#125; &#125; private void send() &#123; //开启线程，发送get请求 new Thread(new Runnable() &#123; @Override public void run() &#123; //value对应http服务器接收的技能 //在http服务器中，设置的，skill=1，直线上天，skill=2，原地上天，skill=3，换装 char value = &#x27;3&#x27;; //这里修改为http服务器地址。 String path = &quot;http://192.168.0.109:9797/?skill=&quot;+value; try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); InputStream in = conn.getInputStream(); conn.disconnect(); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 这只是其中一个一键换装的按钮，另外还需要修改一键上天的按钮。在FloatingButtonService.java中，两个程序，都相似。。修改完后，直接编译，就可以使用了。 完整的项目地址：https://github.com/xieqifei/Expandskill 安卓项目，可以直接通过git克隆 1git clone https://github.com/xieqifei/Expandskill.git 修改程序后，直接编译即可。 5：参考资料《android adb常用命令收集》 《Android adb远程调试》 《http.server — 实现 Web 服务器的基础类》 《Android HTTP请求方式:HttpURLConnection》 《Android悬浮窗的实现》","categories":[{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/categories/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"https://sci.ci/tags/ADB/"},{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://sci.ci/tags/Java/"}]},{"title":"已知多个地点经纬度的最优路径规划","slug":"已知多个地点经纬度的最优路径规划","date":"2020-10-18T22:42:00.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/19/已知多个地点经纬度的最优路径规划/","link":"","permalink":"https://sci.ci/2020/10/19/%E5%B7%B2%E7%9F%A5%E5%A4%9A%E4%B8%AA%E5%9C%B0%E7%82%B9%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9A%84%E6%9C%80%E4%BC%98%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/","excerpt":"","text":"1：为什么规划路线这是统一美团饿了么订单后的后续工作，要求对多个指定的配送地点进行统计，并计算出从花店出发，到配送完所有地点返回花店的可能路程，并得出最优的路线。。 2：设计思想假设有四个配送点ABCD，配送的路线会有24种可能，枚举所有可能，并计算从花店到第一个配送点，依次再有三个配送点，然后返回花店的距离。比较这二十四种路线的距离，距离最少的，选为最优路线。 在Python中，使用itertools迭代库中的permutations方法，对路径可能进行排列。通过haversine公式计算两个经纬度之间的距离。 3：Python程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@file_name :shortest_dist.py@description :@time :2020/10/18 20:24:21@author :Qifei@version :1.0&#x27;&#x27;&#x27;from math import radians, cos, sin, asin, sqrtfrom itertools import permutationsclass Route(): def __init__(self,data): self.data = data self.home = &#123;&#x27;lng&#x27;:&#x27;104.270910&#x27;,&#x27;lat&#x27;:&#x27;30.876583&#x27;&#125; self.distances = [] self.routes = [] #排列各种可能的路线 self.iter_routes = permutations(data,len(data)) #将排列后的迭代类型数据转为列表类型 for iter_route in self.iter_routes: self.routes.append(list(iter_route)) #返回最优路线的列表排序 def best_route(self): for route in self.routes: distance = 0 if len(route) &gt; 1: for i in range(len(route)-1): distance += self.calc_distance(route[i+1][&#x27;lng&#x27;],route[i+1][&#x27;lat&#x27;],route[i][&#x27;lng&#x27;],route[i][&#x27;lat&#x27;]) distance += self.calc_distance(self.home[&#x27;lng&#x27;],self.home[&#x27;lat&#x27;],route[0][&#x27;lng&#x27;],route[0][&#x27;lat&#x27;]) distance += self.calc_distance(self.home[&#x27;lng&#x27;],self.home[&#x27;lat&#x27;],route[-1][&#x27;lng&#x27;],route[-1][&#x27;lat&#x27;]) self.distances.append(distance) return self.routes[self.distances.index(min(self.distances))] #计算两个经纬度之间的距离 def calc_distance(self,lon1, lat1, lon2, lat2): # 将十进制度数转化为弧度 lon1, lat1, lon2, lat2 = map(radians, [float(lon1), float(lat1), float(lon2), float(lat2)]) # haversine公式 dlon = lon2 - lon1 dlat = lat2 - lat1 a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2 c = 2 * asin(sqrt(a)) r = 6371 # 地球平均半径，单位为公里 return c * r * 1000if __name__ == &#x27;__main__&#x27;: data = [&#123;&#x27;name&#x27;:&#x27;大弯中学&#x27;,&#x27;lng&#x27;:&#x27;104.278184&#x27;,&#x27;lat&#x27;:&#x27;30.879862&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;怡湖公园&#x27;,&#x27;lng&#x27;:&#x27;104.261332&#x27;,&#x27;lat&#x27;:&#x27;30.878314&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;大弯小学&#x27;,&#x27;lng&#x27;:&#x27;104.270611&#x27;,&#x27;lat&#x27;:&#x27;30.880657&#x27;&#125;,&#123;&#x27;name&#x27;:&#x27;长河郡&#x27;,&#x27;lng&#x27;:&#x27;104.278201&#x27;,&#x27;lat&#x27;:&#x27;30.872356&#x27;&#125;] route = Route(data) # print(route.calc_distance(data[0][&#x27;lng&#x27;],data[0][&#x27;lat&#x27;],data[0][&#x27;lng&#x27;],data[0][&#x27;lat&#x27;])) best_route = route.best_route() print(best_route) # print(route.distances)","categories":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/categories/Python/"}],"tags":[{"name":"-Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"}]},{"title":"外卖平台订单爬取之美团外卖商家版","slug":"外卖平台订单爬取之美团外卖商家版","date":"2020-10-17T16:49:09.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/17/外卖平台订单爬取之美团外卖商家版/","link":"","permalink":"https://sci.ci/2020/10/17/%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0%E8%AE%A2%E5%8D%95%E7%88%AC%E5%8F%96%E4%B9%8B%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E5%95%86%E5%AE%B6%E7%89%88/","excerpt":"","text":"1：root手机昨天，我利用mitmproxy成功拦截了饿了么服务器返回的订单信息。今天，我准备故技重施，获取美团订单。残酷的现实给我炽热地心浇了一盆冷水。无论我如何调整mitmproxy和美团外卖商家版，都无法获取到美团服务器返回的数据。更确切地说，美团服务器似乎发现，有这么一个小偷，准备偷取它返回给客户端地数据。因此拒绝给客户端传递数据。 我在网上找了一些解答，在安卓7.0之后，安卓系统允许安卓应用不信任用户上传地CA证书，众所周知，在中间人攻击中，将代理服务器的CA证书添加到安卓用户证书里，这样代理服务器在客户端和https服务端之间做个信使，他们的来回信件，信使就能拆开阅读，再封好发出去。现在安卓系统允许安卓应用设置是否信任用户证书，很明显，美团外卖商家版，不支持用户自定义证书。 好在，安卓系统有个要求，就是系统证书都是被认可的。而添加系统证书，需要修改手机system文件夹，需要将手机root。 待root手机：三星S8+ 工具：Odin线刷工具，第三方recovery TWRP，Tomato卡刷包（卡刷包含root）。 2：添加CA证书为系统证书mitmproxy会在其运行目录生成一个.mitmproxy隐藏目录，目录中的mitmproxy-ca-cert.pem是可以直接放到系统证书目录下的证书。首先需要将它更名为统一的格式。 1234#openssl版本在1.0以上的版本的执行这一句openssl x509 -inform PEM -subject_hash_old -in mitmproxy-ca-cert.pem #openssl版本在1.0以下的版本的执行这一句openssl x509 -inform PEM -subject_hash -in mitmproxy-ca-cert.pem 生成347bacb5证书的hash值，然后将mitmproxy-ca-cert.pem更名为347bacb5.0 将更名后的证书放到安卓系统证书目录，root后的安卓手机，可以直接打开RE管理器进入系统目录 1&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts 重启手机。修改wifi代理，并连接mitmproxy。 打开美团外卖商家版，不再报没有网络连接的错误。此时即可以从代理中截获解码后的信息了。 3：截获订单请求数据开启mitmproxy，开始收集请求。在美团上下单，可以截获下单后，美团服务器发送到客户端的订单信息。 进行中订单请求地址，部分内容已打码： 1https:&#x2F;&#x2F;eapi.waimai.meituan.com&#x2F;api&#x2F;retail&#x2F;order&#x2F;supplement&#x2F;increment&#x2F;orders?region_id&#x3D;10***0100&amp;region_version&#x3D;153***1&amp;__skck&#x3D;8f5973b0***&amp;__skts&#x3D;16***8&amp;__skua&#x3D;d41d8c***8427e&amp;__skno&#x3D;94899011-*** 预订单请求地址： 1https:&#x2F;&#x2F;eapi.waimai.meituan.com&#x2F;api&#x2F;retail&#x2F;order&#x2F;pre&#x2F;orders?region_id&#x3D;1000510100&amp;region_version&#x3D;1534166411&amp;__skck&#x3D;8f5973b085446090f224af74e30e0181&amp;__skts&#x3D;1603035614&amp;__skua&#x3D;d41d8cd98f00b204e9800998ecf8427e&amp;__skno&#x3D;ed5fa567-5e33-4186-806a-e1ee884b5d5c&amp;__skcy&#x3D;hNEhcBUBRBinXjXwhZ%2BoMtvkMu8%3D 进行中响应内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302&#123; &quot;msg&quot;: &quot;Success&quot;, &quot;code&quot;: 0, &quot;data&quot;: &#123; &quot;serverTime&quot;: 1603013219, &quot;news&quot;: [&#123; &quot;agreeBtn&quot;: 0, &quot;reject_reason&quot;: &quot;&quot;, &quot;rejectBtn&quot;: 0, &quot;apply_refund_type&quot;: 0, &quot;appealReason&quot;: &quot;&quot;, &quot;pay_status&quot;: 3, &quot;payExpireTime&quot;: 0, &quot;orderDescription&quot;: &quot;&quot;, &quot;pay_status_desc&quot;: &quot;已付款&quot;, &quot;apply_reason&quot;: &quot;&quot;, &quot;applyRefundTime&quot;: 0, &quot;rejectRefundTime&quot;: &quot;&quot;, &quot;appealRefundTime&quot;: 0, &quot;refundFinishTime&quot;: &quot;&quot;, &quot;isPartRefundApply&quot;: 0, &quot;isAllowPartRefund&quot;: 0, &quot;isAllowAllRefund&quot;: false, &quot;hasMigratedToRetail&quot;: true, &quot;returnSubStatus&quot;: 0, &quot;logistics&quot;: &#123; &quot;id&quot;: -1, &quot;type&quot;: 101, &quot;icon&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;status&quot;: -1, &quot;statusDesc&quot;: &quot;&quot;, &quot;sendTime&quot;: -1, &quot;confirmTime&quot;: -1, &quot;arrivePoiTime&quot;: -1, &quot;selfDeliveryTime&quot;: -1, &quot;fetchTime&quot;: -1, &quot;completedTime&quot;: -1, &quot;cancelTime&quot;: -1, &quot;collectTime&quot;: 0, &quot;departureTime&quot;: 0, &quot;reachTime&quot;: 0, &quot;takeTime&quot;: 0, &quot;timeOut&quot;: -1, &quot;code&quot;: &quot;&quot;, &quot;valid&quot;: 1, &quot;shippingFee&quot;: 0.0, &quot;tipFee&quot;: 0.0, &quot;shippingTips&quot;: &quot;&quot;, &quot;couponAmount&quot;: 0.0, &quot;activityName&quot;: &quot;&quot;, &quot;activityAmount&quot;: 0.0, &quot;extraFee&quot;: 0.0, &quot;payAmount&quot;: 0.0, &quot;shippingFeeBase&quot;: 0.0, &quot;payType&quot;: &quot;&quot;, &quot;zbType&quot;: 0, &quot;orderDistance&quot;: 0.0, &quot;ifSelfLogistics&quot;: 0, &quot;isCanChangeSelfLogistics&quot;: 0, &quot;dispatcher&quot;: &#123; &quot;name&quot;: &quot;&quot;, &quot;mobile&quot;: &quot;&quot;, &quot;icon&quot;: &quot;&quot;, &quot;role&quot;: &quot;配送员&quot;, &quot;type&quot;: -1, &quot;typeName&quot;: &quot;&quot; &#125;, &quot;dispatchMaster&quot;: &#123; &quot;name&quot;: &quot;站点&quot;, &quot;mobile&quot;: &quot;&quot;, &quot;icon&quot;: &quot;&quot;, &quot;role&quot;: &quot;站长&quot; &#125;, &quot;dispatchAssistant&quot;: &#123; &quot;name&quot;: &quot;站点备用&quot;, &quot;mobile&quot;: &quot;&quot;, &quot;icon&quot;: &quot;&quot;, &quot;role&quot;: &quot;站长助理&quot; &#125;, &quot;unionDispatcher&quot;: &#123; &quot;name&quot;: &quot;&quot;, &quot;mobile&quot;: &quot;&quot; &#125;, &quot;logisticsSubCode&quot;: &quot;&quot;, &quot;dispatchOrderId&quot;: -1, &quot;delayPushSecond&quot;: 0, &quot;delayPushMin&quot;: 0, &quot;assignTime&quot;: 0, &quot;thirdLogisticsCode&quot;: &quot;&quot; &#125;, &quot;printRelayBarCode&quot;: false, &quot;utime&quot;: 1603013218, &quot;refundType&quot;: -1, &quot;isCanChangeSelfLogistics&quot;: 0, &quot;refundProcessEndTips&quot;: &quot;&quot;, &quot;ifSelfLogistics&quot;: 0, &quot;cancelButtonShow&quot;: 0, &quot;foodDoneInfo&quot;: &#123; &quot;isShowFoodDoneBlock&quot;: 0, &quot;isfoodDone&quot;: 0, &quot;foodDoneStatus&quot;: &quot;拣货完成&quot;, &quot;foodDoneTime&quot;: 0, &quot;foodSendOutTimeDeadline&quot;: 0, &quot;diningMinutes&quot;: 0, &quot;foodSendDeviceInfo&quot;: &quot;&quot; &#125;, &quot;logisticsAbnormalInfo&quot;: &#123; &quot;isLogisticsAbnormal&quot;: 0, &quot;logisticsAbnormalDesc&quot;: &quot;&quot;, &quot;logisticsAbnormalType&quot;: 0, &quot;isShowLogisticsReport&quot;: 0, &quot;logisticsReportDesc&quot;: &quot;&quot; &#125;, &quot;refundOtherInfos&quot;: &#123; &quot;returnStatusDesc&quot;: &quot;&quot;, &quot;returnSubStatusDesc&quot;: &quot;&quot;, &quot;returnMaxPayAcount&quot;: 100.0, &quot;returnSubStatus&quot;: 0, &quot;countDownDesc&quot;: &quot;&quot;, &quot;refundViewId&quot;: 0, &quot;serviceType&quot;: 0, &quot;refundRuleUrl&quot;: &quot;http://s3plus.sankuai.com/v1/mss_03d0d9cf21144ba0b7747ba1dc1acf6e/order/refund_rules.html&quot; &#125;, &quot;refundInfoList&quot;: [], &quot;refundGoodsInfoList&quot;: [], &quot;isAppealApply&quot;: 0, &quot;compensationInfo&quot;: &#123; &quot;id&quot;: 0, &quot;title&quot;: &quot;&quot;, &quot;time&quot;: 0, &quot;moneyDesc&quot;: &quot;&quot;, &quot;reason&quot;: &quot;&quot;, &quot;pictures&quot;: [], &quot;appealInfo&quot;: &quot;&quot; &#125;, &quot;orderImValid&quot;: 1, &quot;imGuideContent&quot;: &quot;&quot;, &quot;imReplyDefaultContent&quot;: &quot;&quot;, &quot;isAllowPriceDiffRefund&quot;: false, &quot;confirmDeliveryStatus&quot;: 0, &quot;id&quot;: 56367**02186, &quot;wm_poi_id&quot;: 5636780, &quot;wm_poi_order_dayseq&quot;: 1, &quot;wm_order_id_view&quot;: 563678***186, &quot;num&quot;: 1, &quot;poi_name&quot;: &quot;**鲜花店&quot;, &quot;order_source&quot;: 1, &quot;order_source_desc&quot;: &quot;手机APP下单&quot;, &quot;shipping_fee&quot;: 0.0, &quot;recipient_name&quot;: &quot;谢先生&quot;, &quot;recipient_phone&quot;: &quot;178**858,4109&quot;, &quot;recipient_address&quot;: &quot;&quot;, &quot;total_after&quot;: 10.0, &quot;total_before&quot;: 10.0, &quot;boxpriceTotal&quot;: 0.0, &quot;remark&quot;: &quot;[贺卡内容]贺卡内容 [其他备注]备注内容&quot;, &quot;environmentalFriendlyOrder&quot;: 0, &quot;status&quot;: 4, &quot;order_time&quot;: 1603013207, &quot;order_time_fmt&quot;: &quot;10-18 17:26&quot;, &quot;confirmOrderTime&quot;: 1603013218, &quot;details&quot;: [&#123; &quot;id&quot;: 1945297344, &quot;food_name&quot;: &quot;8枝红色非洲菊 &quot;, &quot;food_price&quot;: 10.0, &quot;originalFoodPrice&quot;: 10.0, &quot;unit&quot;: &quot;份&quot;, &quot;count&quot;: 1, &quot;box_num&quot;: 1.0, &quot;box_price&quot;: 0.0, &quot;cartId&quot;: 0, &quot;cartName&quot;: &quot;1号口袋&quot;, &quot;upcCode&quot;: &quot;&quot;, &quot;skuCode&quot;: &quot;&quot;, &quot;locatorCode&quot;: &quot;&quot;, &quot;discountPoint&quot;: &quot;&quot;, &quot;discountRemark&quot;: &quot;&quot;, &quot;picUrl&quot;: &quot;http://p0.meituan.net/wmproduct/d852b****0fa2d7f3d1adf7d95423.jpg&quot;, &quot;specification&quot;: &quot;&quot; &#125;], &quot;discounts&quot;: [], &quot;tips&quot;: [], &quot;canBeCancelled&quot;: 1, &quot;cancel_reason&quot;: &quot;&quot;, &quot;is_pre_order&quot;: 0, &quot;delivery_btime&quot;: 0, &quot;pre_order_delivery_info&quot;: &quot;&quot;, &quot;pay_utime&quot;: 1603013218, &quot;pay_utime_fmt&quot;: &quot;2020-10-18 17:26:58&quot;, &quot;online_paid_info&quot;: &quot;&quot;, &quot;pre_order_remind&quot;: 0, &quot;pre_order_tip&quot;: &quot;预订单：期望送达时间&quot;, &quot;overtime_paid_info&quot;: &quot;&quot;, &quot;invoice_title&quot;: &quot;&quot;, &quot;wm_order_pay_type&quot;: 2, &quot;actual_pay_type&quot;: 2, &quot;dispatch_code&quot;: &quot;&quot;, &quot;longitude&quot;: 104251302, &quot;latitude&quot;: 30880900, &quot;inArea&quot;: 1, &quot;orderDistance&quot;: 2120.0, &quot;addressLongitude&quot;: 104251302, &quot;addressLatitude&quot;: 30880900, &quot;riderPayment&quot;: &quot;&quot;, &quot;zbShippingFee&quot;: &quot;&quot;, &quot;zbShippingTips&quot;: &quot;&quot;, &quot;tipsVos&quot;: [], &quot;status_desc&quot;: &quot;已接单&quot;, &quot;delivery_btime_fmt&quot;: &quot;&quot;, &quot;logistics_code&quot;: &quot;&quot;, &quot;logisticsService&quot;: 1, &quot;logistics_status&quot;: -1, &quot;hasFrozen&quot;: 0, &quot;estimateArrivalTime&quot;: 1603020418, &quot;poi_push_day&quot;: 20201018, &quot;bindedPhone&quot;: &quot;178**858,4109&quot;, &quot;isLargeAmountOrder&quot;: 0, &quot;userOrderCount&quot;: 2, &quot;pickType&quot;: 0, &quot;isUsePrivacyPhone&quot;: 1, &quot;privacyPhone&quot;: &quot;1788**4858,4109&quot;, &quot;phoneShow&quot;: &quot;178**8转4109&quot;, &quot;privacyPhoneStatus&quot;: 0, &quot;recipientPhoneShow&quot;: &quot;手机尾号2605&quot;, &quot;packageBagMoney&quot;: 0.0, &quot;wmUserId&quot;: 371311890, &quot;confirmTime&quot;: 1603013218, &quot;cansunStatus&quot;: 0, &quot;cansunInfo&quot;: [], &quot;wmChargeBusiness&quot;: &#123; &quot;wmOrderViewId&quot;: 56367802727202186, &quot;activityAmount&quot;: &quot;0.0&quot;, &quot;activityDetails&quot;: [], &quot;commisionAmount&quot;: &quot;-1.0&quot;, &quot;settleAmount&quot;: &quot;8.95&quot;, &quot;offlineOrderSkPayAmount&quot;: &quot;0.0&quot;, &quot;shippingType&quot;: &quot;0000&quot;, &quot;commisionDetails&quot;: [&#123; &quot;chargeAmount&quot;: &quot;-1.0&quot;, &quot;chargeDesc&quot;: &quot;服务费&quot; &#125;], &quot;userOnlinePayAfter&quot;: &quot;&quot;, &quot;discounts&quot;: [], &quot;isDowngrade&quot;: false, &quot;shippingFee&quot;: &quot;0.0&quot;, &quot;riderPayment&quot;: &quot;&quot;, &quot;isRiderPay&quot;: false, &quot;giftDetails&quot;: [], &quot;userPayAmount&quot;: &quot;0.0&quot;, &quot;foodAmount&quot;: &quot;10.0&quot;, &quot;userPayTotalAmount&quot;: &quot;10.0&quot;, &quot;donateAmount&quot;: &quot;-0.05&quot;, &quot;agreementAmount&quot;: 0.0, &quot;chargeMode&quot;: 1 &#125;, &quot;userTips&quot;: [&#123; &quot;category&quot;: 17, &quot;type&quot;: &quot;下单2次&quot;, &quot;info&quot;: &quot;该用户过去90天完成订单数&quot; &#125;], &quot;bindedPrivacyPhoneList&quot;: [&#123; &quot;privacyPhoneShow&quot;: &quot;130**773转5108&quot;, &quot;privacyPhone&quot;: &quot;13**4773,5108&quot; &#125;], &quot;backupField&quot;: [], &quot;onTimeInsurance&quot;: &#123; &quot;effect&quot;: 0, &quot;desc&quot;: &quot;&quot;, &quot;status&quot;: 0 &#125;, &quot;foodSafeInsurance&quot;: &#123; &quot;effect&quot;: 0, &quot;desc&quot;: &quot;&quot;, &quot;status&quot;: 0 &#125;, &quot;thirdLogistics&quot;: &#123; &quot;courierName&quot;: &quot;&quot;, &quot;courierPhone&quot;: &quot;&quot;, &quot;logisticsPlatformName&quot;: &quot;&quot;, &quot;logisticsPlatformCode&quot;: &quot;&quot;, &quot;deliverTime&quot;: &quot;&quot;, &quot;allowAlterType&quot;: true &#125;, &quot;preMakerValid&quot;: 1, &quot;retailOrderPreMakerInfo&quot;: &#123; &quot;preMakerPrivacyPhoneShow&quot;: &quot;1788**37转9232&quot;, &quot;preMakerPhoneShow&quot;: &quot;178**7转9232&quot;, &quot;preMakerPhone&quot;: &quot;178**137,9232&quot;, &quot;preMakerTag&quot;: &quot;购花使者&quot;, &quot;preMakerPrivacyPhoneShowAfter&quot;: &quot;1******8137转9232&quot;, &quot;preMakerBackupPrivacyPhone&quot;: [&#123; &quot;privacyPhoneShow&quot;: &quot;185**029转1199&quot;, &quot;privacyPhone&quot;: &quot;18**4029,1199&quot; &#125;] &#125; &#125;], &quot;changes&quot;: [], &quot;orderSynCtime&quot;: 1603013219, &quot;orderSynUtime&quot;: 1603013219 &#125;&#125; 3.1 确认送达时间：1&quot;estimateArrivalTime&quot;: 1603020418, 从信息中提取到送达时间的时间戳，时间戳是指，格林威治时间从1970-01-01 00:00:00到某个时间点所经历的秒数，可以表达绝对时间领域的一个时刻。其转化为我们所能够阅读的时间，是根据计算机系统时间来计算的。不同时区的计算机得到的结果是不一样的。上述时间戳，转为北京时间后是2020-10-18 19:26:58。在转换时，默认时根据计算机所在时区转换。所以，最好指定转换时区。 123456import pytzts = 1566395745tz = pytz.timezone(&#x27; Asia/Shanghai&#x27;)dt = pytz.datetime.datetime.fromtimestamp(ts, tz)dt.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)12345 结果为：2019-08-21 09:55:45 3.2 送达地点在信息中，是没有配送地点的内容的，如果，通过appium来点击查看地址在爬取地址信息，就过于麻烦。再次研究订单信息JSON数据后，我发现，在订单中，有一行数据为 12&quot;addressLongitude&quot;: 104251302,&quot;addressLatitude&quot;: 30880900, 这是地址编码，对应的是经纬度信息。在高德地图API接口手册中，我找到了适合地址解码的api 1https:&#x2F;&#x2F;restapi.amap.com&#x2F;v3&#x2F;geocode&#x2F;regeo?output&#x3D;xml&amp;location&#x3D;116.310003,39.991957&amp;key&#x3D;&lt;用户的key&gt;&amp;radius&#x3D;1000&amp;extensions&#x3D;all 测试后，从api返回的地址正是收货地址。 可以看到，Longitude经度，Latitude维度。这个参数是以六位小数结尾的数据。。而订单中，是没有把小数位表现出来的，所以需要单独修改。 为了让饿了么和美团的订单，具有相同的格式，我们需要修改之前确定的饿了么订单对象。把送达时间统一更改为时间戳，把地址信息统一转为地理编码后的经纬度。 4：Python编程下面是包含了饿了么和美团外卖的完整程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- encoding: utf-8 -*-&#x27;&#x27;&#x27;@file_name :order.py@description :@time :2020/10/16 21:25:01@author :Qifei@version :1.0&#x27;&#x27;&#x27;import mitmproxy.httpimport json#顾客类class Customer(object): def __init__(self,name,tel): self.name = name self.tel = tel #商品类class Good(object): def __init__(self,name,number,img): self.name = name self.number = number self.img = img#订单类class Order(Customer): def __init__(self,platform,name,tel,addr_long,addr_latu,note,arri_time,order_id,goods): Customer.__init__(self,name,tel) self.addr_long = addr_long self.addr_latu = addr_latu self.note = note self.arri_time = arri_time self.order_id = order_id self.goods = goods self.platform = platform#截获饿了么订单class ElemeOrders(): def __init__(self): self.orders = [] def response(self, flow: mitmproxy.http.flow): if &quot;bwm_newretail.recrm_order_j/queryorderapp/queryOrderInfoList?&quot; in flow.request.url: data = json.loads(flow.response.text)[&quot;data&quot;] for total_order_list in data[&#x27;total_order_list&#x27;]: for order_list in total_order_list[&#x27;order_list&#x27;]: goods = [] for good in order_list[&#x27;order_goods&#x27;][&#x27;goods_list&#x27;]: good_buffer = Good(good[&#x27;name&#x27;],good[&#x27;number&#x27;],good[&#x27;url&#x27;]) goods.append(good_buffer) order = Order(&#x27;eleme&#x27;,order_list[&#x27;order_basic&#x27;][&#x27;user_real_name&#x27;]+order_list[&#x27;order_basic&#x27;][&#x27;sex&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;user_phone&#x27;],str(order_list[&#x27;order_basic&#x27;][&#x27;user_address_lng&#x27;]),str(order_list[&#x27;order_basic&#x27;][&#x27;user_address_lat&#x27;]),order_list[&#x27;order_basic&#x27;][&#x27;user_note&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;takeout_average_time&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;order_id&#x27;],goods) self.orders.append(order) print(self.orders) #截获美团订单class MeituanOrders(): def __init__(self): self.orders = [] def response(self, flow: mitmproxy.http.flow): if &quot;eapi.waimai.meituan.com/api/retail/order/supplement/increment/orders?&quot; in flow.request.url: data = json.loads(flow.response.text)[&quot;data&quot;] for order_list in data[&#x27;news&#x27;]: goods = [] for good in order_list[&#x27;details&#x27;]: good_buffer = Good(good[&#x27;food_name&#x27;],good[&#x27;count&#x27;],good[&#x27;picUrl&#x27;]) goods.append(good_buffer) order = Order(&#x27;meituan&#x27;,order_list[&#x27;recipient_name&#x27;],order_list[&#x27;recipient_phone&#x27;],self.geo_format(order_list[&#x27;longitude&#x27;]),self.geo_format(order_list[&#x27;latitude&#x27;]),order_list[&#x27;remark&#x27;],order_list[&#x27;estimateArrivalTime&#x27;],order_list[&#x27;id&#x27;],goods) self.orders.append(order) print(self.orders[0].name) #将经纬度162787612转为162.787612 def geo_format(self,int_geo): str_geo = str(int_geo) #162787612 list_geo = list(str_geo) #[&#x27;1&#x27;,&#x27;6&#x27;,&#x27;2&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;7&#x27;,&#x27;6&#x27;,&#x27;1&#x27;,&#x27;2&#x27;] list_geo.insert(-6,&#x27;.&#x27;) new_str = &#x27;&#x27;.join(list_geo) return new_str#mitmproxy插件addons = [ ElemeOrders(), MeituanOrders()] 5：参考资料《给Android7及以上的手机安装系统级证书，实现Fiddler或者其他程序的HTTPS的抓包》 《python将时间戳转换为指定时区时间》","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"-TWRP","slug":"TWRP","permalink":"https://sci.ci/tags/TWRP/"}]},{"title":"外卖平台订单爬取之饿了么零售商家版","slug":"外卖平台订单爬取之饿了么零售商家版","date":"2020-10-16T21:46:27.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/16/外卖平台订单爬取之饿了么零售商家版/","link":"","permalink":"https://sci.ci/2020/10/16/%E5%A4%96%E5%8D%96%E5%B9%B3%E5%8F%B0%E8%AE%A2%E5%8D%95%E7%88%AC%E5%8F%96%E4%B9%8B%E9%A5%BF%E4%BA%86%E4%B9%88%E9%9B%B6%E5%94%AE%E5%95%86%E5%AE%B6%E7%89%88/","excerpt":"","text":"1：简单说两句这是我一个准备做的完整项目中的一个小部分。从很早以前，我就在思考，如何将美团和饿了么以及我自己做的小程序订单合并在一起，这样来实现统一的管理。。之所以要统一管理，是因为我母亲从事鲜花零售，在节假日里，会有大量的订单，而鲜花的包扎是个时间活。制作和配送，以及订单的处理，繁杂的程序会让人晕头转向。为了减轻我母亲的节假日压力，我想到了一些方法，来帮助她管理订单。 完整的项目是，汇总小程序、美团、饿了么的订单。将订单返回的信息，通过处理，按配送时间排序，经过处理后通过企业微信api推送给微信。因为，花店的配送人员都是我母亲找的，他们受教育程度低，有的因为不识字，连导航都不会用。所以，需要把订单的位置信息，通过百度地图api转为url发送给配送员。另外，还可以制作一个程序，在程序上实时更新，新订单。。每当一束花被做好，我母亲就可从程序中将该订单从等待制作的列表中移除。。每当，有一个订单被送出，也可在程序上控制美团等客户端发送对应消息。 这一切都是非常美好的，对零售商家的体验会非常友好。但是，因为我无法取得美团和饿了么的开发者资格，也就拿不到他们的接口授权。。于是，我想到了，利用利用mitmproxy获取美团饿了么的订单信息。通过appium自动化控制手机。无论是mitmrpoxy还是appium对python程序都是非常友好的。 那么现在开始我的第一步，利用mitmproxy爬取饿了么零售商家版订单信息。 2：mitmproxy安装与使用安装 1pip install mitmproxy 开启 12mitmweb#或者mitmproxy mitmdump 与python配合 1mitmdump -s eleme.py 手机使用mitmproxy开启的代理： 更改wifi高级设置里的代理模式为手动，主机填写mitmproxy运行的电脑局域网ip。可通过ifconfig查看。 端口为8080 此时打开baidu.com会提示不安全，而且mitmproxy应该开始记录了。 手机打开网页mitm.it下载对应系统的证书文件。安卓下载后直接安装。。 再上网就不会提示不安全了。 3：响应内容在开启mitmweb后，从打开的网页上可以观察到手机的整个数据流，在手机上刷新订单页，就能截获饿了么发送回来的订单信息。 将响应内容提取出来，并把JSON数据格式化，部分关键信息已打码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416&#123; &quot;data&quot;: &#123; &quot;curr_page&quot;: 1, &quot;order_count&quot;: 1, &quot;page_count&quot;: 1, &quot;page_size&quot;: 20, &quot;total_order_list&quot;: [&#123; &quot;mills&quot;: 1602518400000, &quot;order_list&quot;: [&#123; &quot;cold_chain_cost&quot;: &#123; &quot;price&quot;: &quot;0.00&quot;, &quot;title&quot;: &quot;冷链服务费&quot; &#125;, &quot;compensationInfo&quot;: &#123; &quot;enableCompensable&quot;: false, &quot;timeRemaining&quot;: 0 &#125;, &quot;extract_commission&quot;: &#123; &quot;brief_desc&quot;: &quot;请以结算账单为准&quot;, &quot;commission_total&quot;: &quot;15.00&quot;, &quot;title&quot;: &quot;抽取佣金&quot; &#125;, &quot;goods_discount&quot;: &#123; &quot;discount_account&quot;: &quot;-￥3.00&quot;, &quot;discount_list&quot;: [&#123; &quot;desc&quot;: &quot;&quot;, &quot;hasLineBelow&quot;: 1, &quot;list&quot;: [&#123; &quot;price&quot;: &quot;￥3.00&quot;, &quot;title&quot;: &quot;商家配送费补贴&quot; &#125;, &#123; &quot;price&quot;: &quot;￥3.00&quot;, &quot;title&quot;: &quot;小计&quot; &#125;], &quot;title&quot;: &quot;商户补贴金额&quot; &#125;, &#123; &quot;desc&quot;: &quot;&quot;, &quot;hasLineBelow&quot;: null, &quot;list&quot;: [&#123; &quot;title&quot;: &quot;配送费满减&quot; &#125;, &#123; &quot;title&quot;: &quot;(商家补贴:￥3.00元)&quot; &#125;], &quot;title&quot;: &quot;活动明细&quot; &#125;], &quot;title&quot;: &quot;顾客优惠合计&quot;, &quot;user_discount_account&quot;: &quot;-￥3.00&quot; &#125;, &quot;grayInfo&quot;: &#123; &quot;hummingBirdGray&quot;: 0 &#125;, &quot;orderSettle&quot;: &#123; &quot;baseLogisticsAmt&quot;: &quot;0.00&quot;, &quot;baseLogisticsDesc&quot;: &quot;本单收取固定物流费&quot;, &quot;commissionAmt&quot;: &quot;15.00&quot;, &quot;commissionDesc&quot;: &quot;请以结算账单为准&quot;, &quot;shopInAmount&quot;: &quot;0.00&quot; &#125;, &quot;order_basic&quot;: &#123; &quot;apply_cancel_feed&quot;: &#123; &quot;feed_list&quot;: [&#123; &quot;cancel_content&quot;: &quot;&quot;, &quot;cancel_extra&quot;: &quot;&quot;, &quot;cancel_time&quot;: &quot;10月13日 12:55&quot;, &quot;cancel_title&quot;: &quot;订单已完成(商户)&quot;, &quot;end_time&quot;: &quot;&quot;, &quot;left_time&quot;: 0, &quot;left_time_show&quot;: &quot;&quot;, &quot;refund_price&quot;: &quot;&quot;, &quot;user_apply_refund_pic&quot;: [] &#125;, &#123; &quot;cancel_content&quot;: &quot;&quot;, &quot;cancel_extra&quot;: &quot;&quot;, &quot;cancel_time&quot;: &quot;10月13日 09:10&quot;, &quot;cancel_title&quot;: &quot;商家已接单&quot;, &quot;end_time&quot;: &quot;&quot;, &quot;left_time&quot;: 0, &quot;left_time_show&quot;: &quot;&quot;, &quot;refund_price&quot;: &quot;&quot;, &quot;user_apply_refund_pic&quot;: [] &#125;, &#123; &quot;cancel_content&quot;: &quot;&quot;, &quot;cancel_extra&quot;: &quot;&quot;, &quot;cancel_time&quot;: &quot;10月13日 09:10&quot;, &quot;cancel_title&quot;: &quot;订单已支付&quot;, &quot;end_time&quot;: &quot;&quot;, &quot;left_time&quot;: 0, &quot;left_time_show&quot;: &quot;&quot;, &quot;refund_price&quot;: &quot;&quot;, &quot;user_apply_refund_pic&quot;: [] &#125;, &#123; &quot;cancel_content&quot;: &quot;&quot;, &quot;cancel_extra&quot;: &quot;&quot;, &quot;cancel_time&quot;: &quot;10月13日 09:09&quot;, &quot;cancel_title&quot;: &quot;创建订单&quot;, &quot;end_time&quot;: &quot;&quot;, &quot;left_time&quot;: 0, &quot;left_time_show&quot;: &quot;&quot;, &quot;refund_price&quot;: &quot;&quot;, &quot;user_apply_refund_pic&quot;: [] &#125;] &#125;, &quot;apply_cancel_status&quot;: 886, &quot;auto_confirm_order&quot;: 0, &quot;batch&quot;: 2000000000000000001, &quot;business_type&quot;: 0, &quot;call_delivery_delay&quot;: &quot;&quot;, &quot;cancel_reason&quot;: &quot;&quot;, &quot;cancel_reason_explain&quot;: &quot;&quot;, &quot;cancel_reason_status&quot;: &quot;0&quot;, &quot;check_out_button&quot;: 0, &quot;city_name&quot;: &quot;成都市&quot;, &quot;confirmButton&quot;: 1, &quot;confirm_time&quot;: &quot;1602551413&quot;, &quot;create_time&quot;: &quot;1602551397&quot;, &quot;delivery_delay_time&quot;: &quot;&quot;, &quot;delivery_exception_code&quot;: 0, &quot;delivery_exception_state&quot;: &quot;&quot;, &quot;delivery_name&quot;: &quot;&quot;, &quot;delivery_party&quot;: &quot;self&quot;, &quot;delivery_staff_phone&quot;: &quot;&quot;, &quot;delivery_state&quot;: &quot;0&quot;, &quot;delivery_state_desc&quot;: &quot;&quot;, &quot;delivery_tip_amount&quot;: 0.0, &quot;distance&quot;: &quot;&lt;1.8千米&quot;, &quot;due_deliver_time_by_ofc&quot;: &quot;&quot;, &quot;ele_fengniao_info&quot;: &#123; &quot;is_fengniao_call_again&quot;: 0, &quot;is_fengniao_switch_self&quot;: 0, &quot;no_delivery&quot;: 0 &#125;, &quot;ele_zhongbao_info&quot;: &#123; &quot;delivery_fee&quot;: 0, &quot;is_show&quot;: false, &quot;op_status&quot;: 0 &#125;, &quot;eleme_finish_refund&quot;: 0, &quot;eleme_order_id&quot;: &quot;5009809679236497411&quot;, &quot;evoip_order&quot;: 2, &quot;express_company&quot;: &quot;&quot;, &quot;express_id&quot;: &quot;0&quot;, &quot;feed_to_show&quot;: &quot;order_log&quot;, &quot;finished_time&quot;: &quot;1602564946&quot;, &quot;gift_greeting&quot;: &quot;&quot;, &quot;gift_phone&quot;: &quot;13***502&quot;, &quot;hbirdRunErrandsInfo&quot;: &#123; &quot;addTipsButton&quot;: 0, &quot;callButton&quot;: 0, &quot;cancelCallButton&quot;: 0, &quot;payType&quot;: null &#125;, &quot;idempotentId&quot;: &quot;20201017025815254005000100027411822742&quot;, &quot;invoice_price&quot;: &quot;100.00&quot;, &quot;invoice_title&quot;: &quot;&quot;, &quot;is_alipay_order&quot;: 0, &quot;is_baidu_logistics&quot;: 0, &quot;is_can_auto_confirm&quot;: 0, &quot;is_city_delivery&quot;: 0, &quot;is_cold_order&quot;: 0, &quot;is_compensation_show&quot;: 0, &quot;is_cook_overtime&quot;: 0, &quot;is_from_tp_new_retail&quot;: true, &quot;is_print&quot;: 1, &quot;is_privacy_hide&quot;: 1, &quot;is_ranger_show&quot;: 1, &quot;is_show_express&quot;: 0, &quot;ivr_tip&quot;: &quot;&quot;, &quot;meal_num&quot;: &quot;&quot;, &quot;need_invoice&quot;: 0, &quot;orderUserPhone&quot;: &quot;136****3502&quot;, &quot;orderUserPrivacyPhone&quot;: &quot;&quot;, &quot;order_from&quot;: &quot;2&quot;, &quot;order_id&quot;: &quot;50098***97411&quot;, &quot;order_index&quot;: &quot;1&quot;, &quot;order_list_type&quot;: &#123; &quot;is_cancel&quot;: 0, &quot;is_exception&quot;: 0, &quot;is_new&quot;: 0, &quot;is_remind&quot;: 0, &quot;is_reserve&quot;: 1, &quot;is_user_part_refund&quot;: 0 &#125;, &quot;order_time_line&quot;: [&#123; &quot;code&quot;: &quot;101004&quot;, &quot;time&quot;: &quot;10/13 12:55&quot;, &quot;title&quot;: &quot;订单已完成(商户)&quot; &#125;, &#123; &quot;code&quot;: &quot;100004&quot;, &quot;time&quot;: &quot;10/13 09:10&quot;, &quot;title&quot;: &quot;商家已接单&quot; &#125;, &#123; &quot;code&quot;: &quot;100001&quot;, &quot;time&quot;: &quot;10/13 09:10&quot;, &quot;title&quot;: &quot;订单已支付&quot; &#125;, &#123; &quot;code&quot;: &quot;100000&quot;, &quot;time&quot;: &quot;10/13 09:09&quot;, &quot;title&quot;: &quot;创建订单&quot; &#125;], &quot;order_type&quot;: 4, &quot;part_refund_support&quot;: 0, &quot;pay_display&quot;: 1, &quot;pay_status&quot;: &quot;已支付&quot;, &quot;pc_order_label&quot;: [], &quot;pick_info&quot;: &#123; &quot;expect_finish_time&quot;: &quot;02:58:15&quot;, &quot;left_time&quot;: &quot;0&quot;, &quot;pick_button&quot;: &quot;0&quot;, &quot;show&quot;: &quot;0&quot;, &quot;timestamp&quot;: &quot;&quot; &#125;, &quot;privacy_phone&quot;: &quot;&quot;, &quot;range_status&quot;: 0, &quot;real_status&quot;: 5, &quot;real_status_desc&quot;: &quot;商家已经确认订单&quot;, &quot;refund_attribute&quot;: 0, &quot;refund_logs&quot;: [], &quot;refund_req_info&quot;: [], &quot;refuseButton&quot;: 1, &quot;remind_undeal&quot;: 0, &quot;remind_wait_time&quot;: &quot;&quot;, &quot;responsible_party&quot;: &quot;暂无&quot;, &quot;self_order_completed_button&quot;: 0, &quot;send_time&quot;: &quot;请10月13日 13:00送达&quot;, &quot;send_time_print&quot;: &quot;13日 13:00送达&quot;, &quot;service_phone&quot;: &quot;10105757&quot;, &quot;set_express&quot;: 0, &quot;sex&quot;: &quot;女士&quot;, &quot;shopPicked&quot;: 1, &quot;shop_info&quot;: &#123; &quot;location_shop&quot;: &#123; &quot;latitude&quot;: &quot;35**3**7&quot;, &quot;longitude&quot;: &quot;***4431E7&quot; &#125;, &quot;shop_address&quot;: null &#125;, &quot;shop_name&quot;: &quot;**鲜花店&quot;, &quot;shop_phone&quot;: &quot;13***65&quot;, &quot;shop_user_distance&quot;: &quot;&quot;, &quot;show_add_tip&quot;: 0, &quot;show_cancel_button&quot;: false, &quot;show_know_button&quot;: 0, &quot;show_shop_pack&quot;: 0, &quot;status&quot;: 9, &quot;status_desc&quot;: &quot; 已完结&quot;, &quot;supplier_id&quot;: &quot;0&quot;, &quot;supplier_name&quot;: &quot;&quot;, &quot;takeout_average_time&quot;: 1602565200, &quot;takeout_phone&quot;: &quot;136****065&quot;, &quot;taxer_id&quot;: &quot;&quot;, &quot;thirty_min_service&quot;: 0, &quot;userTags&quot;: [2], &quot;user_address&quot;: &quot;为了保护顾客隐私，隐藏地址信息&quot;, &quot;user_address_lat&quot;: &quot;30.890345&quot;, &quot;user_address_lng&quot;: &quot;104.261772&quot;, &quot;user_id&quot;: &quot;576192986&quot;, &quot;user_note&quot;: &quot;送给我好朋友的生日花，写几句祝福语，谢谢&quot;, &quot;user_order_num_str&quot;: &quot;超百次下单&quot;, &quot;user_phone&quot;: &quot;177****7520&quot;, &quot;user_phone_call&quot;: &quot;&quot;, &quot;user_phone_star&quot;: &quot;&quot;, &quot;user_real_name&quot;: &quot;珊&quot;, &quot;vip_status&quot;: 0, &quot;waimai_release_id&quot;: &quot;159766693&quot;, &quot;wxIconPath&quot;: &quot;&quot;, &quot;wxNickname&quot;: &quot;&quot;, &quot;zone_tips_required&quot;: 0 &#125;, &quot;order_goods&quot;: &#123; &quot;cart_num&quot;: 1, &quot;goods_list&quot;: [&#123; &quot;customer_price&quot;: &quot;98.00&quot;, &quot;ext&quot;: &#123; &quot;attr&quot;: &quot;&quot;, &quot;cart_id&quot;: &quot;1&quot;, &quot;cold_chain&quot;: null, &quot;combo_attr&quot;: [], &quot;customer_total_discount&quot;: &quot;&quot;, &quot;discount_desc&quot;: &quot;&quot;, &quot;ext_code&quot;: &quot;&quot;, &quot;is_combo&quot;: 0, &quot;process_label&quot;: [], &quot;product_index&quot;: null, &quot;property_label&quot;: [], &quot;shop_total_discount&quot;: &quot;&quot;, &quot;store_attr&quot;: &#123; &quot;bar_code&quot;: &quot;wm367**65&quot;, &quot;category_name&quot;: &quot;爱情表白&quot;, &quot;shelf_position&quot;: &quot;&quot;, &quot;sku_id&quot;: &quot;1597871782222488&quot; &#125;, &quot;unique_id&quot;: &quot;13***678&quot; &#125;, &quot;fix_weight&quot;: 0, &quot;gift_info&quot;: null, &quot;gmids&quot;: null, &quot;hasgift&quot;: 0, &quot;isNoReasonToReturn&quot;: false, &quot;isfreegift&quot;: 0, &quot;name&quot;: &quot;【七夕专属】19朵红玫瑰礼盒+银叶&quot;, &quot;number&quot;: 1, &quot;orig_price&quot;: &quot;98.00&quot;, &quot;orig_unit_price&quot;: &quot;98.00&quot;, &quot;printing_price&quot;: &quot;98.00&quot;, &quot;shop_price&quot;: &quot;98.00&quot;, &quot;shop_unit_price&quot;: &quot;98.00&quot;, &quot;total_weight&quot;: 999, &quot;unique_id&quot;: &quot;130047***9119678&quot;, &quot;url&quot;: &quot;https://img.alic***i2/111483146/O1CN01wVILGS1Z6udgswHe4_!!111483146-0-***.jpg&quot;, &quot;weight&quot;: 999, &quot;weight_can_update&quot;: false, &quot;weight_flag&quot;: 2 &#125;], &quot;goods_total&quot;: 1 &#125;, &quot;order_meal_fee&quot;: &#123; &quot;price&quot;: &quot;0.00&quot;, &quot;title&quot;: &quot;包装费&quot; &#125;, &quot;order_operations&quot;: [], &quot;order_sub_total&quot;: &#123; &quot;discount&quot;: 0, &quot;formula_desc&quot;: &quot;&quot;, &quot;number&quot;: 1, &quot;price&quot;: &quot;98.00&quot;, &quot;title&quot;: &quot;商品小计&quot; &#125;, &quot;order_total&quot;: &#123; &quot;customer_price&quot;: &quot;100.00&quot;, &quot;customer_title&quot;: &quot;本单顾客实际支付&quot;, &quot;number&quot;: 1, &quot;pay_type&quot;: 1, &quot;shop_price&quot;: &quot;85.00&quot;, &quot;shop_price_final&quot;: &quot;85.00&quot;, &quot;title&quot;: &quot;预计收入&quot;, &quot;title_after&quot;: null, &quot;total_desc&quot;: &quot;本单顾客实际支付100.00元&quot; &#125;, &quot;other_total_cost&quot;: &#123; &quot;price&quot;: &quot;5.00&quot;, &quot;title&quot;: &quot;其他费用合计&quot; &#125;, &quot;prescriptionDrugsInfo&quot;: &#123; &quot;auditButton&quot;: 0, &quot;prescriptionOrder&quot;: false, &quot;processMsg&quot;: &quot;系统正在处理中&quot; &#125;, &quot;prescription_info&quot;: &#123; &quot;is_prescription_order&quot;: 0 &#125;, &quot;shop_other_discount&quot;: &#123; &quot;customer_discount_list&quot;: [], &quot;customer_discount_total&quot;: 0, &quot;price&quot;: &quot;-0.00&quot;, &quot;shop_discount_list&quot;: [], &quot;shop_discount_total&quot;: 0, &quot;sub_total_desc&quot;: &quot;以上明细为商户承担的顾客优惠费用，最终订单收入请以对账单为准。&quot;, &quot;title&quot;: &quot;商户其他优惠&quot; &#125;, &quot;takeout_cost&quot;: &#123; &quot;price&quot;: &quot;5.00&quot;, &quot;title&quot;: &quot;配送费&quot; &#125; &#125;], &quot;title&quot;: &quot;10月13日&quot; &#125;] &#125;, &quot;errmsg&quot;: &quot;&quot;, &quot;errno&quot;: 0, &quot;req_params&quot;: [&#123; &quot;asap_type&quot;: null, &quot;end_timestamp&quot;: &quot;2020-10-16&quot;, &quot;is_asap&quot;: null, &quot;keyword&quot;: &quot;&quot;, &quot;new_system&quot;: 1, &quot;order_status&quot;: 9, &quot;page&quot;: 1, &quot;pageSize&quot;: 20, &quot;shop_id&quot;: null, &quot;start_timestamp&quot;: &quot;2020-10-10&quot; &#125;, &#123; &quot;appVersion&quot;: &quot;2.2.3&quot;, &quot;authedSupplierIds&quot;: [], &quot;brand&quot;: &quot;samsung&quot;, &quot;channel&quot;: &quot;mobile&quot;, &quot;cuid&quot;: &quot;12B9828F9D0D3E389BA181D5A286A514|fw+G+2QPhBBAD8Yubtg6qGDX&quot;, &quot;from&quot;: &quot;android&quot;, &quot;isBoss&quot;: false, &quot;isManager&quot;: false, &quot;isMobile&quot;: false, &quot;isShop&quot;: true, &quot;isSupplier&quot;: false, &quot;manager&quot;: &#123; &quot;bossUserId&quot;: null &#125;, &quot;pcVersion&quot;: &quot;&quot;, &quot;roleInfo&quot;: &#123; &quot;shopRoleId&quot;: &quot;159766693&quot; &#125;, &quot;shopInfo&quot;: &#123; &quot;eleId&quot;: 159766693, &quot;wid&quot;: &quot;159766693&quot; &#125;, &quot;supplierInfo&quot;: &#123; &quot;supplierId&quot;: &quot;0&quot; &#125;, &quot;userInfo&quot;: &#123; &quot;loginRole&quot;: 1, &quot;loginSubUserType&quot;: 0, &quot;loginUserId&quot;: &quot;1597***50001&quot;, &quot;phone&quot;: &quot;13***65&quot;, &quot;shopUserId&quot;: &quot;15973**001&quot;, &quot;userName&quot;: &quot;x***65&quot; &#125; &#125;]&#125; 4：Python程序对上述JSON数据进行分析，在Python中用json.load把JSON数据转化为字典和列表格式数据，方便我们提取信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import mitmproxy.httpimport json#顾客类class Customer(object): def __init__(self,name,tel): self.name = name self.tel = tel #商品类class Good(object): def __init__(self,name,number,img): self.name = name self.number = number self.img = img#订单类class Order(Customer): def __init__(self,platform,name,tel,addr_long,addr_latu,note,arri_time,order_id,goods): Customer.__init__(self,name,tel) self.addr_long = addr_long self.addr_latu = addr_latu self.note = note self.arri_time = arri_time self.order_id = order_id self.goods = goods self.platform = platformclass ElemeOrders(): def __init__(self): self.orders = [] def response(self, flow: mitmproxy.http.flow): if &quot;bwm_newretail.recrm_order_j/queryorderapp/queryOrderInfoList?&quot; in flow.request.url: data = json.loads(flow.response.text)[&quot;data&quot;] for total_order_list in data[&#x27;total_order_list&#x27;]: for order_list in total_order_list[&#x27;order_list&#x27;]: goods = [] for good in order_list[&#x27;order_goods&#x27;][&#x27;goods_list&#x27;]: good_buffer = Good(good[&#x27;name&#x27;],good[&#x27;number&#x27;],good[&#x27;url&#x27;]) goods.append(good_buffer) order = Order(&#x27;eleme&#x27;,order_list[&#x27;order_basic&#x27;][&#x27;user_real_name&#x27;]+order_list[&#x27;order_basic&#x27;][&#x27;sex&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;user_phone&#x27;],str(order_list[&#x27;order_basic&#x27;][&#x27;user_address_lng&#x27;]),str(order_list[&#x27;order_basic&#x27;][&#x27;user_address_lat&#x27;]),order_list[&#x27;order_basic&#x27;][&#x27;user_note&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;takeout_average_time&#x27;],order_list[&#x27;order_basic&#x27;][&#x27;order_id&#x27;],goods) self.orders.append(order) print(self.orders) 经过简单的测试，程序能够拿到完整的订单信息。一次性搞定，没有bug。 在这个程序中，主要需要关注的是，Mitm类中的self.orders这个变量，可以看到，这个变量是一个列表，它包含了大于等于1个订单。每个订单，都是一个Order类的实例化，Order类中最后一个变量goods是一个列表，这个列表由多个实例化的Good类组成。因为一个订单可能包含多种商品。 具体如何利用这些信息，还需要再Mitm()类中做修改。而提取单个订单类，比如第一个订单，直接使用self.orders[0]，要提取第一个订单中的第一件商品self.orders[0].goods[0]。 其他的，比如第一个订单收货人：self.orders[0].name 第一个订单的第一件商品的名称：self.orders[0].goods[0].name 后续我可能会将它保存到数据库中，方便下次提取和修改信息。 5：参考资料《使用 mitmproxy + python 做拦截代理》 《APP爬虫入门，Appium+Mitmproxy强势组合实现抖音的数据爬取》","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"Mitmproxy","slug":"Mitmproxy","permalink":"https://sci.ci/tags/Mitmproxy/"}]},{"title":"Pandas知识总结","slug":"Pandas知识总结","date":"2020-10-14T16:45:54.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/14/Pandas知识总结/","link":"","permalink":"https://sci.ci/2020/10/14/Pandas%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"1：简介在我看来，Pandas是一款数据处理工具，它相比于numpy而言，更加具有针对性。比如说，Pandas提供了两种数据结构，Series和DataFrame，分别表示一维数据和二维数据，而numpy则还有更多维数据。Pandas的特色是，它可以使用自定义的索引来表示数据的特点，这和Excel表格很类似。而numpy只有固定的整数索引。 在数据中，我们可能会有这种情况，一个二维表格，每一行，表示不同的学生，每一列表示学生的不同信息。如下表所示， 年龄 班级 小明 19 4班 小张 15 2班 小华 17 1班 由年龄和班级构成的二维数组，在numpy中是无法建立的，因为numpy无法建立班级的字符串格式数据，且数组内不能含有多种属性的数据，比如年龄的数据格式是int，而班级则是string。 此时Pandas的作用就出来了。Pandas可以指定上述数据每一行的意义为名字，所以其行索引Index可以设置为[‘小明’,’小张’,’小华’]，而其纵坐标的索引columns设置为[‘年龄’,’班级’]。然后再向这个DataFrame中添加数据即可。 2：入门2.1 生成对象引入Pandas： 12import numpy as npimport pandas as pd 生成Series： 1s = pd.Series([1,4,1,np.nan,8]) 生成DataFrame： 123dates = pd.date_range(&#x27;20130101&#x27;,periods=6)#生成六个以20130101开始，间隔为一天的时间序列df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&#x27;ABCD&#x27;)) date_range函数可以生成一个时间序列，参数有，开始时间，结束时间，序列个数，间隔单位等。 df为： 1234567 A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.0874012013-01-06 -0.673690 0.113648 -1.478427 0.524988 使用字典对象生成DataFrame： 123456df2 = pd.DataFrame(&#123;&#x27;A&#x27;:1, &#x27;B&#x27;:pd.Timestamp(&#x27;20130102&#x27;), &#x27;C&#x27;:pd.Series(1, index=list(range(4)),dtype=&#x27;float332&#x27;), &#x27;D&#x27;:np.array([3]*4,dtype=&#x27;int32&#x27;), &#x27;E&#x27;:pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]), &#x27;F&#x27;:&#x27;foo&#x27;&#125;) 2.2 查看数据查看DataFrame头部和尾部数据： 123df.head()df.tail(3)#可指定查看头尾部的数据行数 显示索引和列名： 12df.indexdf.columns df.to_numpy()将DataFrame数据转为numpy数据 df.describe()查看数据统计摘要 df.T转置 df.sort_index(axis=1,ascending=False)按轴上升排序 df.sort_values(by=&#39;B&#39;)按轴排序 2.3 选择数据产生Series 12df[&#x27;A&#x27;]df.A 切片： 12df[0:3]#选择1到3行 1df[&#x27;20130102&#x27;:&#x27;20130104&#x27;] 按标签选择： 1df.loc[dates[0]] 用标签选多列： 1df.loc[:,[&#x27;A&#x27;,&#x27;B&#x27;]] 用标签切片： 1df.loc[&#x27;20130102&#x27;:&#x27;20130104&#x27;,[&#x27;A&#x27;,&#x27;B&#x27;]] 提取标量： 12df.loc[dates[0],&#x27;A&#x27;]df.at[dates[0],&#x27;A&#x27;] 按位置选： 1df.iloc[3] 用整数切片： 1df.iloc[3:5,0:2] 用整数列表按位置切片： 1df.iloc[[1,2,4],[0,2]] 按位置访问标量： 12df.iloc[1,1]df.iat[1,1] 布尔索引： 用单列的值： 1df[df.A&gt;0] 12345Out[39]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-04 0.721555 -0.706771 -1.039575 0.271860 选择满足条件的值： 1df[df&gt;0] 12345678Out[40]: A B C D2013-01-01 0.469112 NaN NaN NaN2013-01-02 1.212112 NaN 0.119209 NaN2013-01-03 NaN NaN NaN 1.0718042013-01-04 0.721555 NaN NaN 0.2718602013-01-05 NaN 0.567020 0.276232 NaN2013-01-06 NaN 0.113648 NaN 0.524988 isin()筛选 123df2 = df.copy()df2[&#x27;E&#x27;] = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;……]df2[df2[&#x27;E&#x27;].isin([&#x27;one&#x27;,&#x27;two&#x27;])] 2.4 缺失值Nanreindex重建索引，不会修改源数据 12df1 = df.reindex(index = dates[0:4],columns=list(df.columns)+[&#x27;E&#x27;])df1.loc[dates[0]:dates[1],&#x27;E&#x27;] = 1 123456Out[57]: A B C D F E2013-01-01 0.000000 0.000000 -1.509059 5 NaN 1.02013-01-02 1.212112 -0.173215 0.119209 5 1.0 1.02013-01-03 -0.861849 -2.104569 -0.494929 5 2.0 NaN2013-01-04 0.721555 -0.706771 -1.039575 5 3.0 NaN 删除含缺失值的行： 1df1.dropna(how=&#x27;any&#x27;) 填充缺失值： 1df1.fillna(value=5) 提取缺失值的布尔掩码： 1pd.isna(df1) 2.5 运算一般，运算时会排除缺失值 在列上计算平均值： 1df.mean() 在行上计算： 1df.mean(1) 12345678Out[62]: 2013-01-01 0.8727352013-01-02 1.4316212013-01-03 0.7077312013-01-04 1.3950422013-01-05 1.8836562013-01-06 1.592306Freq: D, dtype: float64 减法： 12s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)df.sub(s,axis=&#x27;index&#x27;) s与df的index轴是相同的，或者说在行上他们数据的个数相同，所以，sub第二个参数填写index或者0，计算时，df每列都会减去s。 shift函数是平移函数，s各个位置上的数向下平移，由于向下平移了两个位置，0和1位置上的数没有内容可以补，用nan自动替补。 Apply函数： DataFrame.apply() 函数则会依次将每行或列取出来作为一个Series传递到apply指定的函数中。 12345678matrix = [ [1,2,3], [4,5,6], [7,8,9]]df = pd.DataFrame(matrix, columns=list(&#x27;xyz&#x27;), index=list(&#x27;abc&#x27;))df.apply(np.square) 具体使用方法： pandas apply() 函数用法 直方图与离散化： 12s = pd.Series(np.random.randint(0,7,size=10))s.value_counts() #统计s中整数的分布情况，比如4有5个 字符串方法： 12s = pd.Series([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;Aaba&#x27;, &#x27;Baca&#x27;, np.nan, &#x27;CABA&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;])s.str.lower() #字符串小写 2.6 合并结合： contact()将零散的df合并，合并原则根据index和columns，相同合并，不同连接。 123df = pd.DataFrame(np.random.randn(10, 4))pieces = [df[:3], df[3:7], df[7:]]pd.concat(pieces) 连接： join()直接将连个df连接起来。 12345678910111213141516171819In [79]: leftOut[79]: key lval0 foo 11 foo 2In [80]: rightOut[80]: key rval0 foo 41 foo 5In [81]: pd.merge(left, right, on=&#x27;key&#x27;)Out[81]: key lval rval0 foo 1 41 foo 1 52 foo 2 43 foo 2 5 1234567891011121314151617In [84]: leftOut[84]: key lval0 foo 11 bar 2In [85]: rightOut[85]: key rval0 foo 41 bar 5In [86]: pd.merge(left, right, on=&#x27;key&#x27;)Out[86]: key lval rval0 foo 1 41 bar 2 5 追加： append()为df追加行 1df.append(s,ignore_index=True) 2.7 分组按照某个column或columns，将df分组，然后结合df的函数分别计算各个分组。 1234567891011121314151617181920212223242526272829In [92]: dfOut[92]: A B C D0 foo one -1.202872 -0.0552241 bar one -1.814470 2.3959852 foo two 1.018601 1.5528253 bar three -0.595447 0.1665994 foo two 1.395433 0.0476095 bar two -0.392670 -0.1364736 foo one 0.007207 -0.5617577 foo three 1.928123 -1.623033In [93]: df.groupby(&#x27;A&#x27;).sum()Out[93]: C DA bar -2.802588 2.42611foo 3.146492 -0.63958In [94]: df.groupby([&#x27;A&#x27;, &#x27;B&#x27;]).sum()Out[94]: C DA B bar one -1.814470 2.395985 three -0.595447 0.166599 two -0.392670 -0.136473foo one -1.195665 -0.616981 three 1.928123 -1.623033 two 2.414034 1.600434 2.8 重塑","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"https://sci.ci/tags/Pandas/"},{"name":"数据处理","slug":"数据处理","permalink":"https://sci.ci/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"自定义Volantis主题页脚","slug":"自定义Volantis主题页脚","date":"2020-10-10T18:04:58.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/10/10/自定义Volantis主题页脚/","link":"","permalink":"https://sci.ci/2020/10/10/%E8%87%AA%E5%AE%9A%E4%B9%89Volantis%E4%B8%BB%E9%A2%98%E9%A1%B5%E8%84%9A/","excerpt":"","text":"修改主题文件下的_config.yml 找到页脚部分： 12345678############################### Site Footer ############################### &gt; startsite_footer: # layout of footer: [aplayer, social, license, info, copyright,analytics] layout: [custom] #custom custom: &#x27;&lt;a style=&quot;padding-right: 1%;&quot; href=&quot;https://hexo.io/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Powered-Hexo-red&quot;&gt;&lt;/a&gt;&lt;a style=&quot;padding-right: 1%;&quot; href=&quot;https://volantis.js.org/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Theme-Volantis-blue&quot;&gt;&lt;/a&gt;&lt;a style=&quot;padding-right: 1%;&quot; href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-success&quot;&gt;&lt;/a&gt;&lt;a style=&quot;padding-right: 1%;&quot; href=&quot;https://sci.ci&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/Copyright-2019--2020%20QF-orange&quot;&gt;&lt;/a&gt;&#x27; br: &#x27;&lt;br&gt;&#x27;############################### Site Footer ############################### &gt; end 修改后效果：","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"https://sci.ci/tags/Volantis/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-09-30T06:16:08.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/30/正则表达式/","link":"","permalink":"https://sci.ci/2020/09/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"1：简介正则表达式，常用于匹配包含一定规律的字符串，可以从字符串中提取符合规律的字符串段，或者返回是否符合要求。也可用于替换字符串。 比如，我们设置密码时，网站通常要求，密码为字母+数字+下划线组合，并且具有一定长度如3到15位，那么它的正则表达式可以是，^[a-z0-9_-]&#123;3-15&#125;$ 其中^表示从开头开始匹配，[a-z0-9_-]表示匹配字母，数字，下划线和连接符，$表示匹配结束。&#123;3-15&#125;表示匹配3到15个字符。完整意义：从开头开始匹配，匹配包括字母数字下划线和连接符，总共15个字符。 2：语法*表示匹配0个或多个字符。*qifei**可以匹配：qifei, qifi,qifeeeei ?表示匹配0个或1个字符。qife?i可以匹配：qifi, qifei + 匹配一个或者多个字符。qife+i可以匹配：qifei,qifeeeei []单字符满足[]中的要求，则匹配。[aui]*表示字符串中aui都会被匹配出来 字符 描述 [ABC] 匹配 […] 中的所有字符，例如 [aeiou] 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。 [^ABC] 匹配除了 […] 中字符的所有字符，例如 [^aeiou] 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r] [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，包括换行。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 $。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 ()选择：使用()给需要选择到的匹配项分组，选择项，可使用列表索引获取每个选择项，匹配的值。 3：元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 4：在线测试http://c.runoob.com/front-end/854","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://sci.ci/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python数据分析","slug":"Python数据分析","date":"2020-09-29T15:56:45.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/29/Python数据分析/","link":"","permalink":"https://sci.ci/2020/09/29/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"1：综述为什么学习数据分析 岗位需求 python数据科学的基础 机器学习的课程基础 什么是数据分析 用适当的方法对收集的大量数据进行分析 帮助人们做出判断，以便采取适当的行动 jupyter notebook： Python笔记软件 2：Matplotlib 将数据可视化，更直观的呈现 使数据更加客观、更具说服力 最流行的python底层绘图库，主要做数据可视化，模仿matlab构建 123456from matplotlib import pyplot as plt #导入pyplotx = range(2,26,2) #数据在x轴的位置，是一个可迭代的对y = [15,13,14,17,20,25,26,26,25,22,18,15] #数据在y轴的位置，是一个可迭代的对象plt.plot(x,y) #传入x和y，通过plot绘制出折线图plt.show() #执行程序的时候展现图像 目前存在的问题： 图片大小 保存到本地 描述信息，比如x，y轴表示什么 刻度 线条样式 标记特殊点 2.1 设置图片大小-figure1234567fig = plt.figure(figsize=(20,8),dpi=80)#figure图形图标的意思，这里指画的图#通过实例化一个figure并且传入参数#传入像素值，dpi，让图片更清晰plt.plot(x,y)plt.savefig(&quot;./t1.png&quot;) #保存图片#可以保存为svg矢量图格式，放大不会失真 2.2 设置x，y轴步长-xticks/yticks123456789101112plt.xticks(x) #设置步长plt.xticks(range(2,25))_xticks_labels = [i/2 for i in range(4,49)]plt.xticks(_xticks_labels[::3])plt.yticks(range(min(y),max(y)+1))#显示字符串_x = list(x)[::3]_xticks_labels = [&quot;10点&#123;&#125;分&quot;.format(i) for i in range(60)]_xticks_labels += [&quot;11点&#123;&#125;分&quot;.format(i) for i in range(60)]plt.xticks(list(_x)[::3],_xticks_labels[::3],rotation=90) #,前为步长列表，，后为字符串列表，与步长列表一一对应，并把刻度旋转90度显示。 上述绘图，无法显示中文 2.3 加入中文字体支持-FontProperties方法1： 123456import matplotlibfont = &#123;&#x27;family&#x27;:&#x27;MicroSoft YaHei&#x27;, &#x27;weight&#x27;:&#x27;bold&#x27;, &#x27;size&#x27;:&#x27;larger&#x27;&#125;matplotlib.rc(&quot;font&quot;,**font) #**可以把字典转为xx=xx格式matplotlib.rc(&quot;font&quot;,family=&#x27;MicroSoft YaHei&#x27;,weight=&#x27;bold&#x27;) 方法2： 12345from matplotlib import font_managermy_font = font_manager.FontProperties(fname=&quot;/System/Library/Fonts/PingFang.ttc&quot;) #设定字体位置#查找系统字体存放位置plt.xticks(list(_x)[::3],_xticks_labels[::3],rotation=90,fontproperties=my_font)#使用字体 2.4 加入描述信息-xlabel/ylabel/title123plt.xlabel(&quot;时间&quot;,fontproperties=my_font)plt.ylabel(&quot;温度 单位（℃）&quot;,fontproperties=my_font)plt.title(&quot;10点到12点的请问变化&quot;,fontproperties=my_font) 2.5 设置网格-grid12plt.grid()plt.grid(alpha=0.4) #设置网格透明度，1不透明，0透明 2.6 绘制两个图形-legend1234567plt.plot(x,y1,label=&quot;自己&quot;,color=&quot;orange&quot;,linestyle=&quot;:&quot;)plt.plot(x,y2,label=&quot;同桌&quot;,color=&quot;r&quot;,linestyle=&quot;--&quot;)#添加图例，解释哪个线表示哪个数据集，显示中文，格式不再是FontProperties#prop字体，loc位置：0最好的位置，不设置参数则默认0plt.legend(prop=my_font,loc=0) color=’r’ 颜色 linestyle=’–’ 线条风格：-实线；–虚线；-.点划线；:点虚线；留空或空格，表示无线条 linewidth=5 线粗细 alpha=0.4 透明度 2.7 绘制散点图-scatter12plt.scatter(x, y)plt.show() 2.8 绘制柱状图-bar123456789#绘制电影与其对应票房a=[&quot;战狼2&quot;,&quot;速度与激情8&quot;,&quot;功夫瑜伽&quot;,&quot;西游附魔篇&quot;]b=[56,61,26,94]plt.figure(figsize=(20,15),dpi=80)#绘制柱状图plt.bar(range(a),b,width=0.3)#设置横轴字符串plt.xticks(range(a),a,rotation=45)plt.show() 2.9 绘制条形图-barh12plt.barh(range(len(a)),b,height=0.3,color=&#x27;orange&#x27;)plt.yticks(range(len(a)),a) 2.10 绘制直方图-hist有250部电影的时长，统计时长分布的数量，比如100到120分钟的电影数。 组数=极差/组距。 123456789101112a = [120,76,124,161……] #250部电影的时长。#计算组数theory_d = 3 #假定组距num_bins = (max(a)-min(a))//d #计算组数plt.figure(figsize = (20,8),dpi=80)plt.hist(a,num_bins) #频数分布直方图plt.hist(a,num_bins,normed=True) #频率分布直方图#设置x刻度plt.xticks(range(min(a),max(a)+d,d))plt.grid()plt.show() 当（最大值-最小值）/假定组距 无法除尽时，根据假定组距绘制的x刻度会偏移。 2.11 绘制其他图形 https://matplotlib.org/gallery/index.html 前端画图库js——echarts： https://echarts.apache.org/examples/zh/index.html 图表代码托管——Plotly:https://plot.ly/python 2：Numpy什么时numpy？ 一个再python中做科学计算的基础库，重在数值计算，也是大部分python科学计算库的基础库，多用于在大型、多维数组上执行数值计算。 2.1 创建数组：12345678import numpy as npa = np.array([1,2,3])b = np.array(range(10))c = np.arange(10) #作用与b的表达式相同print(a)print(type(a)) 结果： [1 2 3] &lt;class ‘nmpy.ndarray’&gt; 2.2 数据类型123456d = np.array(range(1,4),dtype=&quot;float32&quot;) #dtype指定数组中数据的数据类型e = np.array([1,1,0,0,0,1],dtype=bool)print(e.dtype) #打印数组中数据的数据类型#调整数据类型f = d.astype(&quot;int8&quot;) 修改浮点型的小数位数 12a &#x3D; np.array(random.random() for i in range(10))np.round(a,2) 2.3 数组形状123t1 = np.array([[1,2,3],[3,4,5]])t1.shape #out:(2,3) 数组的形状 1234t2 = np.arange(12) #新建一维数组t3 = t2.reshape(3,4) #变为二维的t4 = t2.reshape(24,) #变一维数组t5 = t2.flatten() #变一维数组 2.4 数组计算数组和数 12345t6 = np.arange(24)t7 = t6.reshape(4,6)t7+2 #数组中每个数都加2t7*2 #每个数都乘2t7/2 #每个数都除2，会得到浮点数 数组和数组 形状相同：(4,6)与(4,6) 123t8 = np.arange(100,124).reshape(4,6)t7+t8 #形状相同，行列相同的数值进行运算t7*t8 (4,6)与(,6) (4,6)与(4,1) 广播原则： 如果两个数组的后缘维度，即从末尾开始算起的维度的轴长度相符或其中一方的长度为1，则认为他们是广播兼容的。广播会在缺失和或长度为1的维度上进行 2.5 读取数据轴 一维数组只有一个轴，即0轴 二维数组有两个轴，0和1轴。(2,5)，2是0轴长度，5是1轴长度 三维数组有三个轴，0，1，2轴 读取数据 1np.loadtxt(frame,dtype=np.float,delimiter=None,skiprows=0,usecols=None,unpack=False) frame：文件、字符串或产生器 dtype：数据类型 dlimiter：分割字符串，默认是空格 skiprows：跳过前x行 usecols：读取指定的列 unpack：True表示，读入属性将分别写入不同的数组变量，False 读入数据只写入一个数组变量，默认False。转置效果。 读取的文件内容格式： 12341241,1241,15346,2451125415,235,4135,135112516,15326,1361,616…… 读取时可以按,分割。按行划分 2.6 矩阵转置123t2.transpose()t2.Tt2.swapaxes(1,0) #交换轴，也能实现转置效果 2.7 索引和切片取第二行： 1t2[2] 取连续的多行： 1t2[2:] 取不连续的多行： 1t2[[2,8,10]] 取第一列： 1t2[:,0] 取连续多列： 1t2[:,2:] 取不连续的多列： 1t2[:,[0,2,5]] 取3行四列的值： 1t2[3,4] 取多行多列：3行到5行，2列到4列，因为:左右是左闭右开区间，行数为索引+1 1t2[2:5,1:4] 取多个不连续的点：(0,0) (2,1) (5,5) 1t2[[0,2,5],[0,1,5]] 2.8 修改数值1t[:,2:4] = 0 布尔索引 123t2&lt;10 #相同的矩阵，矩阵值为布尔类型，对应位置满足值小于10，则为1，否则为0t2[t2&lt;10] = 3 #t2中小于10的位置，赋值为3t2[t2&lt;10] #取t2中小于10的数组成新矩阵 三元运算符 1np.where(t&lt;10,0,10) #如果小于10，替换为0，否则替换为10 裁剪 1t.clip(10,18) #小于10的替换为10，大于18的替换为18 12t2 = t2.astype(float)t2[3,3] = np.nan 2.9 拼接数组12np.vstack(t1,t2) #竖直拼接np.hstack(t1,t2) #水平拼接 2.10 行列交换行交换： 1t[[1,2],:] = t[[2,1],:] 列交换： 1t[:,[0,2]] = t[:,[2,0]] 2.11 其他方法123456789#获取最大最小值np.argmax(t,axis=0)np.argmin(t,axis=1)#创建一个全0的数组np.zeros((3,4))#创建全1数组np.ones((3,4))#创建一个对角线为1的正方形数组（方阵）np.eye(3) 2.12 生成随机数123np.random.rand(3,4) #均匀分布np.random.randn(3,4) #标准正太分布的随机数，平均数为0，标准差为1np.random.randint(low,high,(shape)) #产生[low,high)之间的数 种子： 12np.random.seed(10)t = np.random.randint(0,20,(3,4)) #每次随机的结果相同 2.13 copy和view a=b完全不复制，a和b相互影响。 a = b[:]，视图操作，创建新对象a，但a的数据完全由b保管，两者数据变化一致。 a = b.copy()复制，a和b互不影响。 2.14 nan和infnan(NAN,Nan)：not a number表示不是一个数字 inf(-inf,inf)：infinity，正无穷，-inf表示负无穷 一个数字除以0，python中会报错，numpy中是一个inf nan： 两个nan不相等 12np.nan !=np.nan#True 计算nan个数 12np.count_nonzero(t2!=t2) #t2!=t2，得到新矩阵，每个位置是bool类型，true表示该位置是nannp.count_nonzero(np.isnan(t2)) # 计算矩阵和 12np.sum(t3)np.sum(t3, axis=0) #数组元素个数，与列数相同。，计算对应列上的和 2.15 常用统计函数求和：t.sum(axis=0) 均值：t.mean(axis=0) 中值：t.median(axis) 最大值：t.max 最小值:t.min 极值：np.ptp(t,axis=None) 最大值和最小值之差 标准差：t.std(axis=None) 默认返回多维数组的全部统计结果","categories":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/categories/Python/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"https://sci.ci/tags/Pandas/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://sci.ci/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://sci.ci/tags/Numpy/"}]},{"title":"利用树莓派定时抢图书馆座位","slug":"利用树莓派定时抢图书馆座位","date":"2020-09-27T16:49:13.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/27/利用树莓派定时抢图书馆座位/","link":"","permalink":"https://sci.ci/2020/09/27/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9A%E6%97%B6%E6%8A%A2%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%BA%A7%E4%BD%8D/","excerpt":"","text":"1：需求分析由于新冠疫情的影响，学校图书馆和自习室必须在监管之下运行，每日提供的坐席和开放时间受限。大部分自习室被关闭，导致坐席需求很大，而供应很少。新规要求，图书馆和自习室的坐席必须在学校官网上预定，而且预定时间是周日到周四早上八点，仅能预定后一天的位置。 在考试周，座位非常难抢到，因此萌发了通过程序抢座的念头。 目前需求是，程序在周天到周日的早上八点启动，并打开抢座页面，抢座后关闭程序。抢座成功后，学校会自动发送抢座成功的邮件。 2：软硬件应用服务器：树莓派4B+、Linux系统 语言：Python 依赖库：Selenium，date Linux工具：crontab 3：抢座程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support.ui import Selectfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom time import sleepimport datetime#点击buchen按钮def clickbucheng(driver): inputs = driver.find_elements_by_tag_name(&#x27;input&#x27;) for input in inputs: if input.get_attribute(&#x27;value&#x27;) == &#x27;buchen&#x27;: ActionChains(driver).click(input).perform() # writetohtml(driver,r&quot;C:\\Users\\97532\\OneDrive\\程序仓库\\getPlatzinBibliothek\\1.html&quot;) window = driver.window_handles[1] driver.switch_to.window(window) driver.find_elements_by_css_selector(&#x27;#bs_form_main &gt; div &gt; div.bs_etvg &gt; div &gt; label &gt; div.bs_form_uni.bs_right.padding0 &gt; input&#x27;)[0].click() print(datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H:%M:%S&#x27;),&quot;: start buchen&quot;) return 1 return 0#发送表格信息def sendform(driver): # writetohtml(driver,r&#x27;C:\\Users\\97532\\OneDrive\\程序仓库\\getPlatzinBibliothek\\2.html&#x27;) #sex:M/W urinfo = &#123;&quot;sex&quot;:&quot;M&quot;,&quot;vorname&quot;:&quot;***&quot;,&quot;name&quot;:&quot;***&quot;,&quot;strasse&quot;:&quot;Hai***1&quot;,&quot;ort&quot;:&quot;***&quot;,&quot;status&quot;:&quot;S-RWTH&quot;,&quot;matnr&quot;:&quot;***93&quot;,&quot;email&quot;:&quot;im@xieqifei.com&quot;,&quot;telefon&quot;:&quot;0049***4845&quot;&#125; radios = driver.find_elements_by_name(&#x27;sex&#x27;) vorname = driver.find_element_by_name(&#x27;vorname&#x27;) name = driver.find_element_by_name(&#x27;name&#x27;) strasse = driver.find_element_by_name(&#x27;strasse&#x27;) ort = driver.find_element_by_name(&#x27;ort&#x27;) status = Select(driver.find_element_by_name(&#x27;statusorig&#x27;)) matnr = driver.find_element_by_name(&#x27;matnr&#x27;) email = driver.find_element_by_name(&#x27;email&#x27;) telefon = driver.find_element_by_name(&#x27;telefon&#x27;) tnbed = driver.find_element_by_name(&#x27;tnbed&#x27;) submit = driver.find_element_by_css_selector(&#x27;#bs_foot &gt; div.bs_form_row &gt; div.bs_right &gt; input&#x27;) for radio in radios: if radio.get_attribute(&quot;value&quot;) == urinfo[&#x27;sex&#x27;]: radio.click() break vorname.send_keys(urinfo[&#x27;vorname&#x27;]) name.send_keys(urinfo[&#x27;name&#x27;]) strasse.send_keys(urinfo[&#x27;strasse&#x27;]) ort.send_keys(urinfo[&#x27;ort&#x27;]) status.select_by_value(urinfo[&#x27;status&#x27;]) matnr.send_keys(urinfo[&#x27;matnr&#x27;]) email.send_keys(urinfo[&#x27;email&#x27;]) telefon.send_keys(urinfo[&#x27;telefon&#x27;]) tnbed.click() telefon.click() sleep(4) # WebDriverWait(driver, 10).until(EC.element_to_be_clickable(By.XPATH,&#x27;//*[@id=&quot;bs_foot&quot;]/div[3]/div[2]/input&#x27;)) submit.click() print(datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H:%M:%S&#x27;),&quot;: send MsgForm&quot;) return 1#确认预定def confirm(driver): confirm = driver.find_element_by_css_selector(&#x27;#bs_foot &gt; div.bs_form_row &gt; div.bs_right &gt; input&#x27;) confirm.click() print(datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H:%M:%S&#x27;),&quot;: confirm,buchen success!&quot;)#可发送用户名密码抢座def sendpw(driver): logininfo = &#123;&quot;pw_email&quot;:&quot;im@xieqifei.com&quot;,&quot;password&quot;:&quot;***&quot;&#125; pw_email = driver.find_element_by_name(&#x27;pw_email&#x27;) pw = driver.find_element_by_css_selector(&#x27;#bs_pw_anm &gt; div:nth-child(3) &gt; div.bs_form_sp2 &gt; input&#x27;) submit2 = driver.find_element_by_css_selector(&#x27;#bs_pw_anm &gt; div.bs_form_foot &gt; div.bs_form_row &gt; div.bs_right &gt; input&#x27;) pw_email.send_keys(logininfo[&#x27;pw_email&#x27;]) pw.send_keys(logininfo[&#x27;password&#x27;]) # sleep(3) submit2.submit() &quot;&quot;&quot;def writetohtml(driver,path): f = open(path,&#x27;wb&#x27;) f.write(driver.page_source.encode(&quot;utf-8&quot;, &quot;ignore&quot;)) f.close() &quot;&quot;&quot; if __name__ == &quot;__main__&quot;: #path = &quot;/home/pi/Programms/getPlatzinBibliothek/chromedriver&quot; option = webdriver.ChromeOptions() option.add_argument(&#x27;--headless&#x27;) driver = webdriver.Chrome(options=option) print(datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H:%M:%S&#x27;),&quot;: chrome start up&quot;) # driver.get(&#x27;file:///C:/Users/97532/Desktop/Anmeldung.html&#x27;) driver.get(&#x27;https://buchung.hsz.rwth-aachen.de/angebote/aktueller_zeitraum/_Lernraumbuchung.html&#x27;) ok = clickbucheng(driver) count = 0 while ok != 1 and count &lt; 10: sleep(1) driver.refresh() ok = clickbucheng(driver) count = count + 1 else: if ok == 1: sendform(driver) confirm(driver) #driver.get_screenshot_as_file(r&quot;/home/pi/Programms/tushuguan.jpg&quot;) sleep(1) print(datetime.datetime.now().strftime(&#x27;%Y.%m.%d-%H:%M:%S&#x27;),&quot;: chrome shutdown&quot;) driver.quit() 使用Selenium驱动chrome浏览器，实行web自动化，完成抢座功能。 4：定时任务在树莓派上，利用Linux定时工具crontab，指定程序在每周天到周四上午八点运行。 创建shell脚本，bibplatz.sh 123#!/bin/bashcd /home/pi/Programms/getPlatzinBibliothekpython3 -u getplatz.py &gt; result.log 2&gt;&amp;1 添加任务 1crontab -e 在vim编辑器中添加任务 10 8 * * 0-4 /home/pi/bibplatz.sh &amp; crontab的格式为：* * * * * command 五个*分别代表，分钟，小时，天，月，周 查看任务 1crontab -l 5：参考资料《Linux定时任务Crontab命令详解》 《Linux后台运行Python程序的几种方法讲解》 《linux下后台运行python程序并输出到日志文件中》","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/tags/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"树莓派Chrome浏览器驱动webdriver","slug":"树莓派Chrome浏览器驱动webdriver","date":"2020-09-21T20:01:57.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/21/树莓派Chrome浏览器驱动webdriver/","link":"","permalink":"https://sci.ci/2020/09/21/%E6%A0%91%E8%8E%93%E6%B4%BEChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A9%B1%E5%8A%A8webdriver/","excerpt":"","text":"树莓派上的系统是基于Arm内核的Linux，且是32位系统，在Google上面下载的chromedriver在selenium运行时，会报错，可以直接使用apt-get安装chromedriver。 安装命令： 1sudo apt-get install chromium-chromedriver 会自动识别树莓派上原有的chrome浏览器版本。 在python程序中，可直接使用webdriver.Chrome()而无需再指定驱动路径。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://sci.ci/tags/Selenium/"}]},{"title":"ADB参考指令","slug":"ADB参考指令","date":"2020-09-21T14:31:53.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/21/ADB参考指令/","link":"","permalink":"https://sci.ci/2020/09/21/ADB%E5%8F%82%E8%80%83%E6%8C%87%E4%BB%A4/","excerpt":"","text":"1：参考资料《使用adb命令操控Android手机（adb命令）》：从连接设备，到键盘输入和点击操作 《adb shell getevent中获取到的屏幕事件的坐标转换》","categories":[{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/categories/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"https://sci.ci/tags/ADB/"}]},{"title":"Selenium库常用操作记录","slug":"Selenium常用操作记录","date":"2020-09-18T17:06:09.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/18/Selenium常用操作记录/","link":"","permalink":"https://sci.ci/2020/09/18/Selenium%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1：Selenium简介Selenium库是一个用于浏览器自动化pyhon库。对提高爬虫容错率有很好的效果。它可用于驱动浏览器，来帮助我们实现获取网站js脚本执行后的网页。 2：Selenium安装2.1 安装1pip install selenium 2.2 浏览器驱动下载浏览器驱动： Firefox浏览器驱动：geckodriver Chrome浏览器驱动：chromedriver , taobao备用地址 IE浏览器驱动：IEDriverServer Edge浏览器驱动：MicrosoftWebDriver Opera浏览器驱动：operadriver PhantomJS浏览器驱动：phantomjs 将驱动放到某个路径下，并在环境变量中指明。例如： 驱动放在目录：C:/abc/webdriver.exe 则需要在用户或者系统环境变量中，给Path变量添加新变量：C:/abc 或者指定驱动路径 123from selenium import webdriverpath = &quot;/path/to/chromedriver&quot; #注意这个路径需要时可执行路径（chmod 777 dir or 755 dir）driver = webdriver.Chrome(executable_path=path) 不同的浏览器启动方式： 123456789101112from selenium import webdriverdriver = webdriver.Firefox() # Firefox浏览器driver = webdriver.Chrome() # Chrome浏览器driver = webdriver.Ie() # Internet Explorer浏览器driver = webdriver.Edge() # Edge浏览器driver = webdriver.Opera() # Opera浏览器driver = webdriver.PhantomJS() # PhantomJS 3：浏览器选项和操作3.1 浏览器选项每次当selenium启动chrome浏览器的时候，chrome浏览器很干净，没有插件、没有收藏、没有历史记录，这是因为selenium在启动chrome时为了保证最快的运行效率，启动了一个裸浏览器，这就是为什么需要配置参数的原因，但是有些时候我们需要的不仅是一个裸浏览器。 selenium启动配置参数接收是ChromeOptions类，创建方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from selenium import webdriveroption = webdriver.ChromeOptions()# 添加启动参数option.add_argument()# 添加扩展应用 option.add_extension()option.add_encoded_extension()# 添加实验性质的设置参数 option.add_experimental_option()# 设置调试器地址option.debugger_address()# 添加UAoptions.add_argument(&#x27;user-agent=&quot;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&quot;&#x27;)# 指定浏览器分辨率options.add_argument(&#x27;window-size=1920x3000&#x27;) # 谷歌文档提到需要加上这个属性来规避bugchrome_options.add_argument(&#x27;--disable-gpu&#x27;) # 隐藏滚动条, 应对一些特殊页面options.add_argument(&#x27;--hide-scrollbars&#x27;)# 不加载图片, 提升速度options.add_argument(&#x27;blink-settings=imagesEnabled=false&#x27;) # 浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败options.add_argument(&#x27;--headless&#x27;) # 以最高权限运行options.add_argument(&#x27;--no-sandbox&#x27;)# 手动指定使用的浏览器位置options.binary_location = r&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot; #添加crx插件option.add_extension(&#x27;d:\\crx\\AdBlock_v2.17.crx&#x27;) # 禁用JavaScriptoption.add_argument(&quot;--disable-javascript&quot;) # 设置开发者模式启动，该模式下webdriver属性为正常值options.add_experimental_option(&#x27;excludeSwitches&#x27;, [&#x27;enable-automation&#x27;]) # 禁用浏览器弹窗prefs = &#123; &#x27;profile.default_content_setting_values&#x27; : &#123; &#x27;notifications&#x27; : 2 &#125; &#125; options.add_experimental_option(&#x27;prefs&#x27;,prefs)driver=webdriver.Chrome(chrome_options=chrome_options) 其他配置参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586–user-data-dir=”[PATH]” # 指定用户文件夹User Data路径，可以把书签这样的用户数据保存在系统分区以外的分区 –disk-cache-dir=”[PATH]“ # 指定缓存Cache路径 –disk-cache-size= # 指定Cache大小，单位Byte –first run # 重置到初始状态，第一次运行 –incognito # 隐身模式启动 –disable-javascript # 禁用Javascript --omnibox-popup-count=&quot;num&quot; # 将地址栏弹出的提示菜单数量改为num个 --user-agent=&quot;xxxxxxxx&quot; # 修改HTTP请求头部的Agent字符串，可以通过about:version页面查看修改效果 --disable-plugins # 禁止加载所有插件，可以增加速度。可以通过about:plugins页面查看效果 --disable-javascript # 禁用JavaScript，如果觉得速度慢在加上这个 --disable-java # 禁用java --start-maximized # 启动就最大化 --no-sandbox # 取消沙盒模式 --single-process # 单进程运行 --process-per-tab # 每个标签使用单独进程 --process-per-site # 每个站点使用单独进程 --in-process-plugins # 插件不启用单独进程 --disable-popup-blocking # 禁用弹出拦截 --disable-plugins # 禁用插件 --disable-images # 禁用图像 --incognito # 启动进入隐身模式 --enable-udd-profiles # 启用账户切换菜单 --proxy-pac-url # 使用pac代理 [via 1/2] --lang=zh-CN # 设置语言为简体中文 --disk-cache-dir # 自定义缓存目录 --disk-cache-size # 自定义缓存最大值（单位byte） --media-cache-size # 自定义多媒体缓存最大值（单位byte） --bookmark-menu # 在工具 栏增加一个书签按钮 --enable-sync # 启用书签同步 3.2 浏览器操作 控制浏览器窗口大小 1driver.set_window_size(480, 800) 浏览器后退，前进 1234# 后退 driver.back() # 前进 driver.forward() 刷新 1driver.refresh() # 刷新 4：元素定位和操作4.1 元素定位获取首个匹配元素： 12345678find_element_by_id()find_element_by_name()find_element_by_class_name()find_element_by_tag_name()find_element_by_link_text()find_element_by_partial_link_text()find_element_by_xpath()find_element_by_css_selector() 如果具有多个匹配属性元素，可使用： 1find_elements_by_class_name() 即在element后加s 4.2 输入、提交 点击和输入 1driver.find_element_by_id(&quot;kw&quot;).clear() # 清楚文本 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) # 模拟按键输入 driver.find_element_by_id(&quot;su&quot;).click() # 单机元素 提交 可以在搜索框模拟回车操作 12search_text = driver.find_element_by_id(&#x27;kw&#x27;) search_text.send_keys(&#x27;selenium&#x27;) search_text.submit() 其他 size： 返回元素的尺寸。 text： 获取元素的文本。 get_attribute(name)： 获得属性值。 is_displayed()： 设置该元素是否用户可见。 4.3 鼠标操作在 WebDriver 中， 将这些关于鼠标操作的方法封装在 ActionChains 类提供。 ActionChains 类提供了鼠标操作的常用方法： 1234567891011121314151617181920212223242526272829click（on_element &#x3D; None）-鼠标左键click_and_hold（on_element &#x3D; None）-单击鼠标左键，不松开context_click（on_element &#x3D; None）-点击鼠标右键double_click（on_element &#x3D; None）-双击鼠标左键drag_and_drop（源，目标）-拖拽到某个元素然后松开drag_and_drop_by_offset（source，xoffset，yoffset）-拖拽到某个坐标然后松开key_down（value，element &#x3D; None）-点击某个键盘上的键key_up（value，element &#x3D; None）-松开某个键move_by_offset（xoffset，yoffset）-鼠标从当前位置移动到某个坐标move_to_element（to_element）-鼠标移动到某个元素move_to_element_with_offset（to_element，xoffset，yoffset）-移动到距离某个元素（左上角坐标）多少距离的位置perform（）-执行链中的所有动作释放（on_element &#x3D; None）-在某个元素位置松开鼠标左键send_keys（* keys_to_send）-发送某个键到当前焦点的元素send_keys_to_element（element，* keys_to_send）-发送某个键到指定元素 举个例子： 1234567891011from selenium import webdriver# 引入 ActionChains 类from selenium.webdriver.common.action_chains import ActionChainsdriver = webdriver.Chrome()driver.get(&quot;https://www.baidu.cn&quot;)# 定位到要悬停的元素above = driver.find_element_by_link_text(&quot;设置&quot;)# 对定位到的元素执行鼠标悬停操作ActionChains(driver).move_to_element(above).perform() 4.4 键盘事件以下为常用的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,’a’) 全选（Ctrl+A） send_keys(Keys.CONTROL,’c’) 复制（Ctrl+C） send_keys(Keys.CONTROL,’x’) 剪切（Ctrl+X） send_keys(Keys.CONTROL,’v’) 粘贴（Ctrl+V） send_keys(Keys.F1) 键盘 F1 …… send_keys(Keys.F12) 键盘 F12 12345# 输入框输入内容driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;seleniumm&quot;)# 删除多输入的一个 mdriver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.BACK_SPACE) 4.5 获取断言信息123title = driver.title # 打印当前页面titlenow_url = driver.current_url # 打印当前页面URLuser = driver.find_element_by_class_name(&#x27;nums&#x27;).text # # 获取结果数目 4.6 等待页面加载完成 显示等待 显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）。 12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firefox()driver.get(&quot;http://www.baidu.com&quot;)element = WebDriverWait(driver, 5, 0.5).until( EC.presence_of_element_located((By.ID, &quot;kw&quot;)) )element.send_keys(&#x27;selenium&#x27;)driver.quit() WebDriverWait类是由WebDirver 提供的等待方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。具体格式如下： 1WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) driver ：浏览器驱动。 timeout ：最长超时时间，默认以秒为单位。 poll_frequency ：检测的间隔（步长）时间，默认为0.5S。 ignored_exceptions ：超时后的异常信息，默认情况下抛NoSuchElementException异常。 WebDriverWait()一般由until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。 until(method, message=‘’) 调用该方法提供的驱动程序作为一个参数，直到返回值为True。 until_not(method, message=‘’) 调用该方法提供的驱动程序作为一个参数，直到返回值为False。 在本例中，通过as关键字将expected_conditions 重命名为EC，并调用presence_of_element_located()方法判断元素是否存在。 隐式等待 如果某些元素不是立即可用的，隐式等待是告诉WebDriver去等待一定的时间后去查找元素。 默认等待时间是0秒，一旦设置该值，隐式等待是设置该WebDriver的实例的生命周期。 12345from selenium import webdriverdriver = webdriver.Firefox() driver.implicitly_wait(10) # seconds driver.get(&quot;http://somedomain/url_that_delays_loading&quot;) myDynamicElement = driver.find_element_by_id(&quot;myDynamicElement&quot;) 4.7 在不同的iframe之间移动12driver.switch_to_window(&quot;windowName&quot;)driver.switch_to_frame(&quot;frameName&quot;) 以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 12345#先通过xpth定位到iframexf = driver.find_element_by_xpath(&#x27;//*[@id=&quot;x-URS-iframe&quot;]&#x27;)#再将定位对象传给switch_to_frame()方法driver.switch_to_frame(xf) 一旦我们完成了frame中的工作，我们可以这样返回父frame: 1driver.switch_to_default_content() 4.8 警告框处理1alert = driver.switch_to_alert() text：返回 alert/confirm/prompt 中的文字信息。 accept()：接受现有警告框。 dismiss()：解散现有警告框。 send_keys(keysToSend)：发送文本至警告框。keysToSend：将文本发送至警告框。 4.9 下拉框选择123456789from selenium import webdriverfrom selenium.webdriver.support.select import Selectfrom time import sleepdriver = webdriver.Chrome()driver.implicitly_wait(10)driver.get(&#x27;http://www.baidu.com&#x27;)sel = driver.find_element_by_xpath(&quot;//select[@id=&#x27;nr&#x27;]&quot;)Select(sel).select_by_value(&#x27;50&#x27;) # 显示50条 4.10 文件上传1driver.find_element_by_name(&quot;file&quot;).send_keys(&#x27;D:\\\\upload_file.txt&#x27;) # # 定位上传按钮，添加本地文件 4.11 cookie操作WebDriver操作cookie的方法： get_cookies()： 获得所有cookie信息。 get_cookie(name)： 返回字典的key为“name”的cookie信息。 add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。 delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。 delete_all_cookies()： 删除所有cookie信息 4.12 调用JavaScript代码12js=&quot;window.scrollTo(100,450);&quot;driver.execute_script(js) # 通过javascript设置浏览器窗口的滚动条位置 通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。 4.13 窗口截图1driver.get_screenshot_as_file(&quot;D:\\\\baidu_img.jpg&quot;) # 截取当前窗口，并指定截图图片的保存位置 4.14 关闭浏览器 close() 关闭单个窗口 quit() 关闭所有窗口 4.15 直接用cookie登录方法链接：https://www.jianshu.com/p/773c58406bdb 手动获取网页的cookie，将其序列化并存储在本地 写入代码 12for item in cookies: driver.add_cookie(item) 4.16 导出html到beautifulsoup或文件1soup = BeautifulSoup(driver.page_source,&quot;html.parser&quot;) 1234def writetohtml(driver,path): f = open(path,&#x27;wb&#x27;) f.write(driver.page_source.encode(&quot;utf-8&quot;, &quot;ignore&quot;)) f.close() 5：控件操作5.1 SelectSelect类提供了三种选择某些选项的方法： 123select_by_index(index)select_by_value(value)select_by_visible_text(text) index从0开始，第一个option为0 value是标签的属性值 visible_text是option标签中间的值，即下拉框可见值 自然的，有选择必然有反选，即取消选择。Select提供了四个方法给我们取消原来的选择： 1234deselect_by_index(index)deselect_by_value(value)deselect_by_visible_text(text)deselect_all() 前一种分别于select相对应，第四种是全部取消选择，是的，你没看错，是全部取消。有一种特殊的选择标签，即设置了multiple=&quot;multiple&quot;属性的select，这种select框是可以多选的，你可以通过多次select，选择多个选项，而通过deselect_all()来将他们全部取消。 当我们选择了选项之后，想要看看选择的是哪项，替代的是否是我想选的，怎么办？别担心，Select为你提供了相应的方法（或者应该说是属性了）： 123optionsall_selected_optionsfirst_selected_option 上面三个属性，分别返回这个select元素所有的options，所有被选中的options以及第一个被选中的option。 5.2 Radio和Checkbox12345678910111213&lt;html&gt;&lt;body&gt;Checkbox:&lt;input type=&quot;checkbox&quot; value=&quot;cv1&quot; name=&quot;c1&quot;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;cv2&quot;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;cv3&quot; name=&quot;c1&quot;&gt;&lt;input type=&quot;checkbox&quot; value=&quot;cv4&quot;&gt;&lt;p&gt;Radio:&lt;input type=&quot;radio&quot; value=&quot;rv1&quot; name=&quot;r1&quot;&gt;&lt;input type=&quot;radio&quot; value=&quot;rv2&quot; name=&quot;r1&quot;&gt;&lt;/body&gt;&lt;/html&gt; 选择操作即点击事件，清除选择即键盘操作 12345678# checkboxdriver.find_element_by_xpath(&#x27;//input[@value=&quot;cv1&quot;]&#x27;).click() # clickdriver.find_element_by_xpath(&#x27;//input[@value=&quot;cv2&quot;]&#x27;).send_keys(Keys.SPACE) # send space# radiodriver.find_element_by_xpath(&#x27;//input[@value=&quot;rv1&quot;]&#x27;).send_keys(Keys.SPACE) # send spacesleep(1)driver.find_element_by_xpath(&#x27;//input[@value=&quot;rv2&quot;]&#x27;).click() # click 6：参考资料《Selenium Python 教程》 《selenium启动Chrome配置参数问题》 《Python硒-模拟鼠标键盘操作（ActionChains）》 《Python硒-操作选择标签的下拉选择框》 《Python+selenium使用cookie登录淘宝》","categories":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/categories/Python/"}],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://sci.ci/tags/Selenium/"}]},{"title":"利用树莓派+内网穿透搭建网站服务器","slug":"利用树莓派-内网穿透搭建网站服务器","date":"2020-09-10T20:08:39.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/10/利用树莓派-内网穿透搭建网站服务器/","link":"","permalink":"https://sci.ci/2020/09/10/%E5%88%A9%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"1：前言在购买了树莓派之后，我一直在找寻它的用处，最近想学基于Python的网站后端框架Django，而树莓派以linux为操作系统，有天生作为网站服务器的优点。以下列举部分。 相比于直接购买高配置VPS，使用树莓派+廉价低配VPS做内网穿透，更加划算。 相比于使用windows作为网站服务器联系，树莓派可以保持24*7不宕机，避免每次开启电脑都要重新运行服务器程序的麻烦。 开始之前，需要说明的一些软硬件配置。 4B+树莓派，4g内存+32g内存卡 一台低配置带ipv4地址的VPS。本人使用Ubuntu系统 一个域名，需要将A记录解析到VPS的ipv4地址上。非必须，可直接用vps的ip地址访问也是可以的。 2：树莓派上搭建Django服务器安装Django教程：《Django安装》 在树莓派上安装Django。 并创建第一个Django项目。 在使用python3 manage.py runserver 0.0.0.0:8000打开服务后， 在shell终端上使用 1curl 127.0.0.1:8000 是可以访问新建的网站的。 但是，使用树莓派内网ip:8000在相同局域网下的笔记本，无法访问网站，必须修改项目配置文件。后期可修改回来，因为我们需要在树莓派上也安装nginx以作为生产环境，现在只是测试。修改项目下的setting.py文件 12DEBUG = FalseALLOWED_HOSTS = [&quot;*&quot;] 此时，在笔记本上访问树莓派上面的网站，应该已经能够访问了。 3：内网穿透为了让外网的人，能够使用ip地址或者域名，访问到树莓派上的网站，需要做内网穿透，首先，需要让VPS能够访问到树莓派。 使用花生壳之类的软件也能实现内网穿透，且不用VPS，但是这类软件收费比较高，所以我们可以用VPS自己搞一个内网穿透。 使用p2p组网的内网穿透软件，比如n2n、zerotier、frp。在github上都能搜得到。frp是一个端口转发的软件，不需要借助别人提供的服务器来做导航，如果只是做网站是非常推荐的，因为这不设及后面讲的nginx做反向代理的步骤，个人是很推荐的。但，如果你有多个VPS或者多个电脑，想组成局域网，建议使用zerotier。我这里使用的是zerotier，因为它配置比较简单。并在此基础上做了网站的反向代理，以实现外网访问内网，和frp直接做端口转发的原理是不同的。 我们需要分别在树莓派和vps上安装zerotier。 1curl -s https://install.zerotier.com | sudo bash 然后在zerotier官网创建一个账号，并创建一个网络。可参考教程： 内网穿透工具——ZeroTier One的使用 建好网络后，获得十六位网络码 然后，在树莓派和vps输入命令 1zerotier-cli join 网络码 即可加入此网络 然后回到zerotier官网，管理这两个网络，让他们之间能够互相ping通。此间步骤比较多，需要耐心自学。 内网穿透实现后，在vps上不仅应该能够ping通树莓派虚拟局域网分配的ip，而且使用虚拟局域网ip:端口，应该能够访问到树莓派上的网站。 在vps使用 1curl http://ip:port 访问。获取html代码，则内网穿透可以访问网站了。 4：Nginx反向代理为了让所有外部的人，都能够通过域名或者vps公网ip访问到树莓派的网站，需要在vps上安装nginx，作反向代理。 原理大概是，外部用户，访问vps的ip，浏览器默认不输入端口则访问80端口，http对应80，https对应443。比如用户输入http://x.x.x.x或者http://example.com则默认访问vps的80端口。 我们需要为vps开放80端口，并将80端口的访问请求转到树莓派的网站端口。 安装nginx 1apt-get install nginx 配置nginx，新建配置文件，并配置nginx 12touch /etc/nginx/conf.d/respberry.conf #新建配置文件vim /etc/nginx/conf.d/respberry.conf #编辑配置文件 在文件中输入配置 1234567server&#123; listen 80 server_name example.com #你的域名，或者vps的公网ip location / &#123; proxy_pass http://树莓派虚拟局域网ip:网站端口 &#125;&#125; 保存退出。 1service nginx restart #重启nginx 这样通过域名访问vps就能将请求转给树莓派了。外网就能够访问到树莓派了。 5：参考资料《内网穿透工具——ZeroTier One的使用》 《Nginx配置文件nginx.conf中文详解》","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"记录一次在Linux上彻底卸载nginx","slug":"记录一次在Linux上彻底卸载nginx","date":"2020-09-10T19:34:01.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/10/记录一次在Linux上彻底卸载nginx/","link":"","permalink":"https://sci.ci/2020/09/10/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%9C%A8Linux%E4%B8%8A%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDnginx/","excerpt":"","text":"刚想通过nginx做反向代理，以实现内网穿透，但是80端口始终无法ping通，查看linux端口是开着的。思想简单的我，尝试重新安装nginx，然而无论如何都无法卸载干净。首先，nginx可能不是通过apt-get安装的，使用apt remove指令没有卸载掉，于是尝试find / -name nginx -exec rm -rf &#123;&#125; \\;来删除所有以nginx命名的目录，然而apt-get install nginx安装后，任然没有把删除的目录重新安装。 查阅资料后，重新进行了删除和安装 dpkg指令 1dpkg -l #查看安装的软件包 尽管已经通过删除目录移除了nginx，在软件包列表里仍然存在三个包含nginx的软件，nginx、nginx-core、nginx-common 使用指令 1sudo dpkg -r 软件名 #分别删除三个软件 其中nginx-common无法使用上述命令删除， 1sudo apt-get --purge remove nginx-common 至此nginx以彻底移除。 使用 1apt-get install nginx 重新安装nginx。 安装结束，访问ip可出现welcome to nginx网页。 如果没有出现， 1curl http://ip 如果主机上出现html文本，而浏览器外部无法访问，则是防火墙问题。 我在ubuntu上安装了firewall软件，因此导致外部无法访问80端口，使用指令 1systemctl stop firewall.service 关闭firewall。也可能是iptables开启了，相同的办法可以关闭iptables防火墙。 参考文献： 《Linux之Ubuntu下如何查看已安装的软件/库文件》","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://sci.ci/tags/Nginx/"}]},{"title":"计划为Hexo博客添加相册和Vlog页面","slug":"计划为Hexo博客添加相册和Vlog页面","date":"2020-09-08T13:07:33.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/08/计划为Hexo博客添加相册和Vlog页面/","link":"","permalink":"https://sci.ci/2020/09/08/%E8%AE%A1%E5%88%92%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%92%8CVlog%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"计划内容： 新建相册页面，下属图片和vlog分支 以Onedrive作为储存库，储存相册及视频 页面自动获取相册和视频，并展示 首页标题改为计时项目 项目js源码：https://www.bingyublog.com/2019/02/20/hexo%E5%A2%9E%E5%8A%A0%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://sci.ci/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://sci.ci/tags/Hexo/"},{"name":"Vlantis","slug":"Vlantis","permalink":"https://sci.ci/tags/Vlantis/"}]},{"title":"利用海贝音乐做一个自用音乐播放器","slug":"利用海贝音乐做一个自用音乐播放器","date":"2020-09-06T16:45:48.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/09/06/利用海贝音乐做一个自用音乐播放器/","link":"","permalink":"https://sci.ci/2020/09/06/%E5%88%A9%E7%94%A8%E6%B5%B7%E8%B4%9D%E9%9F%B3%E4%B9%90%E5%81%9A%E4%B8%80%E4%B8%AA%E8%87%AA%E7%94%A8%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"1：项目简介对于我这个经常听歌的人来说，免费的听歌软件总是很有用的。我在网上找到了一款叫做海贝音乐的播放器，这个播放器不提供音乐资源，仅仅是一个播放器，可以播放本地音乐、Onedrive云音乐，以及DLNA局域网里的音乐。对于很多人来说，将好听喜欢的音乐下载下来保存到手机，总归是个麻烦的操作，如果想在线听歌，又需要购买音乐软件的VIP。那么有没有一个方法，可以免费而又在不下载音乐在线听歌呢？ 我将利用Onedrive作为音乐储存云盘，并在海贝音乐播放器上，实现在线听歌。将喜欢的音乐下载到Onedrive是个非常麻烦的步骤，为此我将在之后编写一个项目，来实现自动下载热榜音乐至云盘指定目录，并编写一个客户端，用作搜索指定音乐，并保存到云盘的接口。此项目，我将使用python进行编写，并在linux系统上运行。 2：实现原理2.1 音乐来源免费音乐接口总是很难获取，甚至很不稳定，为此我们需要合法的获取音乐资源。为此，我考虑从YouTube上获取音乐资源，因为音乐MV和MP3格式的隶属不同版权，而MV往往是不收费的，所以直接从youtube上下载mv的mp4格式文件，这里利用基于python编写的you-get程序即可，然后，利用ffmpeg软件将mp4格式文件转为mp3格式。 2.2 音乐获取获取音乐当然不能一个一个的获取，我们可以在网上找到网易或者qq音乐的榜单api，获取榜单列表，根据列表内容使用程序来检索音乐。 另外在单独做一个web端，用于搜索音乐。后台根据搜索指令下载音乐。 歌词可以通过歌词迷接口https://hacpai.com/article/1364440883834 获取。 2.3 音乐保存后台转换后的音乐，可以利用onedrive提供的上传接口，把音乐上传到onedrive目录，比如榜单目录和自行搜索的like目录。 定期使用onedrive接口清除过时的音乐也很重要。 2.4 音乐收听海贝音乐app提供了从onedrive源收听音乐的功能，因此，直接在海贝音乐上授权onedrive就能够在线收听了，而一个onedrive目录就是一个播放列表。","categories":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/categories/Python/"}],"tags":[{"name":"音乐播放器","slug":"音乐播放器","permalink":"https://sci.ci/tags/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"}]},{"title":"树莓派4B无网线无显示器出发","slug":"树莓派4B无网线无显示器出发","date":"2020-08-28T20:22:40.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/08/28/树莓派4B无网线无显示器出发/","link":"","permalink":"https://sci.ci/2020/08/28/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%97%A0%E7%BD%91%E7%BA%BF%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E5%87%BA%E5%8F%91/","excerpt":"","text":"从亚马逊新入手了最新款树莓派4B以及相关配件，花了一共109欧。这是第一次把玩树莓派。因为长期浸淫于Linux系统，而受制于surface的小容量硬盘，实在不忍心在电脑上安装一个虚拟机了。之前把玩Linux也是购买的云服务器，但是云服务器是个消耗品啊，而且毕竟是外网，要操做内网设备，比如打印机，就得内网穿透，还是得依赖一个在内网能够长期在线得设备，那么树莓派的作用就不言而喻了。 树莓派自带GPIO这一点，可玩性也非常高。现在开始安装树莓派系统。 一：准备工作1.1 硬件准备 树莓派4B及其电源设备 8G及以上内存卡 笔记本电脑一台 WIFI网络，使用手机热点或者WIFI 1.2 软件准备 SSH连接工具，比如Xshell、Putty。Putty下载，点击下载 Windows 下安装镜像的工具 win32diskimager，本地下载 官网下载 树莓派系统镜像文件，下载地址：https://shumeipai.nxez.com/download 如果需要图形桌面，就下载VNC Viewer，点击下载 二：安装系统下载树莓派镜像后，解压为.ios后缀的文件。然后利用win32diskimager烧录到SD卡中。点击查看详细教程 打开SD卡，在根目录下新建文件名为ssh无后缀名空文件。 在根目录下新建文件名为wpa_supplicant.conf的文件，文件内容为 12345678country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;spzmi8&quot; psk=&quot;yatoummd233&quot;&#125; ssid：wifi名称 psk：wifi密码 将SD卡插入树莓派。 三：登陆树莓派将树莓派接通电源，打开ssh软件入putty或者xshell。之后即可登陆树莓派。 使用以下信息登陆树莓派 主机名 用户名 密码 端口 raspberrypi.local pi raspberry 22 至此树莓派已连接成功。 四：参考资料《无显示器、路由器、网线安装树莓派系统》 《树莓派3B+无显示器配置详细教程》 《树莓派3-系统安装-Windows下利用Win32DiskImager进行系统安装》","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/tags/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"在订单中打印收货地址二维码","slug":"在订单中打印收货地址二维码","date":"2020-08-28T15:14:28.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/08/28/在订单中打印收货地址二维码/","link":"","permalink":"https://sci.ci/2020/08/28/%E5%9C%A8%E8%AE%A2%E5%8D%95%E4%B8%AD%E6%89%93%E5%8D%B0%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E4%BA%8C%E7%BB%B4%E7%A0%81/","excerpt":"","text":"一：简介七夕节在配送过程中，发现配送员由于文化有限，在使用导航软件上有极大的障碍。这不仅拖慢了整个配送过程，也不利于业务的增长。于是我想到了，在订单上打印一个二维码，扫描二维码，则就可以导航到收货地点。 在一段时间的尝试后，我敲定了此方案的可行性。 由于美图和饿了么订单打印，已在飞鹅打印机上固定了模板，我无法修改他们的打印模板。所以，只能为小程序的订单，打印地址二维码。 二：方案由于各个地图公司都没有提供直接的接口，让地图转为二维码，所以退而求其次，需要先将地址转为url，进入这个url可以进入地图界面，然后将url转为二维码。 2.1 地图转url 百度地图方案 在查看了几个地图技术文档后，我找到了百度地图的接口。 地址：http://lbsyun.baidu.com/index.php?title=uri/api/web 此接口提供了免费的调起地图的url方案。由于我们只能拿到收货地址，所以可以使用下面的接口 服务地址 1http:&#x2F;&#x2F;api.map.baidu.com&#x2F;geocoder &#x2F;&#x2F;PC&amp;Webapp服务地址 示例 1http:&#x2F;&#x2F;api.map.baidu.com&#x2F;geocoder?address&#x3D;北京市海淀区上地信息路9号奎科科技大厦&amp;output&#x3D;html&amp;src&#x3D;webapp.baidu.openAPIdemo 打开后的页面 2 高德地图方案 高德地图提供Web调起地图的接口格式如下： 1https:&#x2F;&#x2F;uri.amap.com&#x2F;marker?position&#x3D;116.473195,39.993253 url参数： 参数名称 值(点击可编辑) 参数说明 是否必选 备注 position 116.473195,39.993253 位置点经纬度坐标，格式为: position=lon,lat 是 lon表示经度，lat表示纬度 name 首开广场 用户自定义显示名称 否 src mypage 使用方来源信息 否 为保证服务质量建议填写 coordinate gaode 坐标系参数coordinate=gaode,表示高德坐标（gcj02坐标），coordinate=wgs84,表示wgs84坐标（GPS原始坐标） 否 默认为高德坐标系（gcj02坐标系） callnative 0 是否尝试调起高德地图APP并在APP中查看，0表示不调起，1表示调起, 默认值为0 否 该参数仅在移动端有效 和百度地图不同的是，这个接口不提供类似搜索功能的接口方式，其中经纬度为必填项，因此，我们必须将订单地址，先调用高德的地理名称转经纬度api，在调用此接口。 详细的地理编码api参见：https://lbs.amap.com/api/webservice/guide/api/georegeo/ 通过上述两个api获取，地址的链接，详细php函数如下： 12345678910111213141516171819/** * [getAddressUrl 生成地址url] * @param [string] $taddress [订单地址] * @return [string] [返回地址url] */public function getAddressUrl($address)&#123; $api = &quot;https://restapi.amap.com/v3/geocode/geo&quot;; $key = &quot;你申请的高德地图key&quot;; $request_url = $api.&quot;?address=&quot;.$address.&quot;&amp;output=JSON&amp;key=&quot;.$key; $response = file_get_contents($request_url); $obj = json_decode($response); if(strcmp($obj-&gt;status,&quot;1&quot;)==0)&#123; $location_code = $obj-&gt;geocodes[&quot;0&quot;]-&gt;location; $address_url = &quot;https://uri.amap.com/marker?position=&quot;.$location_code.&quot;&amp;name=&quot;.$address; &#125;else&#123; return 0; &#125; return $address_url; &#125; 对比高德地图和百度地图。百度地图在编程方面更加方便，但是对于扫描二维码体验而言，百度地图必须使用浏览器扫描，或者微信扫描后根据提示打开浏览器，然后由浏览器调起百度地图进入导航。直接使用百度地图扫描二维码是无法调出导航的，而且百度地图扫描功能隐藏在搜索框之中，使用非常不方便。相对而言，用户使用高德地图api生成的二维码使用高德地图首页的扫一扫功能，可以直接进入导航界面。 2.2 url转二维码在网上能找到许多提供url转二维码的api接口。 在简书https://www.jianshu.com/p/064ab5c811cf 里，提供了许多接口。 由于飞鹅打印机的技术文档中说明了，只需要在打印时在&lt;QR&gt;标签中输入url即可自动转换，所以，不在需要使用额外的接口。 ⭐但是需要注意的是，通过get来获取url二维码，必须先使用url_encode将url编码，否则二维码中将丢失url的参数信息。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"电商","slug":"电商","permalink":"https://sci.ci/tags/%E7%94%B5%E5%95%86/"}]},{"title":"订单卡片备注自动打印系统","slug":"订单卡片备注自动打印系统","date":"2020-08-26T13:51:39.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/08/26/订单卡片备注自动打印系统/","link":"","permalink":"https://sci.ci/2020/08/26/%E8%AE%A2%E5%8D%95%E5%8D%A1%E7%89%87%E5%A4%87%E6%B3%A8%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%B0%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"一：系统设计系统思维导图： 各个接单平台在收到订单后，将订单信息发送给公网服务器，公网服务器从订单信息中提取卡片内容，并将卡片内容发送给和打印机处在同一个局域网环境下的树莓派，树莓派发送打印请求。 由于打印机的打印请求必须在局域网环境下发出，内网穿透就是必须的步骤，所以这里的树莓派和公网服务器缺一不可，如果有固定的公网ip，则可取消公网服务器步骤，如果打印机支持http发送api请求创建打印进程，则可取消树莓派的作用。 二：准备工作 申请美团和饿了么API接口。 购买公网服务器，推荐阿里云和腾讯云，学生价购买轻量级应用服务器，一年100元左右。我由于已有小程序，因此和小程序公用了同一台服务器。小程序使用的是开源电商平台“ShopXO”。 树莓派4B和一台打印机。打印机可选普通的喷墨打印机或者标签打印机。喷墨打印机打印的时候需要间歇的将贺卡放入打印机，而标签机则可连续的打印标签，可将打印后的标签贴在贺卡上。各有优缺点，专门购买一个连续打印贺卡的机器通常比较贵。此系统预算在1k元人民币。其中公网服务器100元/年，树莓派可根据自身资金选择，建议在100~500，打印机在300~800。不同的打印机在树莓派编程时，涉及的指令集是不同的。细节可能在后面选好后，在修改这里的内容。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"电商系统","slug":"电商系统","permalink":"https://sci.ci/tags/%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/"}]},{"title":"爬虫基础","slug":"爬虫基础","date":"2020-07-26T08:55:04.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/26/爬虫基础/","link":"","permalink":"https://sci.ci/2020/07/26/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1: 任务介绍和准备工作爬取豆瓣电影Top250的基本信息。 https://movie.douban.com/top250 编码规范： 1234567#coding=utf-8def hello(): print(&quot;hello&quot;) if __name__ = &quot;__main__&quot;: #入口函数，控制函数的执行顺序 hello() 引入模块： 目录结构： - test1 ​ - t1.py - test2 ​ - t2.py t1.py 123def add(a,b): return a+bprint(add(a,b)) 在t2.py中引入，t1.py 12from test1 import t1print(t1.add(3,5)) 引入第三方模块 12345from bs4 import BeautifulSoup #网页解析import re #正则表达式import urllib.request,urllib.error #指定url，获取网页数据import xlwt #进行excel操作import sqlite3 #进行SQLite数据库操作 2：构建流程2.1 基本框架1234567891011121314151617def main(): baseurl = &quot;https://movie.douban.com/top250?start=&quot; #1.爬取网页 datalist = getData(baseurl) savepath = &quot;.\\\\豆瓣电影Top250&quot; #3.保存数据 saveData(savepath) #爬取网页def getData(baseurl): datalist = [] #2.逐一解析数据 return datalist#保存数据def saveData(savepath): #保存 2.2 获取数据12345678910111213141516171819202122def askURL(url): #用户代理，告诉豆瓣，浏览器类型 head = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;&#125; req = urllib.request.Request(url,headers=head) html = &quot;&quot; try: response = urllib.request.urlospen(req) html = response.read().decode(&quot;utf-8&quot;) print(html) except urllib.error.URLError as e: if hasattr(e,&quot;code&quot;):s print(e.code) if hasattr(e,&quot;reason&quot;): print(e.reason)def getData(baseurl): datalist = [] for i in range(0,10): url = baseurl + str(i*25) html = askURL(url) #逐一解析网页 return datalist 3：补充Urllib库get请求 1234import urllib.requestresponse = urllib.request.urlopen(&quot;https://www.baidu.com&quot;)print(response.read().decode(&#x27;utf-8&#x27;)) #对获取到的源码进行解码 Post请求 123456import urllib.requestimport urllib,parsedata = bytes(urllib.parse.urlencode(&#123;&quot;hello&quot;:&quot;world&quot;&#125;),encoding=&quot;utf-8&quot;)response = urlib.request.urlopen(&quot;http://httpbin.org/post&quot;,data = data)print(response.read().decode(&quot;utf-8&quot;)) 超时处理：0.01秒内无反应 12345try: response = urlib.request.urlopen(&quot;http://httpbin.org/get&quot;,timeout = 0.01) print(response.read().decode(&quot;utf-8&quot;))except urllib.error.URLError as e: print(&quot;time out&quot;) 响应内容： 123response.statusresponse.getheader()response.getheader(&quot;Server&quot;) 伪装：headers内容可以在访问网站时查看，request header 123456url = &quot;https://www.douban.com&quot;headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36&quot;&#125;data = bytes(urllib.parse.urlencode(&#123;&quot;name&quot;:&quot;eric&quot;&#125;),encoding=&quot;utf-8&quot;)#封装请求req = urllib.request.Request(url=url,data=data,headers=headers,method=method)response = urllib.request.urlopen(req) 4：补充BeautifSoup库将复杂的html文档转化为树形文档 1234567891011121314151617181920212223242526272829303132from bs4 import BeautifulSoupfile = open(&quot;./baidu.html&quot;,&quot;rb&quot;)html = file.read()bs = BeautifulSoup(html,&quot;html.parser&quot;)print(bs.title)# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;print(bs.title.string)#The Dormouse&#x27;s storyprint(bs.a.attrs)#获取所有属性#find_all()查找所有的a标签t_lists = bs.find_all(&quot;a&quot;)t_lists = bs.find_all(re.compile(&quot;a&quot;))t_lists = bs.find_all(class=&quot;head&quot;)t_lists = bs.find_all(class_=True)t_lists = bs.find_all(text = re.compile(&quot;\\d&quot;)) #查找带数字的文字t_lists = bs.find_all(&quot;a&quot;,limit=3) #限定三个元素#Css选择器bs.select(&#x27;title&#x27;)#&lt;title&gt;sbianm&lt;title&gt;bs.select(&quot;.mnav&quot;)#按类名查找bs.select(&quot;#u1&quot;)#按id查找bs.select(&quot;a[class=&#x27;bri&#x27;]&quot;)#按照属性查找bs.select(&quot;head&gt;title&quot;)#通过子标签来查找bs.select(&quot;.mnv ~ .bri&quot;)#查找.mnv类的兄弟标签，且类名为bri 更多内容：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ 5：补充正则表达式","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"httponly的Cookie","slug":"httponly的Cookie","date":"2020-07-22T15:24:14.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/22/httponly的Cookie/","link":"","permalink":"https://sci.ci/2020/07/22/httponly%E7%9A%84Cookie/","excerpt":"","text":"JS获取cookie的程序是document.cookie，但是为了网站安全。服务器可以设置某些cookie不能使用js获取。这种类型的cookie即使httponly的cookie，而且只有服务器能发送此类cookie。 1setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE); 在最新php中设置cookie的httponly属性，需要将第七个值设置为true。 在浏览器如何获取httponly属性的cookie呢。需要进入控制台，打开Application 设置httponly属性，对于cookie安全非常重要，这样可以防止XSS攻击，攻击者通过植入JS代码，获取网站的cookie，从而以用户身份浏览服务器。 另外设置cookie过期时间与会话Session时间相同，也能有效保护用户信息安全。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"https://sci.ci/tags/Cookie/"}]},{"title":"Python基础","slug":"Python基础","date":"2020-07-22T11:51:02.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/22/Python基础/","link":"","permalink":"https://sci.ci/2020/07/22/Python%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1: Hello Worldwindows win+R打开运行菜单，输入CMD，进入终端。输入python进入python终端程序。输入print(&quot;hello,world&quot;)打印文字。 import this打印python之禅 结束命令提示符： exit() ctrl+z 命令提示符中的每一行是相关联的。 执行以.py结尾文件。 命令提示符中输入python hello.world.py 2: 基础2.1 注释#注释：单行注释 ***注释***：多行注释 2.2 标准化输出12345678910111213141516171819#常规输出print(&quot;标准化输出字符串&quot;)a = 10#字符连接变量print(&quot;这是变量&quot;, a)#变量占位print(&quot;我的年纪是：%d 岁&quot;%a)#多变量占位print(&quot;我的名字是%s，我的国籍是%s&quot;%(&quot;小张&quot;,&quot;中国&quot;))#多个字符串，空格隔开print(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)#多个字符串，指定.隔开print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep=&quot;.&quot;)#无字符串结尾print(&quot;hello&quot;,end=&quot;&quot;)#以空格结尾print(&quot;world&quot;,end=&quot;\\t&quot;)#以回车符结尾print(&quot;python&quot;,end=&quot;\\n&quot;) 输出： 标准化输出字符串这是变量 10我的年纪是：10 岁我的名字是小张，我的国籍是中国aaa bbb cccwww.baidu.comhelloworld python 占位符： 2.3 标准化输入1234password = input(&quot;请输入密码&quot;)print(&quot;您刚才输入的密码是&quot;,password)#测试变量类型print(type(password)) 输出： 请输入密码123您刚才输入的密码是 123&lt;class ‘str’&gt; 即使输入数字，input也是字符串 如果想要输入整型数。使用强制类型转换 123a = int(&quot;123&quot;)print(type(a))print(&quot;输出的是整型%d&quot;%a) 2.4 运算符 3: 判断和循环语句3.1 判断语句：123456if conditino1: codeselif condition2: codeselse: codes :warning:缩进、冒号很重要 3.2 随机生成数：123import random#随机生成[0,2]之间的整数，0、1、2x = random.randint(0,2) 3.3 导入模块和函数导入整个模块：import module 从某个模块中导入某个函数：from module import function 从某个模块导入多个函数：from module import function1, function2 将某个模块的函数全部导入：from module import * 3.4 循环3.4.1 for循环1234567891011121314151617#[0,4]for i in range(5): print(i)#步长为3，[0,10]for i in range(0,10,3): print(i) #打印每个字符 name = &quot;chengdu&quot;for x in name: print(x,end=&quot;\\t&quot;)#打印列表a = [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]for i in range(len(a)): print(i,a[i]) 3.4.2 while循环123456i=0while i&lt;5 : print(i) i += 1else: print(&quot;while结束&quot;) 3.4.3 break和continuebreak：结束所有循环； continue：结束本次循环，进入下次循环。 pass：占位，什么也不执行，但pass后的同级语句会执行，和空行没区别。 4: 核心数据类型4.1 字符串可使用：单引号、双引号和三引号（三个单或双引号），使用反斜杠\\转义 4.1.1 字符串作为数组12345str = &quot;chengdu&quot;print(str)print(str[0])print(str[5:]) #从索引5到最后print(str[0:5:2]) #[起始位置:结束位置:步进值] chengdu c du ceg 4.1.2 字符串连接1234print(str+&quot;,nihao&quot;) #chengdu,nihaoprint(str*3) #连续打印三次print(&quot;hello\\nchengdu&quot;) #\\n转义为换行print(r&quot;hello\\nchengdu&quot;) #转义字符不起作用，直接显示 4.1.3 字符串操作函数bytes.decode字符串解码 isalnum()包含至少一个字母或数字 isalpha()至少一个且全为字母 isdigit()至少一个且全为数字 join(seq)指定字符串做分隔符，合并新的字符串 split()拆分字符串 lstrip()截掉字符串左边的空格或指定字符 rstrip()截掉右边 4.2 列表4.2.1 定义列表12list = []namelist = [&quot;zhang&quot;,&quot;wang&quot;,3] #列表中可以存储混合类型 4.2.2 打印123print(namelist[0])print(namelist[1])print(namelist[2]) 4.2.3 遍历列表for: 123for name in namelist: print(name)print(len(namelist)) #len()获取列表长度 while: 1234i = 0while i&lt;len(namelist): print(namelist[i]) i++ 4.2.4 列表操作函数[ : : ]列表切片 append新增数据到列表尾部 123456789namelist.append(&quot;qian&quot;)a=[1,2]b=[3,4]a.append(b)#输出[1,2,[3,4]] 将列表作为一个元素加入到a中a.extend(b) #将b中的每个元素逐一追加到a中#输出[1,2,[3,4],3,4] insert指定下标位置插入元素， 123a = [0,1,2]a.insert(1,3) #第一个表示索引下标，第二个表示插入的元素（对象）#输出[0,3,1,2] del list[index] 在指定位置删除元素 list.pop()弹出末尾最后一个元素 list.remove(&quot;钢铁侠&quot;)直接删除第一个指定内容的元素，还有的同名元素不会被删除。 12movieName = [&quot;加勒比海盗&quot;,&quot;复仇者&quot;,&quot;钢铁侠&quot;,&quot;蜘蛛侠&quot;]del movieName[2] #删除钢铁侠 in某元素是否在列表中 not in不在列表中 12345name = &quot;wang&quot;if name in namelist: print(&quot;找到名字wang&quot;)else: print(&quot;没找到&quot;) index查找指定下标范围的元素，返回元素在列表中的索引下标，范围区间，左闭右开 1234a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]a.index(&quot;c&quot;,1,4) #范围是[1,4)#输出2#如果没找到会报错 count()查找有多少个元素 12a.count(&quot;c&quot;) #输出1 reverse()将列表元素从后向前反转 123a = [1,4,2,3]a.reverce()#输出[3,2,4,1] sort()排序 1234a.sort()#输出[1,2,3,4]a.sort(reverse=True)#输出[4,3,2,1] 4.3 元组tuple(元组):与list相似，但tuple元素不能修改。 元组的元素不能改，但包含的对象可以修改。 123tup1 = () #创建空元组，带引成tuple类型tup2 = (58) #会打印成整型tup3 = (58,) #打印成tuple类型 元组寻址： 123tup1 = (&quot;abc&quot;,&quot;def&quot;,1421)print(tup1[0])print(tup1[-1]) #倒数第一个 元组不能修改： tup[0] = 1; 元组增： 123tup1 = (12,34,56)tup2 = (&quot;abc&quot;,xyz)tup3 = tup1 + tup2 元组删： 1del tup 4.4 字典无序的对象集合，使用键值储存。 12info = &#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;print(info[&quot;name&quot;]) 访问可能不存在的键： 123456print(info[&quot;gender&quot;])#报错print(info.get(&quot;gender&quot;))#输出Noneprint(info,get(&quot;gender&quot;,&quot;m&quot;))#没找到默认为m，找到时显示找到的值 字典增： 1info[&quot;id&quot;] = 12 字典删： 12del info[&quot;name&quot;] #删除键值对。直接访问键会报错。info.clear #清空数组，打印：info = &#123;&#125; 字典改： 1info[&quot;name&quot;] = &quot;成龙&quot; 字典查： 12345678910111213141516info.keys() #得到所有的键，列表形式info.values() #得到所有的值info.items() #得到所有的项#遍历for key in info.keys(): print(key)for values in info.values(): print(value)for key,value in info.items(): print(&quot;key=$s,value=%s&quot;%(key,value))mylist = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]#enumerate枚举类型对象for i,x in enumerate(mylist): print(i,x) 4.5 集合与字典相似，是key的集合，但是key不能重复。 set可以用来去重。 小结： 5: 函数12345def printInfo(): print(&quot;---------------------------&quot;) print(&quot; 人生苦短，我用python &quot;) print(&quot;---------------------------&quot;)printInfo() 带参数的函数： 1234def add2Num(a,b): c = a + b print(c)add2Num(11,22) 带返回值的函数： 1234def add2Num(a,b): return a+bresult = add2Num(1,2)print(result) 返回多个值： 123456def divid(a,b): shang = a/b yushu = a%b return shang,yushush,yu = divid(5,2)print(sh,yu) 函数类，局部变量优先于全局变量 在函数中使用全局变量： 123456a = 100def test1(): global a #全局变量标识符 print(a) a = 200print(a) 6: 文件操作6.1 打开关闭12f = open(&quot;test.txt&quot;,&quot;w&quot;) #打开文件，写模式，不存在文件时，在函数目录路径新建这个文件。f.close() #关闭文件 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 6.2 读取字符读取全部行 1234f = open(&quot;test.txt&quot;,&quot;r&quot;)content = f.read(5) #读五个字符，读取后，指针向后移到5的位置content1 = f.readlines() #将文档全部读取出来，按行作为一个元素放在列表里。f.close() 读取一行： 123f = open(&quot;test.txt&quot;,&quot;r&quot;)content1 = f.readline() #读取一行，指针后移f.close() 6.3 os库12import osos.rename(&quot;test.txt&quot;,&quot;abc.txt&quot;) 7: 错误与异常1f = open(&quot;123.txt&quot;,&quot;r&quot;) #如果没有这个文件，就会报错 123456try: print(&quot;---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(&quot;---2---&quot;)except IOError: #文件没找到属于IO异常 pass #捕获异常后的处理 要捕获异常类型，才不会报错 捕获多个异常： 123456try: print(&quot;---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(&quot;---2---&quot;)except (IOError,NameError): pass 获取错误描述： 123456try: print(&quot;---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(&quot;---2---&quot;)except IOError as result: print(result) 捕获所有异常： 123456try: print(&quot;---1---&quot;) f = open(&quot;123.txt&quot;,&quot;r&quot;) print(&quot;---2---&quot;)except Exception as result: print(result) #捕获异常后的处理 try finally: 123456try: f = open(&quot;123.txt&quot;,&quot;r&quot;)except Exception as result: print(result)finally: f.close()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"}]},{"title":"php和js中的JSON操作","slug":"php和js中的JSON操作","date":"2020-07-17T09:45:51.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/17/php和js中的JSON操作/","link":"","permalink":"https://sci.ci/2020/07/17/php%E5%92%8Cjs%E4%B8%AD%E7%9A%84JSON%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1：基本知识JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。这种格式的特点如下： 12&#123;[&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:54&#125;],[&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:56&#125;]&#125; 说明： 以上JSON数据包含了一个对象，最外侧的&#123;&#125;，对象内部包含了两个数组[],每个数组内都有一个结构类似的对象，内侧的&#123;&#125;。 对象和数组是构成JSON的基本要素，数组的出现是为了让结构相同，即键名例如：name、age相同的对象，排列更加整齐，也方便我们用数组的方法提取。 由于前后端数据传递的特点，对象或者数组格式的数据不能直接从php传递到前端js。因此，我们将php中的对象/数组数据，转为字符串格式的JSON数据，然后传递到前端，前端js再将其转为对象或数组格式。反之亦然。 2：php中的json处理php中主要有两个函数处理json数据: json_encode、json_decode 2.1 json_encodejson_encode:将数组、对象转为json格式的字符串。 例如：php中有一个数组，其包含键名和键值。 123456789101112$arr = [ &#x27;appid&#x27; =&gt; &#x27;121434352&#x27;, &#x27;appkey&#x27; =&gt; &#x27;19b8b372c501e1fbedead782d46199a&#x27;, &#x27;callback&#x27; =&gt; &#x27;http://example.com/callback.php&#x27;, &#x27;scope&#x27; =&gt; &#x27;add_t,add_pic_t,del_t&#x27;, &#x27;errorReport&#x27; =&gt; true, &#x27;storageType&#x27; =&gt; &#x27;file&#x27;, &#x27;host&#x27; =&gt; &#x27;localhost&#x27;, &#x27;user&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;root&#x27;, &#x27;database&#x27; =&gt; &#x27;test&#x27;]; 使用将其转为字符串 12$str = json_encode($arr);echo $str; 输出： 1&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125; 可以看到，数组被转换成了一个对象样式的JSON数据。 如果一个数组，索引为数字。 例如： 12$arr = array(&#x27;a&#x27; , &#x27;b&#x27;, &#x27;c&#x27;);json_encode($arr); 输出： 1[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 可看到其输出仍为数组格式。 如果希望将键名键值格式的数组转换后格式仍保留。可以对其排序，排序后，会丢失键名。索引统一变为数字。 123$arr = array(&#x27;1&#x27; =&gt; &#x27;a&#x27; , &#x27;2&#x27; =&gt; &#x27;b&#x27;, &#x27;3&#x27; =&gt; &#x27;c&#x27;);sort($arr);json_encode($arr); 输出： 1[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] 2.2 json_decodejson_decode:将字符串转为对象/数组格式。 123$str = &#x27;&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125;&#x27;;$obj = json_decode($str);print_r($obj); 由于echo只能输出字符串格式数据，print_r和var_dump可以将数组和对象用特定的格式输出。所以这里使用了print_r。 输出： 12345678910111213stdClass Object( [appid] =&gt; 121434352 [appkey] =&gt; 19b8b372c501e1fbedead782d46199a [callback] =&gt; http://example.com/callback.php [scope] =&gt; add_t,add_pic_t,del_t [errorReport] =&gt; 1 [storageType] =&gt; file [host] =&gt; localhost [user] =&gt; root [password] =&gt; root [database] =&gt; test) 可以看到，json数据被转换成了一个对象。 也可以修改json_decode参数，将json转为数组 123$str = &#x27;&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125;&#x27;;$arr = json_decode($str, true);var_dump($arr); 这里，再json_decode参数里添加true，表示将json转为数组。并使用var_dump来输出数组。 var_dump输出结果： 12345678910111213141516171819202122array(10) &#123; [&quot;appid&quot;]=&gt; string(9) &quot;121434352&quot; [&quot;appkey&quot;]=&gt; string(31) &quot;19b8b372c501e1fbedead782d46199a&quot; [&quot;callback&quot;]=&gt; string(31) &quot;http://example.com/callback.php&quot; [&quot;scope&quot;]=&gt; string(21) &quot;add_t,add_pic_t,del_t&quot; [&quot;errorReport&quot;]=&gt; bool(true) [&quot;storageType&quot;]=&gt; string(4) &quot;file&quot; [&quot;host&quot;]=&gt; string(9) &quot;localhost&quot; [&quot;user&quot;]=&gt; string(4) &quot;root&quot; [&quot;password&quot;]=&gt; string(4) &quot;root&quot; [&quot;database&quot;]=&gt; string(4) &quot;test&quot;&#125; 对比print_r输出结果： 1234567891011121314Array( [appid] =&gt; 121434352 [appkey] =&gt; 19b8b372c501e1fbedead782d46199a [callback] =&gt; http://example.com/callback.php [scope] =&gt; add_t,add_pic_t,del_t [errorReport] =&gt; 1 [storageType] =&gt; file [host] =&gt; localhost [user] =&gt; root [password] =&gt; root [database] =&gt; test) 2.3 对象数组操作2.3.1 对象操作php中，根据对象键名获取键值的方式是-&gt; 比如我们转换了以下对象， 12$str = &#x27;&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125;&#x27;;$obj = json_decode($str); 现在获取appkey 12$appkey = $obj-&gt;appkey;echo $appkey; 输出： 119b8b372c501e1fbedead782d46199a 2.3.2 数组操作转换的数组： 12$str = &#x27;&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125;&#x27;;$arr = json_decode($str, true); 操作数组，获取appkey： 12$appkey = $arr[&#x27;appkey&#x27;];echo $appkey 输出： 119b8b372c501e1fbedead782d46199a 3：JS中的json处理与php中处理方式相对应，存在JSON.stringify和JSON.parse两个函数 3.1 JSON.stringify对象、数组转为字符串格式。 对象字符串化： 1234567var Person=&#123;&#125;; //等同于var Person =new Object();var Person=&#123;name:&quot;Jason&quot;,age:21&#125;var str=JSON.stringify(Person)alert(str); 输出： 1&#123;&quot;name&quot;:&quot;Jason&quot;,&quot;age&quot;:21&#125; 数组字符串化： 12345var mycars=new Array();mycars[0]=&quot;Saab&quot;;mycars[1]=&quot;Volvo&quot;;mycars[2]=&quot;BMW&quot;;alert(JSON.stringify(mycars)); 输出： 1[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;] 3.2 JSON.parse字符串转数组、对象。 转对象： 123var str = &#x27;&#123;&quot;appid&quot;:&quot;121434352&quot;,&quot;appkey&quot;:&quot;19b8b372c501e1fbedead782d46199a&quot;,&quot;callback&quot;:&quot;http:\\/\\/example.com\\/callback.php&quot;,&quot;scope&quot;:&quot;add_t,add_pic_t,del_t&quot;,&quot;errorReport&quot;:true,&quot;storageType&quot;:&quot;file&quot;,&quot;host&quot;:&quot;localhost&quot;,&quot;user&quot;:&quot;root&quot;,&quot;password&quot;:&quot;root&quot;,&quot;database&quot;:&quot;test&quot;&#125;&#x27;;var obj= JSON.parse(str);alert(obj); 输出： 1[object Object] 以上说明输出的数据格式为对象。 转数组： 123var str = &#x27;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#x27;;var arr= JSON.parse(str);alert(arr); 输出： 1a,b,c 3.3 对象数组操作3.3.1 对象操作创建对象： 12345var Person=&#123;&#125;; //等同于var Person =new Object();var Person=&#123;name:&quot;Jason&quot;,age:21&#125; 获取name对应的键值： 12var name = Person.name;alert(name); 或者： 12var name = Person[&#x27;name&#x27;];alert(name); 3.3.2 数组操作12var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];alert(arr[0]);","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://sci.ci/tags/JSON/"}]},{"title":"git使用记录","slug":"git使用记录","date":"2020-07-11T23:03:53.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/12/git使用记录/","link":"","permalink":"https://sci.ci/2020/07/12/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1：git指令1git clone https://github.com/user/repo/program.git 将远程仓库克隆到git打开的目录。 1git switch -c dev 新建并切换至dev分支。 1git switch dev 切换到dev分支 1git add . 将所有变更提交至缓冲区 1git commit -m &quot;message&quot; 为缓冲区的变更添加更新的提示 1git push origin dev 将本地缓冲区的变更更新到远程仓库dev分支。 1git merge dev 将dev分支的内容更新至当前所在分支。 1git pull origin dev 拉去远程仓库dev分支的内容到本地仓库 2：.gitignore在更新远程仓库时，可以指定部分本地仓库的文件/文件夹不推送至远程仓库。 在仓库根目录下新建.gitignore文件，直接编辑内容即可 1&#x2F;config&#x2F;* 忽略根目录下的/config文件夹下的所有文件。 1config&#x2F;* 忽略任意路径下的/config文件夹下的所有文件。 1&#x2F;config&#x2F;*!README.md 忽略根目录下的/config文件夹下除README.md以外的所有文件 1&#x2F;config&#x2F;README.md 忽略根目录下的/config文件夹下的README.md文件 3：版本控制release版本，有助于保存阶段性成果。","categories":[{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://sci.ci/tags/Git/"}]},{"title":"使用JsDelivr给静态资源加速","slug":"使用JsDelivr给静态资源加速","date":"2020-07-11T20:37:07.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/07/11/使用JsDelivr给静态资源加速/","link":"","permalink":"https://sci.ci/2020/07/11/%E4%BD%BF%E7%94%A8JsDelivr%E7%BB%99%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E9%80%9F/","excerpt":"","text":"github仓库里的js、css静态资源是无法被直接放在网页的静态资源url里的，因此，需要借助第三方工具来引用。 这里使用JsDelivr。 说明打开jsDeliver官网，可以看到使用方式： 12345&#x2F;&#x2F; load any GitHub release or commit&#x2F;&#x2F; note: we recommend using npm for projects that support ithttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;user&#x2F;repo@version&#x2F;file user：github用户名 repo：仓库名 version：(Tag)版本名 file：文件路径 步骤第一步：将静态资源push到仓库 第二步：release一个版本 第三步：根据上面的cdn方式，获取静态资源cdn资源。 参考资料《使用Github托管js和css文件》","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JsDelivr","slug":"JsDelivr","permalink":"https://sci.ci/tags/JsDelivr/"}]},{"title":"Oneindex+YAAW增加后台离线上传","slug":"Oneindex-YAAW增加后台离线上传","date":"2020-06-25T09:07:03.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/25/Oneindex-YAAW增加后台离线上传/","link":"","permalink":"https://sci.ci/2020/06/25/Oneindex-YAAW%E5%A2%9E%E5%8A%A0%E5%90%8E%E5%8F%B0%E7%A6%BB%E7%BA%BF%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"一：简介Yaaw是个开源的aria2的WebUI，通过这个UI可以使用aria2的rpc功能，向aria2发送下载某文件的指令。我将yaaw嵌入到了Oneindex后台，同时在前台也部署了yaaw供游客使用。 项目地址：https://github.com/xieqifei/OneindexN Demo：https://pan.sci.ci 后台预览： 二：部署网站网站环境尽量使用nginx。后面会用nginx做反代，可以避免修改yaaw的rpc参数。 在github上将网站下载下来。可以直接下载为zip压缩包 将文件解压到网站根目录。 进入网站首页。配置网站。 三：修改Nginx配置添加 12345678location &#x2F;jsonrpc &#123; proxy_pass http:&#x2F;&#x2F;localhost:6800&#x2F;jsonrpc; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $host; &#125; 这样RPC可以配置为http://yoursite/jsonrpc。网站后台默认的RPC就是http://yoursite/jsonrpc 关闭aria2远程RPC 仅本地也就是443转发的请求能到达6800。 1vim /root/.aria2c/aria2.conf 修改aria2配置内容 12345678# 启用RPC, 默认:falseenable-rpc&#x3D;true# 接受所有远程请求, 默认:falserpc-allow-origin-all&#x3D;false# 允许外部访问, 默认:falserpc-listen-all&#x3D;false# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port&#x3D;6800 如果不配置nginx，需要自己修改RPC设置。并且aria2配置需要开放远程RPC 四：参考资料《github YAAW项目》 《Issue：一旦使用HTTPS协议就无法连接》 《Nginx 反向代理 Aria2 JSONRPC》","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"YAAW","slug":"YAAW","permalink":"https://sci.ci/tags/YAAW/"},{"name":"Oneindex","slug":"Oneindex","permalink":"https://sci.ci/tags/Oneindex/"}]},{"title":"部署Aria2+Rclone实现离线下载文件到Onedrive","slug":"部署Aria2-Rclone实现离线下载文件到Onedrive","date":"2020-06-25T07:55:43.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/25/部署Aria2-Rclone实现离线下载文件到Onedrive/","link":"","permalink":"https://sci.ci/2020/06/25/%E9%83%A8%E7%BD%B2Aria2-Rclone%E5%AE%9E%E7%8E%B0%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%88%B0Onedrive/","excerpt":"","text":"一：前言Aria2是一款多线程下载的应用，可以充分利用网络带宽，实现满速下载。Rclone是个网盘管理工具，可以绑定Onedrive实现将网盘挂载到本地。利用aria2和Rclone，可以在服务器上通过指令，直接将远程文件下载到本地，并自动保存到Onedrive。 二：安装Aria2推荐使用一键脚本： 1wget -N git.io/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; ./aria2.sh 此脚本会自动下载关联Rclone的脚本，即aria2文件下载结束自动文件上传到Onedrive。 三：安装rclone1curl https://rclone.org/install.sh | sudo bash 安装完毕，配置rclone 1rclone config 配置方式参考《Rclone在win上挂在Onedrive》，但是不完全相同。 如果你的系统有UI，那么可以和在win上一样配置rclone。如果是纯指令界面，则按下面操作配置。 你需要现在windows上部署rclone，以获取onedrive授权的token。token在C:\\Users\\你的用户名\\.config\\rclone中 打开rclone.conf将token从&#123;&quot;access_token&quot;:开始到&#125;结束的内容复制下来。 在rclone config出现 1234567Remote config Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yes (default) n) No y/n&gt; 时输入 n，不自动配置。 在接下来出现的 1result&gt; 中，输入你拷贝的token。 剩下的和windows配置相同。 然后修改aria2配置，以配置将下载文件自动上传到onedrive 四：配置自动上传脚本Aria2 一键安装管理脚本 增强版 整合了 Aria2 完美配置 ，安装后会附带一些列增强功能脚本，Rclone 自动上传脚本就是其中之一。由于默认不启用，所以需要手动启用。 输入vim /root/.aria2c/autoupload.sh打开自动上传脚本进行编辑，脚本中有中文注释，按照自己的实际情况进行修改，一般只需要修改下面2个部分。 1234# Rclone 配置时填写的网盘名(name)DRIVE_NAME&#x3D;&#39;Onedrive&#39;# 网盘目录。即上传目标路径，留空为网盘根目录，末尾不要有斜杠。DRIVE_PATH&#x3D;&#39;&#x2F;DRIVEX&#x2F;Download&#39; 输入vim /root/.aria2c/aria2.conf打开 Aria2 配置文件进行修改。或使用Aria2 一键安装管理脚本 增强版中的手动修改选项打开配置文件进行修改。找到“下载完成后执行的命令”，把delete.aria2.sh替换为autoupload.sh。 12# 下载完成后执行的命令on-download-complete&#x3D;&#x2F;root&#x2F;.aria2c&#x2F;autoupload.sh 重启 Aria2 1service aria2 restart 五：参考资料《Aria2 + Rclone 实现 OneDrive、Google Drive 等网盘离线下载》","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"Rclone","slug":"Rclone","permalink":"https://sci.ci/tags/Rclone/"},{"name":"Aria2","slug":"Aria2","permalink":"https://sci.ci/tags/Aria2/"}]},{"title":"Rclone在win上挂在Onedrive","slug":"Rclone在win上挂在Onedrive","date":"2020-06-22T18:07:26.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/22/Rclone在win上挂在Onedrive/","link":"","permalink":"https://sci.ci/2020/06/22/Rclone%E5%9C%A8win%E4%B8%8A%E6%8C%82%E5%9C%A8Onedrive/","excerpt":"","text":"一：Rclone下载首先下载适用于 Windows 的 rclone 👇 官网下载：https://rclone.org/downloads/GitHub下载：https://github.com/ncw/rclone 在rclone官网中，Windows 平台下选择下载 AMD64 - 64 Bit 或者在github下载。 下载后解压到一个英文路径中。 另外在Windows平台使用rclone还需要另一个依赖工具winfsp，下载地址：http://www.secfs.net/winfsp/download/ ，下载后一路安装即可。 二： 配置环境变量 在电脑桌面右键点击“此电脑”的“属性”选项 选择“高级系统设置”选项 在系统变量中找到path，新建添加刚才解压后的路径 检查环境变量是否配置成功。 按win+X，然后按A 打开 powershell ，当然也可以去打开 cmd ，输入rclone --version，如果出现下面的输出则安装成功，否则检查上面步骤的环境变量是否配置正确。 三：配置Rclone在终端中依次输入以下命令行，请根据我下的步骤进操作。 下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158PS C:\\WINDOWS\\system32&gt; rclone config // 第一步在终端输入 rclone config2020/06/22 19:36:22 NOTICE: Config file &quot;C:\\\\Users\\\\12412\\\\.config\\\\rclone\\\\rclone.conf&quot; not found - using defaultsNo remotes found - make a new onen) New remotes) Set configuration passwordq) Quit confign/s/q&gt; n //第二步输入n创建新的配置， name&gt; Onedrive_local //第三步 输入一个英文名称 ，中间也不要有空格Type of storage to configure.Enter a string value. Press Enter for the default (&quot;&quot;).Choose a number from below, or type in your own value 1 / 1Fichier \\ &quot;fichier&quot; 2 / Alias for an existing remote \\ &quot;alias&quot; 3 / Amazon Drive \\ &quot;amazon cloud drive&quot; 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc) \\ &quot;s3&quot; 5 / Backblaze B2 \\ &quot;b2&quot; 6 / Box \\ &quot;box&quot; 7 / Cache a remote \\ &quot;cache&quot; 8 / Citrix Sharefile \\ &quot;sharefile&quot; 9 / Dropbox \\ &quot;dropbox&quot;10 / Encrypt/Decrypt a remote \\ &quot;crypt&quot;11 / FTP Connection \\ &quot;ftp&quot;12 / Google Cloud Storage (this is not Google Drive) \\ &quot;google cloud storage&quot;13 / Google Drive \\ &quot;drive&quot;14 / Google Photos \\ &quot;google photos&quot;15 / Hubic \\ &quot;hubic&quot;16 / In memory object storage system. \\ &quot;memory&quot;17 / Jottacloud \\ &quot;jottacloud&quot;18 / Koofr \\ &quot;koofr&quot;19 / Local Disk \\ &quot;local&quot;20 / Mail.ru Cloud \\ &quot;mailru&quot;21 / Mega \\ &quot;mega&quot;22 / Microsoft Azure Blob Storage \\ &quot;azureblob&quot;23 / Microsoft OneDrive \\ &quot;onedrive&quot;24 / OpenDrive \\ &quot;opendrive&quot;25 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ &quot;swift&quot;26 / Pcloud \\ &quot;pcloud&quot;27 / Put.io \\ &quot;putio&quot;28 / QingCloud Object Storage \\ &quot;qingstor&quot;29 / SSH/SFTP Connection \\ &quot;sftp&quot;30 / Sugarsync \\ &quot;sugarsync&quot;31 / Tardigrade Decentralized Cloud Storage \\ &quot;tardigrade&quot;32 / Transparently chunk/split large files \\ &quot;chunker&quot;33 / Union merges the contents of several upstream fs \\ &quot;union&quot;34 / Webdav \\ &quot;webdav&quot;35 / Yandex Disk \\ &quot;yandex&quot;36 / http Connection \\ &quot;http&quot;37 / premiumize.me \\ &quot;premiumizeme&quot;38 / seafile \\ &quot;seafile&quot;Storage&gt; 23 //第四步 输入要配置的网盘类型 因为我们要配置Microsoft OneDrive 因此输入23** See help for onedrive backend at: https://rclone.org/onedrive/ **Microsoft App Client IdLeave blank normally.Enter a string value. Press Enter for the default (&quot;&quot;).client_id&gt; //第五步 直接回车Microsoft App Client SecretLeave blank normally.Enter a string value. Press Enter for the default (&quot;&quot;).client_secret&gt; //第六步 直接回车 Edit advanced config? (y/n)y) Yesn) No (default)y/n&gt; n //第七步 输入n 不进行高级配置 Remote configUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yes (default)n) Noy/n&gt; y //第八步 输入y 使用自动配置授权If your browser doesn&#x27;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=DWKiZ1cLZoWl9buxJbPXgwLog in and authorize rclone for accessWaiting for code...Got codeChoose a number from below, or type in an existing value 1 / OneDrive Personal or Business \\ &quot;onedrive&quot; 2 / Root Sharepoint site \\ &quot;sharepoint&quot; 3 / Type in driveID \\ &quot;driveid&quot; 4 / Type in SiteID \\ &quot;siteid&quot; 5 / Search a Sharepoint site \\ &quot;search&quot;Your choice&gt; 1 //第九步 输入1 因为现在我配置的是 OneDrive Personal or Business 类型的网盘Found 1 drives, please select the one you want to use:0: (personal) id=58719e3298535c9Chose drive to use:&gt; 0 //第十步 输入0Found drive &#x27;root&#x27; of type &#x27;personal&#x27;, URL: https://onedrive.live.com/?cid=058719e3298535c9Is that okay?y) Yes (default)n) No //第十一步 直接回车y/n&gt;--------------------[Onedrive_local]type = onedrivetoken = &#123;&quot;access_token&quot;:&quot;BAAUO9chh8cJscQLmU+LSWpbnr0vmwwAAZ6th5X8qdv3jqko0KCKeFVHdJigXdmpkGf3aO/W9HQahNAmDTxEVF2TnPtPNCw7M/me6FRz4mD9+x/jfJIb8Qewi8NpYMfYXdmPyUUVcPp1G+bwKOIFfJlNa6Can21gaGhTKgdEaz27GwetIvwjy7Qo/eDh/jarwoHEKljM8fN3UF1xz/RS0Ir+DC6CrvNIP3MUpbBF31/qUWJekWn3XqdT1j6m9bBfJ9Xk8heaY1/MT+1SA6fs6IPV5mO5m6dtjfsr1wO3xLGuaEutBPlNT9t219R55MZibwt746mw+VRTMCLsMrFZqVGK6IHzXyG3t+5NOrdP9yelb0AVQDZgAACJVvxd1cmt0LOAKEWlmYeQi3Eo6NKs9l5Abb4AsL2V02tbQt3AheMGLOxpOfyWOUUNaqvFAdSWRGQU8JLgFOA0YWy+UtYHSBG8SIy40jFI5czeqFoCzXguNijP2eiE+JdJREz9fO0q947/QK0K4MxVBqQxmlD1RDujCtnIDsT5r1ICG2AN40wSWqGvanKyctRNPdEm0BjmTrmXh0qTinmJ+BBVe70AU3ZigEzfMULxP+i+vwI2rA7VbiAuXnDUE75t49RGBiCMS+p00x0smGI685pmbPYQoOcMuVLHVdIxSDCO+YLSgpaHaBrruIvFbhto0OczwvYKn8XXEIp0CM6XEy55UYTuLkJFRDWX9VB/mSHarvexYqtEi4EYK2nABm4KrngexH0IdyhdwDKx7gNnLcMP9YYXG0cybppINxx67jFxjQM8/TWQPAz4cADt/FfPPVvuVABOZdhKmpuScj6qOhWsCfh6KH385UiM2Z+Rn2t9hZaXt3ZRmu+W5XAx9+E1SnlewdTiH5/VwB8QhCuRvS89hK/51BeMz4cJ5R9dLEqjGDxZ0HHay52DDhQYta/yG0VN2pkWTg0+T7rVdXbgC607y47sWmqP540tigNZPc0AgrWK3TXFOAJAEAoV9Xg+QUhJKYQNnrtFWI9nKbSFVHEeg8vvl5efZviF2szVI4wProgIHpUydqfnMlR3vRZlei/rmGUC9IICjdNTKPWSGmilJdbdxHMUc/MDyfYhxJA69cwI=&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;refresh_token&quot;:&quot;MCeVIl4QGaJb!yGdTF6FLD!8N7hR4D8Z1bV4mpta08v64kR!MLcolxhea*NOv24M5V!uqHzBvi5dSW9wVHXGqALSe9kML5HKxV12XougeYafX2dcdyxvZ*cYEa6D0l6hIzovUwFpVjv3lqiP66jpzY4KxYMtZqQHf5PN!VGJf52xDKcsIUseoKD98z7olU3E2kyaZqJW8j6o5dBTV!Lmo5DVc31VpGrfeUnwhOcZkO7xN7IUEy8Vs9YXKQ0C4cin4qpyDSQ3pLpwy09ZpVE2bKOt4XQP7JLWQa6iGQ*r8zgewRo7ULYoEpRXYsqSBdwX6pJEQnRzCDcJimHxXBEV59rE*Ykwc9SijTkBN4haK6br9y2YVQ2UKegfQiErCHY33kzmSMAPJUwiooUNc6GytUz5O6ZxsBMghhb6B6NiSBCs!U5xRon1y*zzOsh9EArHk4y2rihu7BkkC13bJqxeMvhw$&quot;,&quot;expiry&quot;:&quot;2020-06-22T20:38:09.8687266+08:00&quot;&#125;drive_id = 58719e3298825c9drive_type = personal--------------------y) Yes this is OK (default)e) Edit this remoted) Delete this remotey/e/d&gt; //第十二步 回车Current remotes:Name Type==== ====Onedrive_local onedrive //显示你的设置则成功！e) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; q //第十三步 输入q结束配置 四：挂载Onedrive到本地 自行下载安装git 此时请使用 git bash 的终端执行以下命令，因为我使用cmd 和 powershell 都出现关闭终端后挂载程序退出、本地挂载的OneDrive退出的现象。 如果你的windows没有安装git ， 请[自行安装](https://www.baidu.com/s?wd=windows 安装git&amp;ie=utf-8)。若你使用 cmd 的话 ，cmd 是不能退出的，要保持 cmd 不退出本地硬盘才一直挂载着。 桌面新建txt文本文件。编辑内容为： 1start &quot;&quot; &quot;%ProgramFiles%\\Git\\git-bash.exe&quot; -c &quot;rclone mount Onedrive_local:/ Q: --cache-dir C:\\Users\\97532\\Rclone --vfs-cache-mode writes &amp;&quot; Onedrive_local 替换为你自己前面设置的名称 。 Q: 替换为你想要挂载后硬盘的盘符名称即可，记得不要和本地的C盘、D盘等重复。 C:\\Users\\97532\\Rclone 为本地缓存目录，可自行设置 。 上述代码，使用git bash程序执行rclone挂载磁盘的指令。cmd无法识别&amp;，也就是退出程序继续挂载指令。 重命名txt文件为rclone_startup.bat 双击运行 出现：The service rclone has been started 或者磁盘列表出现Onedrive，则说明挂载成功。 设置开机启动 由于git程序在重启后会停止，需要将rclone_startup.bat移动到开机启动文件里，每次开机让磁盘自动挂载。 将rclone_startup.bat放在C:\\Users\\用户名\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 中 237.png) 现在试试重启电脑。。重启后需要等待十几秒，才会运行git bash程序挂载Onedrive。 git bash运行后会有一闪而过的黑色窗口。此时磁盘应该挂载成功了。 删掉上面的方法，是由于步骤太过冗杂，需要安装git bash，而且开机启动时存在一闪而过的黑色窗口，运行后的挂载盘也存在问题。 挂载操作在退出cmd后就自动结束了，所以我们需要让它后台运行。rclone虽然提供了--daemon参数来实行后台运行，但是该参数并不适合于windows环境中。会有如下提示： 12λ rclone mount GDrive:&#x2F; x: --cache-dir F:\\Temp --vfs-cache-mode writes --daemon2018&#x2F;05&#x2F;01 09:54:19 background mode not supported on windows platform 所以，我们需要另外想个办法让rclone能够后端运行以及开机自动挂载。 新建一个文本文件。 填入以下内容，请注意修改倒数第二行的WS.Run中相关命令为你上步成功执行的命令，然后将该文件名改为rclone.vbs （后缀名为.vbs即可） 12345678910111213141516Option ExplicitDim WMIService, Process, Processes, Flag, WSSet WMIService = GetObject(&quot;winmgmts:&#123;impersonationlevel=impersonate&#125;!\\\\.\\root\\cimv2&quot;)Set Processes = WMIService.ExecQuery(&quot;select * from win32_process&quot;)Flag = truefor each Process in Processes if strcomp(Process.name, &quot;rclone.exe&quot;) = 0 then Flag = false exit for end ifnextSet WMIService = nothingif Flag then Set WS = Wscript.CreateObject(&quot;Wscript.Shell&quot;) WS.Run &quot;rclone mount Onedrive_local:/ Q: --cache-dir C:\\Users\\97532\\Rclone --vfs-cache-mode writes&quot;, 0end if Onedrive_local 替换为你自己前面设置的名称 。 Q: 替换为你想要挂载后硬盘的盘符名称即可，记得不要和本地的C盘、D盘等重复。 C:\\Users\\97532\\Rclone 为本地缓存目录，可自行设置 。 关于vfs-cache-mode项设置，还是建议看下官方的说明根据自己的需求和网络情况来进行选择 https://rclone.org/commands/rclone_mount/#file-caching 。这里只做简单说明： off： 本地不做任何缓存，所有文件直接从云端获取并写入。建议网速特别好时（复制粘贴大文件时建议至少100M管以上速度）使用。 minimal：（和off类似，但是已经打开的文件会被缓存到本地。个人推荐，小文件基本够用，但是如果你的网络情况（梯子）不是特别好的话，用writes也行 writes：（如果文件属性为只读则只从云端获取，不然先缓存在本地进行读写操作，随后被同步。个人推荐使用，但是在直接从本地复制文件到GDrive时还是看网络情况 full：（所有的读写操作都会缓存到磁盘中。然后才会同步。不是很推荐。会导致所有文件均被缓存到本地。直到达到你缓存总额（–cache-total-chunk-size，默认大小10G）。但是你网速特别差时也可以使用。 如果你需要中断这个挂载操作，请直接在任务管理器中kill掉rclone.exe进程即可。 开机自启 将这个文件rclone.vbs复制（或者剪贴）到开机项中C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp（Windows 10）即可实现开机自动挂载~ 五：参考资料《Windows平台下使用 Rclone 挂载 OneDrive 为本地硬盘》 《CMD打开Git Bash》 《Windows-如何从DOS命令行启动Git Bash？》 《使用rclone在Windows下挂载Google个人/团队云盘》","categories":[{"name":"Windows","slug":"Windows","permalink":"https://sci.ci/categories/Windows/"}],"tags":[{"name":"Rclone","slug":"Rclone","permalink":"https://sci.ci/tags/Rclone/"}]},{"title":"Oneindex自建不限速网盘","slug":"Oneindex自建不限速网盘","date":"2020-06-22T09:46:34.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/22/Oneindex自建不限速网盘/","link":"","permalink":"https://sci.ci/2020/06/22/Oneindex%E8%87%AA%E5%BB%BA%E4%B8%8D%E9%99%90%E9%80%9F%E7%BD%91%E7%9B%98/","excerpt":"","text":"不占用服务器空间，不走服务器流量， 直接列出 OneDrive 目录，文件直链下载。 一：注册申请000webhost免费主机进入 https://www.000webhost.com/ 注册后，在我的网站里创建新网站。 创建成功后，打开网站后台。 点击File Manager，或者直接输入网址 https://files.000webhost.com 连接你的网站ftp 输入你的网站名称和密码 /public_html就是网站的根目录。将网页的index应放在此目录下 二：下载和上传网页下载程序源码：https://wwa.lanzous.com/ikFHMdxgkeb 确保public_html目录里没有任何文件。 在网站文件管理页面，点击上传文件(upload files)的图标。将压缩包上传到public_html。 选择文件右键选择解压(extract)。将解压后的所有文件即index.php所在的文件目录下所有的文件移动到public_html 最终结果应如图所示。 三：绑定自己的域名webhost给的免费域名是webname.000webhostapp.com，需要自行设置cname解析。解析步骤就不说了。不会的可自行百度。 cname添加后，还需要在webhost后台设置白名单才能生效。 在000webhost网站管理后台中，点击Website Settings-&gt;General。 在Website Name下面有一段英文，you can change the name of your website here 。点击here。进入修改域名界面 添加你cname解析的域名 四：安装配置oneindex打开你的网盘网页，比如我的 http://pan.sci.ci 按照提示配置。 其中应用密钥和id，需要你点击网站给的链接获取。密钥获取结束后，点击密钥界面的回退按钮，在回退的网页里就能找到应用id。 五：oneindex其他操作onedrive文件管理：https://onedrive.live.com 5.1 计划任务 [可选]推荐配置，非必需。后台定时刷新缓存，可增加前台访问的速度。 12345# 每小时刷新一次token0 * * * * &#x2F;具体路径&#x2F;php &#x2F;程序具体路径&#x2F;one.php token:refresh# 每十分钟后台刷新一遍缓存*&#x2F;10 * * * * &#x2F;具体路径&#x2F;php &#x2F;程序具体路径&#x2F;one.php cache:refresh 5.2 Docker 安装运行 请参考TimeBye/oneindex 5.3 特殊文件实现功能 README.md、HEAD.md 、 .password特殊文件使用 可以参考https://github.com/donwa/oneindex/tree/files 在文件夹底部添加说明: 在 OneDrive 的文件夹中添加README.md文件，使用 Markdown 语法。 在文件夹头部添加说明: 在 OneDrive 的文件夹中添加HEAD.md 文件，使用 Markdown 语法。 加密文件夹: 在 OneDrive 的文件夹中添加.password文件，填入密码，密码不能为空。 直接输出网页: 在 OneDrive 的文件夹中添加index.html 文件，程序会直接输出网页而不列目录。配合 文件展示设置-直接输出 效果更佳。 5.4 命令行功能 仅能在PHP CLI模式下运行 清除缓存: 1php one.php cache:clear 刷新缓存: 1php one.php cache:refresh 刷新令牌: 1php one.php token:refresh 上传文件: 1php one.php upload:file 本地文件 [OneDrive文件] 上传文件夹: 1php one.php upload:folder 本地文件夹 [OneDrive文件夹] 例如： 1234567891011&#x2F;&#x2F;上传demo.zip 到OneDrive 根目录 php one.php upload:file demo.zip &#x2F;&#x2F;上传demo.zip 到OneDrive &#x2F;test&#x2F;目录 php one.php upload:file demo.zip &#x2F;test&#x2F; &#x2F;&#x2F;上传demo.zip 到OneDrive &#x2F;test&#x2F;目录并将其命名为 d.zip php one.php upload:file demo.zip &#x2F;test&#x2F;d.zip &#x2F;&#x2F;上传up&#x2F; 到OneDrive &#x2F;test&#x2F; 目录 php one.php upload:file up&#x2F; &#x2F;test&#x2F;","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Oneindex","slug":"Oneindex","permalink":"https://sci.ci/tags/Oneindex/"}]},{"title":"Volantis主题ReadMore自动截取文章内容","slug":"Valantis-ReadMore自动截取文章内容","date":"2020-06-18T13:56:09.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/18/Valantis-ReadMore自动截取文章内容/","link":"","permalink":"https://sci.ci/2020/06/18/Valantis-ReadMore%E8%87%AA%E5%8A%A8%E6%88%AA%E5%8F%96%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9/","excerpt":"","text":"1：在主题配置文件里添加键值对添加键值对的目的是，控制截取长度和自动截取功能是否开启。在你的博客目录\\themes\\volantis\\_config.yml下添加 123456# Excerpt ## Auto creat excerpt with not &lt;!--more--&gt;## Enable will truncate auto_excerpt.lines rows in post head to replace excerpt.auto_excerpt: enable: true lines: 5 2：修改文章代码修改\\themes\\volantis\\layout\\_partial文件内容为： 1234567891011121314151617181920212223242526272829303132333435363738&lt;article class&#x3D;&quot;post white-box &lt;%- theme.style.body.effect.join(&#39; &#39;) %&gt; reveal &lt;%&#x3D; (post.title) ? &quot;&quot; : &quot;no-title&quot; %&gt;&quot;&gt; &lt;%- partial(&#39;meta&#39;,&#123;post:post, position:&#39;header&#39;&#125;) %&gt; &lt;section class&#x3D;&quot;article typo&quot;&gt; &lt;div class&#x3D;&quot;article-entry&quot; itemprop&#x3D;&quot;articleBody&quot;&gt; &lt;% var show_all_content &#x3D; true %&gt; &lt;% if (post.excerpt) &#123; %&gt; &lt;% show_all_content &#x3D; false %&gt; &lt;%- post.excerpt %&gt; &lt;% &#125; else if (post.summary) &#123; %&gt; &lt;% show_all_content &#x3D; false %&gt; &lt;p&gt;&lt;%- post.summary %&gt;&lt;&#x2F;p&gt; &lt;% &#125; else if (theme.auto_excerpt.enable) &#123; %&gt; &lt;% var br_position &#x3D; 0 %&gt; &lt;% for (var br_count &#x3D; 0; br_count &lt; theme.auto_excerpt.lines; br_count++) &#123; %&gt; &lt;% br_position &#x3D; post.content.indexOf(&#39;\\n&#39;,br_position + 1) %&gt; &lt;% if(br_position &lt; 0) &#123; break &#125; %&gt; &lt;% &#125; %&gt; &lt;% if(br_position &gt; 0) &#123; %&gt; &lt;% show_all_content &#x3D; false %&gt; &lt;p&gt;&lt;%- post.content.substring(0, br_position + 1) %&gt;&lt;p&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;% if (show_all_content) &#123; %&gt; &lt;%- post.content %&gt; &lt;% &#125; %&gt; &lt;&#x2F;div&gt; &lt;% if (theme.layout.on_list.readmore) &#123; %&gt; &lt;% if ((post.readmore !&#x3D; false) &amp;&amp; (show_all_content !&#x3D; true)) &#123; %&gt; &lt;div class&#x3D;&quot;button readmore&quot;&gt; &lt;a href&#x3D;&quot;&lt;%- url_for(post.link || post.path) %&gt;&quot;&gt; &lt;%- theme.layout.on_list.readmore %&gt; &lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; &lt;&#x2F;section&gt;&lt;&#x2F;article&gt; 上面的代码逻辑，是，如果有more标签，则使用more标签前的文字作为摘要，非则使用md文章scaffolds里的summary内容作为摘要，主题原来用的scaffolds是description。如果需要用description，可以自行替换上面的代码。 在scaffolds\\post.md里可以修改新建md文件生成的scaffold。 重要！！这种方法是直接提取的文章前5行。如果提取到的内容里，包含代码块的一部分，那么由于渲染问题布局将会出现问题。建议如果你的文章前面里有代码，自行在summary里写摘要，或者more标签前写摘要。 3：参考文献《Hexo 自动给博文添加 ReadMore》","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Volantis","slug":"Volantis","permalink":"https://sci.ci/tags/Volantis/"}]},{"title":"TensorFlow学习笔记","slug":"TensorFlow学习笔记","date":"2020-06-17T18:35:46.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/17/TensorFlow学习笔记/","link":"","permalink":"https://sci.ci/2020/06/17/TensorFlow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"P1：tensorflow安装1pip install tensorflow P2：Hello World——衣服分类这个例子训练了一个神经网络模型，用于分类衣服图片，比如tshirt和运动鞋。 需要用到tf.keras，它是个用于建立和训练模型的高层次的API 1234567# TensorFlow and tf.kerasimport tensorflow as tffrom tensorflow import keras# Helper librariesimport numpy as npimport matplotlib.pyplot as pltprint(tf.__version__) 2.2.0 导入Fashion MNIST数据集 12fashion_mnist = keras.datasets.fashion_mnist(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data() 导入数据集，返回Numpy数组： train_images和train_labels 数组是训练集。 test_images和 test_labels 数组是测试集。 这些图像是28x28的Numpy数组。可以理解为28x28的像素点，这些像素点在屏幕上显示出来表现为图像。每个像素点的值在0到255之间，表示颜色的深浅。如果你了解颜色的RGB值，那你就明白，所有的颜色都是由不同深浅程度的三种基本色构成，比如白色的RGB为(255.255.255)。标签labels是一个整数数组，范围从0到9。表示10个不同的衣服种类Class。 Label Class 0 T-shirt/top 1 Trouser 2 Pullover 3 Dress 4 Coat 5 Sandal 6 Shirt 7 Sneaker 8 Bag 9 Ankle boot 这些种类不包括在数据集中，需要单独定义： 1class_names = [&#x27;T-shirt/top&#x27;, &#x27;Trouser&#x27;, &#x27;Pullover&#x27;, &#x27;Dress&#x27;, &#x27;Coat&#x27;, &#x27;Sandal&#x27;, &#x27;Shirt&#x27;, &#x27;Sneaker&#x27;, &#x27;Bag&#x27;, &#x27;Ankle boot&#x27;] 研究数据 在训练模型之前，先研究这些数据格式。比如在训练集中的六万张图片，每张图片由28x28的像素点表示。 1train_images.shape (60000, 28, 28) 同时还有六万个与之对应的标签： 1len(train_labels) 60000 每个标签都是一个0到9之间的整数： 1train_labels array([9, 0, 0, …, 3, 0, 5], dtype=uint8) 还有一万张用于测试的图片： 1test_images.shape (10000, 28, 28) 一万张训练集的标签： 1len(test_labels) 10000 数据预处理 在训练模型之前，必须先对数据进行预处理。观察第一张图，我们可以看到图片的像素值在0到255之间。 12345plt.figure()plt.imshow(train_images[0])plt.colorbar()plt.grid(False)plt.show() 将像素值范围缩小为0到1，所以将像素值都除以255： 12train_images = train_images / 255.0test_images = test_images / 255.0 为了确保数据的正确性，先将训练集的前25个图片显示出来，并且在图片下面展示分类名。 123456789plt.figure(figsize=(10,10))for i in range(25): plt.subplot(5,5,i+1) plt.xticks([]) plt.yticks([]) plt.grid(False) plt.imshow(train_images[i], cmap=plt.cm.binary) plt.xlabel(class_names[train_labels[i]])plt.show() 建立模型 建立神经网络需要配置模型层，然后编译模型。 设置层 基本的神经网络模块是层。层会从它们获取的数据里提取图像。它们希望从这些图像里获取有用的信息。 大多数深度学习都是简单层组合在一起。大多数层比如tf.keras.layers.Dense，拥有在训练时学习到的参数。 1model = keras.Sequential([ keras.layers.Flatten(input_shape=(28, 28)), keras.layers.Dense(128, activation=&#x27;relu&#x27;), keras.layers.Dense(10)]) 这个网络的第一层，tf.keras.layers.Flatten，将图像的格式从二维数组(28 * 28像素)转换为一维数组(28 * 28 = 784像素)。可以将这一层看作是将图像中的像素行展开并排列起来。这一层没有参数需要学习;它只是重新格式化数据。 像素被扁平化后，网络由两个tf.keras.层组成。它们是紧密相连或完全相连的神经层。第一致密层有128个节点(或神经元)。第二个(也是最后一个)层返回长度为10的logits数组。每个节点都包含一个评价值，表示当前图像属于这10个类中的一个。 编译模型 在准备训练模型之前，需要进行一些其他设置。 这些是在模型的编译步骤中添加的： Loss function——这可以衡量模型在培训期间的准确性。您希望最小化这个函数，以便将模型“引导”到正确的方向。 Optimizer——这就是模型如何根据它看到的数据和它的损失函数进行更新。 Metrics——用于监控培训和测试步骤。下面的例子使用了准确率，即正确分类的图像的比例。 1model.compile(optimizer=&#x27;adam&#x27;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[&#x27;accuracy&#x27;]) 训练模型 训练神经网络模型需要以下步骤： 输入训练数据到模型中。 模型学习关联图像和分类标签。 让模型预测测试集。 验证预测结果是否和标签匹配。 输入数据到模型中 利用model.fit方法。他能将模型用于拟合训练数据。 1model.fit(train_images, train_labels, epochs=10) Epoch 1/101875/1875 [==============================] - 3s 2ms/step - loss: 0.4978 - accuracy: 0.8248Epoch 2/101875/1875 [==============================] - 3s 2ms/step - loss: 0.3767 - accuracy: 0.8637Epoch 3/101875/1875 [==============================] - 3s 2ms/step - loss: 0.3397 - accuracy: 0.8759Epoch 4/101875/1875 [==============================] - 3s 2ms/step - loss: 0.3138 - accuracy: 0.8854Epoch 5/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2948 - accuracy: 0.8914Epoch 6/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2803 - accuracy: 0.8958Epoch 7/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2678 - accuracy: 0.9006Epoch 8/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2590 - accuracy: 0.9043Epoch 9/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2464 - accuracy: 0.9078Epoch 10/101875/1875 [==============================] - 3s 2ms/step - loss: 0.2402 - accuracy: 0.9099 &lt;tensorflow.python.keras.callbacks.History at 0x7fe472eff4a8&gt; 评估准确率 比较模型在测试数据集上的表现： 12test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)print(&#x27;\\nTest accuracy:&#x27;, test_acc) 313/313 - 1s - loss: 0.3382 - accuracy: 0.8840 Test accuracy: 0.8840000033378601 结果是测试数据集上的准确性比训练数据集上的准确性稍低。训练准确度和测试准确度之间的差距代表过拟合。当机器学习模型在新的、以前没有看到的输入上的表现不如在训练数据上的表现时，就会发生过拟合。过度拟合的模型“记忆”了训练数据集中的噪音和细节，从而对模型在新数据上的性能产生负面影响。有关更多信息，请参见以下内容 证明过度拟合 防止过度拟合策略 预测结果 通过训练模型，你可以使用它来预测某些图像。 模型的线性输出，logits。 附加一个softmax层以将logit转换为更容易解释的概率。 1probability_model = tf.keras.Sequential([model, tf.keras.layers.Softmax()]) 1predictions = probability_model.predict(test_images) 在这里，模型已经预测了测试集中每个图像的标签。 让我们看一下第一个预测： 1predictions[0] array([1.2275562e-07, 8.9534730e-08, 7.6224147e-09, 1.9726743e-08, 6.1515345e-07, 4.6329503e-03, 4.1164008e-06, 1.5043605e-02, 2.8817641e-07, 9.8031825e-01], dtype=float32) 预测是一个包含10个数字的数组。它们代表了模型的“自信”，即图像对应着10种不同的服装。你可以看到哪个标签的自信度最高： 1np.argmax(predictions[0]) 9 因此，模型最自信的认为这是一个踝靴，或class_names[9]。检查测试标签表明这个分类是正确的： 1test_labels[0] 9 绘制图表，看看10个类预测的全部集合。 123456789101112131415161718192021222324252627282930def plot_image(i, predictions_array, true_label, img): predictions_array, true_label, img = predictions_array, true_label[i], img[i] plt.grid(False) plt.xticks([]) plt.yticks([]) plt.imshow(img, cmap=plt.cm.binary) predicted_label = np.argmax(predictions_array) if predicted_label == true_label: color = &#x27;blue&#x27; else: color = &#x27;red&#x27; plt.xlabel(&quot;&#123;&#125; &#123;:2.0f&#125;% (&#123;&#125;)&quot;.format(class_names[predicted_label], 100*np.max(predictions_array), class_names[true_label]), color=color)def plot_value_array(i, predictions_array, true_label): predictions_array, true_label = predictions_array, true_label[i] plt.grid(False) plt.xticks(range(10)) plt.yticks([]) thisplot = plt.bar(range(10), predictions_array, color=&quot;#777777&quot;) plt.ylim([0, 1]) predicted_label = np.argmax(predictions_array) thisplot[predicted_label].set_color(&#x27;red&#x27;) thisplot[true_label].set_color(&#x27;blue&#x27;) 验证预测 通过训练模型，您可以使用它来预测某些图像。 让我们看一下第0张图片，预测和预测数组。 正确的预测标签为蓝色，错误的预测标签为红色。 该数字给出了预测标签的百分比（满分为100）。 1234567i = 0plt.figure(figsize=(6,3))plt.subplot(1,2,1)plot_image(i, predictions[i], test_labels, test_images)plt.subplot(1,2,2)plot_value_array(i, predictions[i], test_labels)plt.show() 1234567i = 12plt.figure(figsize=(6,3))plt.subplot(1,2,1)plot_image(i, predictions[i], test_labels, test_images)plt.subplot(1,2,2)plot_value_array(i, predictions[i], test_labels)plt.show() 让我们绘制一些带有预测的图像。 请注意，即使非常自信，该模型也可能是错误的。 12345678910111213# Plot the first X test images, their predicted labels, and the true labels.# Color correct predictions in blue and incorrect predictions in red.num_rows = 5num_cols = 3num_images = num_rows*num_colsplt.figure(figsize=(2*2*num_cols, 2*num_rows))for i in range(num_images): plt.subplot(num_rows, 2*num_cols, 2*i+1) plot_image(i, predictions[i], test_labels, test_images) plt.subplot(num_rows, 2*num_cols, 2*i+2) plot_value_array(i, predictions[i], test_labels)plt.tight_layout()plt.show() 使用训练的模型 最后，利用训练好的模型对单幅图像进行预测。 123# Grab an image from the test dataset.img = test_images[1]print(img.shape) (28, 28) tf.keras模型经过优化，可以立即对一批或一组示例进行预测。因此，即使使用的是单个图像，也需要将其添加到列表中 123# Add the image to a batch where it&#x27;s the only member.img = (np.expand_dims(img,0))print(img.shape) (1, 28, 28) 现在为这个图像预测正确的标签 123predictions_single = probability_model.predict(img)print(predictions_single) [[2.3256284e-06 5.5768194e-13 9.9955302e-01 3.3701731e-13 4.3444714e-04 3.7890427e-17 1.0105057e-05 4.5671220e-20 8.4883814e-14 9.5599025e-18]] 1plot_value_array(1, predictions_single[0], test_labels)_ = plt.xticks(range(10), class_names, rotation=45) keras.Model.predict返回列表的列表-数据批次中每个图像的列表。 批量获取我们（唯一）图像的预测： 1np.argmax(predictions_single[0]) 2 这个模型预测了一个标签。 本指南使用Fashion MNIST数据集，该数据集包含10个类别中的70,000张灰度图像。这些图像以低分辨率(28×28像素)显示了衣服的单个物品，如图所示 Fashion MNIST旨在替代经典MNIST数据集，通常被用作计算机视觉机器学习程序的“ Hello，World”。 MNIST数据集包含手写数字（0、1、2等）的图像，格式与您将在此处使用的衣服的格式相同。 本指南将Fashion MNIST用于多种用途，并且因为它比常规MNIST更具挑战性。 两个数据集都相对较小，用于验证算法是否按预期工作。 它们是测试和调试代码的良好起点。 在这里，使用60,000张图像来训练网络，使用10,000张图像来评估网络学习对图像进行分类的准确程度。 您可以直接从TensorFlow访问Fashion MNIST。 直接从TensorFlow导入和加载Fashion MNIST数据：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://sci.ci/tags/TensorFlow/"}]},{"title":"PyTorch学习笔记","slug":"PyTorch学习笔记","date":"2020-06-16T14:14:08.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/16/PyTorch学习笔记/","link":"","permalink":"https://sci.ci/2020/06/16/PyTorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"PyTorch的用处：GPU加速、求导、常用API P1：开发环境 Python 3.7+Anaconda 5.3.1 CUDA 10.0 Pycharm Community 下载安装Anaconda，勾选“添加ana到路径环境” cmd输入，查看ana安装的包。 1conda list 安装nvidia CUDA 确保有nvidia的GPU 配置系统环境变量，确保CUDA的bin目录在PATH行里，在cmd里 1nvcc -v pytorch.org里下载pytorch 下载pycharm，这是一个python的IDE 配置编译器为Python P2：梯度下降算法 求解线性方程，如果存在噪声？ 求取近似值w,b。 假设采样数据输入x和理论真实输出y满足 y=wx+b的线性回归函数。Linear Regression 那么$$loss\\ function=\\sum(wx+b-y)^2$$ 梯度下降算法：有若干个wb不同的函数y=wx+b，这些函数能够将采样输入x得出一个若干个输出值w1x+b1、w2x+b2等等，这个输出值wx+b与理论输出值y存在误差，于是我们定义了一个loss function来表示w和b不同时，wx+b与真实值y之间的误差。通过对loss function做运算能找到一组w和b，这组w和b可以使wx+b最接近y。 对loss function的运算方式叫梯度下降算法，将若干个采样输入和理论输出带入loss function，形成一个诸如L(w,b)的方程。要找使得L(w,b)最小的w和b。 P3：梯度Ⅱ对线性回归y=wx+b 计算loss function： 1234567def compute_error_for_line_given_points(b,w,points)： totalError=0 for i in range(0,len(points)): x = points[i,0] y = points[i,1] totalError += (y-(w*x+b))**2 return totalError / float(len(points)) 输入上一个w和b值，计算梯度，返回下一个w和b： 123456789101112def step_gradient(b_current,w_current,points,learningRate): b_gradient = 0 w_gradient = 0 N = float(len(points)) for i in range(0,len(points)): x = points[i,0] y = points[i,1] b_gradient += -(2/N) * (y - ((w_current*x) + b_current)) w_gradient += -(2/N) * x * (y-((w_current*x)+b_current)) new_b = b_current - (learningRate * b_gradient) new_w = w_current - (learningRate * w_gradient) return [new_b,new_w] 计算最优解： 123456def gradient_descent_runner(points,starting_b,starting_w,learning_rate,num_iterations): b = starting_b w = starting_w for i in range(num_iterations): b,w = step_gradient(b,w,np.array(points),learning_rate) return [b,w] P4：手写数字问题手写0~9，输出手写数字 P5：Pytorch基本数据类型Int: IntTensor of size() float: FloatTensor of size() Int array: IntTensor of size [d1,d2……] 没有String类型，只能用向量来表示[0,0,1,0……] P6：张量 TensorTensor或者Numpy的ndarrays 12from __future__ import print_functionimport torch 构造空矩阵,五行三列 12x = torch.empty(5,3)print(x) tensor(1.00000e-04 * [[-0.0000, 0.0000, 1.5135], [ 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000], [ 0.0000, 0.0000, 0.0000]]) 构造一个随机数矩阵，随机数都在0到1之间 12x = torch.rand(5, 3) print(x) tensor([[ 0.6291, 0.2581, 0.6414], [ 0.9739, 0.8243, 0.2276], [ 0.4184, 0.1815, 0.5131], [ 0.5533, 0.5440, 0.0718], [ 0.2908, 0.1850, 0.5297]]) 构造一个全0矩阵，字符类型为long。 12x = torch.zeros(5, 3, dtype=torch.long)print(x) tensor([[ 0, 0, 0], [ 0, 0, 0], [ 0, 0, 0], [ 0, 0, 0], [ 0, 0, 0]]) 直接输入数据创建一个张量。 12x = torch.tensor([5.5, 3])print(x) tensor([ 5.5000, 3.0000]) 创建一个张量，基于已存在的张量 1234567891011x = x.new_ones(5, 3, dtype=torch.double) # new_* methods take in sizesprint(x)x = torch.randn_like(x, dtype=torch.float) # override dtype!print(x) # result has the same size tensor([[ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.], [ 1., 1., 1.]], dtype=torch.float64)tensor([[-0.2183, 0.4477, -0.4053], [ 1.7353, -0.0048, 1.2177], [-1.1111, 1.0878, 0.9722], [-0.7771, -0.2174, 0.0412], [-2.1750, 1.3609, -0.3322]]) 获取维度 1print(x.size()) torch.Size([5, 3])","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://sci.ci/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"PyTorch","slug":"PyTorch","permalink":"https://sci.ci/tags/PyTorch/"}]},{"title":"SSR负载均衡实现自动切换端口","slug":"SSR负载均衡实现自动切换端口","date":"2020-06-15T23:09:41.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/16/SSR负载均衡实现自动切换端口/","link":"","permalink":"https://sci.ci/2020/06/16/SSR%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"1：准备工作 一台国内服务器。 国内服务器可以监控到国外的服务器ip或者端口是否被封锁。如果你用国外的服务器，也能做到负载均衡，但是如果这台服务器被封锁，那SSR还是会断开连接。国内服务器不会被封锁。 SSR添加多个端口或者多台SSR服务器 修改SSR配置文件，监听多个端口《SSR添加多用户多端口教程》，我监听的是34567、34568、34569。 注意：不同端口或者IP的密码和协议等等都必须相同。 2：haproxy下载和配置在Ubuntu上下载： 1apt-get -y install haproxy 在centos上： 1yum -y install haproxy 安装完毕后，打开haproxy配置文件/etc/haproxy/haproxy.cfg，修改配置为： 12345678910111213141516171819202122232425262728293031323334353637383940global log &#x2F;dev&#x2F;log local0 log &#x2F;dev&#x2F;log local1 notice user root group root daemondefaults log global mode tcp timeout connect 5s timeout client 5s timeout server 5s option dontlognull option redispatch retries 3listen status bind *:1111 mode http stats refresh 30s stats uri &#x2F;status stats realm Haproxy stats auth admin:admin stats hide-version stats admin if TRUEfrontend shadowsocks-in mode tcp bind *:8388 default_backend shadowsocks-outbackend shadowsocks-out mode tcp option tcp-check balance roundrobin server servername1 xxxxx1.com:8088 check server servername2 xxxxx2.net:8080 check server servername3 12.34.56.78:9999 check server servername4 123.234.234.123:443 check 配置分为五大部分： global：全局配置，这里主要是配置了日志 默认值：默认配置，也是一些分布式配置 听：监听配置，我在1111端口配置了http监控页面，访问ip:1111/status，认证用户名和密码都是admin，具体含义参考博客“ haproxy监控页面和页面详细参数” frontend：前端配置，Shadowsocks数据流从这里进入，流向指定标题，注意这里的端口号，即为ss客户端的输入端口 backend：调整配置，balance指定负载平衡方式，每个服务器写一个服务器行，服务器支持域名或IP。如果使用域名，重启服务出现问题，可以参考博客“解决Haproxy用Systemd启动失败的问题”。 3：其他负载均衡方式《shadowsocks借助nginx实现负载均衡，自动切换“零”宕机》介绍了使用nginx的方法。也可以尝试。 我之前使用过apache来做负载均衡，但是无法连接，查看apache日志后提示如下： 1[Tue Jun 16 00:07:30.557609 2020] [core:debug] [pid 25543:tid 140127116449536] protocol.c(1335): [client 127.0.0.1:57310] AH00566: request failed: malformed request line 意思是请求行格式错误。刚开始以为配置错了。阅读apache的相关资料后才知道。 apache在做负载均衡时，只是对子目录进行了替换，比如说，你监听1234端口，将发送给主机1234端口的数据均衡发送给192.1.1.1:5678、192.1.1.2:6789。那么你在访问baidu.com/test 时，将你的请求发送给1234端口，而apache做的仅仅只是将请求HOST替换掉。真实请求地址是192.1.1.1:5678/test 或者192.1.1.2:6789/test 。。而ssr加密后的数据，是没有http请求头的，这便导致了，日志所显示的请求行格式错误。所以apache并不适合做单纯的数据转发。 4：参考文献《用Haproxy实现多VPS线路负载均衡》 《shadowsocks借助nginx实现负载均衡，自动切换“零”宕机》 《Haproxy（二）之负载均衡配置详解》 《Apache 正向代理与反向代理配置》","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"SSR","slug":"SSR","permalink":"https://sci.ci/tags/SSR/"},{"name":"haproxy","slug":"haproxy","permalink":"https://sci.ci/tags/haproxy/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://sci.ci/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"}]},{"title":"移动运营商过滤外网流量和解决办法","slug":"移动运营商过滤外网流量问题","date":"2020-06-14T12:22:09.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/14/移动运营商过滤外网流量问题/","link":"","permalink":"https://sci.ci/2020/06/14/%E7%A7%BB%E5%8A%A8%E8%BF%90%E8%90%A5%E5%95%86%E8%BF%87%E6%BB%A4%E5%A4%96%E7%BD%91%E6%B5%81%E9%87%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"移动在哪些方面对用户访问外网进行了限制？ 国内过滤掉海外站点的http请求。 我们最常使用的https协议是由http和tls协议构成。通常访问一个https网站，第一步是，向目标网站比如youtube.com发起一个http明文请求，要求建立连接，之后传递数据才由tls协议进行加密。。如果只是单纯的使用浏览器代理，发送到youtube的http请求将被移动网络过滤掉，从而无法建立连接。 不过，ssr、v2ray在使用时，已经将http请求进行了加密转发到ssr、v2ray服务端。因此http请求是由ssr服务端在外网发起的，不用担心移动过滤http请求。 国内外网络边界上对无特征的tcp流量限流降速 ssr和v2ray使用了加密和混淆协议，这些协议保证了它们服务端和客户端之间传递的数据无法被解密。移动在这方面，直接对这类没有特征的tcp流量进行丢包，也就导致了，移动用户访问外网速度极慢。 国内外网络边界上对tls协议的tcp流量按优先级放行 tls协议流量在出国流量中是海量的，我们访问普通海外网站的时，也包含了大量的tls流量。因此，移动不能对这类流量进行限流降速，而是对那些优先级比较低的用户访问外网进行限制，在高峰时段，可能访问外网速度奇慢。这个问题可以直接花钱解决。 如何解决移动网络访问外网限制？ 更换电信或联通网络。 广电也很坑，跟移动差不多 使用v2ray+ws+tls方案，即将翻墙流量伪装为普通的https流量。如果你的移动网络出国优先级比较低，高峰时段也会很拥挤。这时候，就取决于你的外网服务器了。外网服务器使用cn2gia自然就不会拥挤了。 如果你买不起一个cn2gia线路，试试在国内部署一个中转服务器，阿里云头年90块（学生价也有优惠）。在这个路由器上部署一个stunnel，把ssr、v2ray的代理请求转发到国内服务器，然后国内服务器发送至国外服务器。 这个方案，可以解决ssr不带tls协议的缺点，同时，即便外网服务器不是cn2gia，你用的也不是电信联通，都没关系。阿里云服务器出国会走电信，而且优先级高，所以即便是高峰时期，网速也不会有影响。 然而，受到国内带宽价格影响。阿里云90一年的服务器，带宽仅为5Mpbs，所以下载速度也就在900kB/s左右。不过看1080P的youtube没有问题。","categories":[{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"移动网络","slug":"移动网络","permalink":"https://sci.ci/tags/%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"}]},{"title":"BLOG双线部署+https","slug":"BLOG双线部署-https","date":"2020-06-14T11:53:54.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/14/BLOG双线部署-https/","link":"","permalink":"https://sci.ci/2020/06/14/BLOG%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2-https/","excerpt":"","text":"dns.la支持多线解析，而且免费，非常好用。推荐！ 关于证书申请的方式，就不多说了。之前在coding申请证书失败，是因为域名cname解析没有配置正确。将域名服务商修改为 https://dns.la 后，需要先将域名海外线路解析到coding。 将海外线路解析到coding是，coding证书能够申请成功的关键！在github申请证书时，也需要将海外线路解析到github。 证书申请完毕后，可以在dns.la上修改dns线路，国内解析到coding，海外解析到github。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://sci.ci/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"}]},{"title":"SSR加速和降低服务器端口被封风险","slug":"SSR加速和降低服务器端口被封风险","date":"2020-06-08T13:22:38.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/08/SSR加速和降低服务器端口被封风险/","link":"","permalink":"https://sci.ci/2020/06/08/SSR%E5%8A%A0%E9%80%9F%E5%92%8C%E9%99%8D%E4%BD%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%B0%81%E9%A3%8E%E9%99%A9/","excerpt":"","text":"另外需要说明的是，购买的国内服务器，不需要进行备案，你可以帮定一个域名到此服务器上，填写ssr客户端也只需要使用这个域名，ssr会自动帮你查询dns，此后即便国外ssr出现端口或ip被封，也不需要更改ssr客户端的配置信息。而只需要另起一台国外服务器，修改国内中转服务器的配置信息。 如果你懂得更多编程知识，你可以在国内国外的两台服务器上进行编程，实现，当国外服务器端口被封，国内和国外服务器自动检测，若检测到端口被封，则国外服务器修改ssr配置端口，而国内服务器修改stunnel配置信息。这样，无需人为干预，也能实现长久而稳定的连接。如果有空的话，我会去探索这个方案。 1：原理说明简单了解，可以提高你对网络的认识。 1.1 ssr网络加速原理由于中国移动对普通用户的海外流量随机高概率丢包，导致国外流量进入国内时，走移动线路，就会有很高的丢包率。所以我们希望借助一台，属于移动vip级别的国内服务器（这样移动出海线路优先级高，不容易丢包），或者出入海走联通电信线路的服务器。通常，阿里云、腾讯云服务器都能满足要求。 国内服务器上安装stunnel，并配置为客户端。国外服务器安装stunnel服务端和ssr服务端。 1.2 降低端口被封的风险原理stunnel是一个将流量利用ssl证书加密的软件，加密后的流量，出国时将会被识别为tls协议，因此不再具有ssr流量特点，我们常使用的https请求便基于ssl证书，此时国外服务器端口被封锁的几率将大大减小。出国后，stunnel将流量解密，再传递给ssr服务端。 通过抓取ssr流量，可以看到，ssr流量在传输过程中，由于协议加密，它不具备任何常见的网络请求特征，而你在使用ssr与海外服务器进行数据往来时，长时间的使用不具有网络请求特征的流量进行连接，很容易被防火墙识别为翻墙软件。因此被封。使用tls协议，就能够伪装为https请求，https(http协议+tls协议)。当然为了更有迷惑性，在ssr服务器端口加一个能被访问的网站是最好的。因为虽然tls协议作为https的一部分，但在实际使用中，由于没有http协议的流量，那么是能被推断出使用stunnel这类加密隧道的。如果长时间大流量访问，也有被封锁的风险。 而使用中转服务器，所付出的代价，仅仅是国内月租几块钱的服务器(阿里云、腾讯云等有学生服务器，一年一百块左右)，和相当低的stunnel加解密过程所导致的延迟，此延迟几乎不可见。 2：stunnel和ssr安装2.1 stunnel安装和配置stunnel安装，请参见我之间的文章《利用Stunnel+squid代理实现国内无客户端访问外网》。 3.2节是在国外服务器上安装stunnel服务端。第四章，在国内服务器上安装stunnel客户端。 将ssr的流量通过stunnel加密，你需要修改配置文件。在《利用Stunnel+squid代理实现国内无客户端访问外网》安装后的stunnel基础上修改。 修改国外服务器上的stunnel服务端配置文件，在/etc/stunnel/stunnel.conf文件里， 删除 12345[squid-proxy]; 服务监听的端口，client要连接这个端口与server通信accept &#x3D; 3129; 服务要连接的端口，连接到squid的3128端口，将数据发给squidconnect &#x3D; localhost:3128 添加 12345[tls2socks];服务端监听一个端口，这个端口用于接收stunnel客户端传过来的数据，建议设置在10000~60000之间，务必在linux防火墙和阿里云这类的服务商安全组开放，例如设置为：accept = 12345accpet = your accept port 1;连接到，ssr的服务器端口上，与ssr服务端配置的端口保持一致connect = localhost:your ssr server port 修改国内中转服务器上的stunnel客户端配置文件，在/etc/stunnel/stunnel.conf文件里， 删除 12345[squid-proxy]; 监听3128端口，那么用户浏览器的代理设置就是 stunnel-client-ip:3128accept = 3128; 要连接到的stunnel server的ip与端口，修改xx.xx.xx.xx为国外的服务器connect = xx.xx.xx.xx:3129 添加 12345[socks2tls];服务端监听一个端口，这个端口用于接收ssr客户端传过来的数据，建议设置在10000~60000之间，务必在linux防火墙和阿里云这类的服务商安全组开放。例如 accept = 34567accpet = your accept port 2;连接到，stunnel服务端接收端口上。按照该服务端的例如配置，这里应该为：connect = xx.xx.xx.xx:12345。xx表示国外服务器ip地址。connect = stunnel server ip:your accept port 1 2.2 ssr安装和配置ssr安装，可以参考《SSR 一键安装脚本》，在国外的服务器上安装。 ssr服务端端口需要和stunnel服务端的connect端口保持一致。 ssr客户端配置，客户端地址，应该填写为国内服务器ip，服务端口，应填写为stunnel客户端的accept端口(国内服务器上配置的accept = your accept port 2)，例子中给的34567端口。 配置完成后，就可以连接上网了。 即便使用移动网络，也能产生非常好的连接效果，而且应该在非常久得时间里，端口都不会被封。 3：可能出现的问题如果配置后无法上网，请检查你设置得端口，通过 https://port.ping.pe 网址检测你的端口是否开启，如果测试未开启，请修改防火墙配置，在《利用Stunnel+squid代理实现国内无客户端访问外网》中第4章有介绍。若任然没有导通，请检查云服务商的安全组是否开启了端口。 如果端口开放，而无法连接，请尝试，终止stunnel进程并重新启用。 方法1： 1servicer stunnel restart 方法2: 检查stunnel的进程 1ps aux | grep -i stunnel 找到进程号pid，在第二列 杀掉进程 1kill -9 替换为pid 然后重新启用stunnel 1stunnel 如果没有任何显示，则stunnel重启成功，且配置文件没有任何问题。否则将显示错误信息。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"SSR","slug":"SSR","permalink":"https://sci.ci/tags/SSR/"},{"name":"Stunnel","slug":"Stunnel","permalink":"https://sci.ci/tags/Stunnel/"}]},{"title":"Squid+MySQL储存用户验证通过的IP","slug":"Squid-MySQL储存用户验证通过的IP","date":"2020-06-02T10:02:54.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/06/02/Squid-MySQL储存用户验证通过的IP/","link":"","permalink":"https://sci.ci/2020/06/02/Squid-MySQL%E5%82%A8%E5%AD%98%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81%E9%80%9A%E8%BF%87%E7%9A%84IP/","excerpt":"","text":"0：前文在文章《利用Stunnel+squid代理实现国内无客户端访问外网》中，提到了，当使用代理验证实现代理访问时，手机的软件无法连接网络，而且切换浏览器需要重新验证用户名和密码。为了解决这个问题，我提出了四种方案。前两种漏洞太大，第三种，开发比较麻烦。于是，我采用了第四种方法。下面将对代码和具体细节进行说明。 阅读本文，请确保你已经安装了squid 3.5以上版本。squid -v可以查看你的安装版本。 1：配置基本环境MySQL和Python1.1 数据库Mysql被广泛用于网站数据库，网上的支持文档很多，重要的是，MySQL在python编程上具有非常好的支持。也就是mysqldb库。 使用数据库，主要是用来存放通过验证器验证的客户端ip，ACL辅助器可以通过读取这个ip，从而acl辅助器通过的ip不再需要验证器验证密码。所以，你使用任何其他数据库都是可以的。建议你选用你自己熟悉的数据库。因为本文对于如何在mysql下，创建数据表，只做大概说明。 我建议使用宝塔面板bt.cn安装mysql。这样可以可视化的安装mysql和创建数据库和数据表。也可以规避许多由于数据库权限问题导致的不可控因素。宝塔面板安装和在宝塔面板中安装mysql数据库，可以自行百度。非常简单。 在完成数据库安装后，请你在mysql里添加一个，库名为：squid。用户名为：squid。的数据库。用于存放squid数据。 数据库新建成功后，点击右边的管理。进入phpmyadmin，新建一个数据表。表名为：sq_client_ip。 表的结构： 注意，id项，新建表时，勾选AI，AI表示设置id为自增主键。这样每添加一个数据进去，id都会自行增加。 1.2 Python安装Python，简单的安装python，你只需要输入下面指令 centos: 1yum -y install python Ubuntu: 1apt-get -y install python 安装完python，需要安装python的mysqldb库。 1pip install mysqldb 2：自定义基本验证器新建一个python文件AuthPro.py。在里面添加如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/python# coding=UTF-8import sysimport MySQLdb&quot;&quot;&quot;&quot;&quot;&quot;def matchpasswd(login,passwd): #用户名和密码，用于验证输入的用户名和密码。 #你可以自定义验证通过的要求，验证通过，返回True，验证不通过返回False if (login == &#x27;修改为你的用户名&#x27; and passwd == &#x27;修改为你的验证密码&#x27;): return True else: return Falsedef write_client_ip_to_db(username,client_ip): #数据库地址，数据库名，数据库密码，数据库用户名，数据库编码格式 db=MySQLdb.connect(&quot;localhost&quot;,&quot;squid&quot;,&quot;修改为你的密码&quot;,&quot;squid&quot;,charset=&#x27;utf8&#x27;) # 使用cursor()方法获取操作游标 cursor = db.cursor() # 向sq_client_ip表中插入用户名和用户ip sql = &quot;INSERT INTO sq_client_ip(username, client_ip) VALUES (&#x27;%s&#x27;, &#x27;%s&#x27;)&quot; % (username,client_ip) try: # 执行sql语句 cursor.execute(sql) #Ok 后面的print语句可以向cache日志中输出提示。/var/log/squid/cache.log查看 print(&quot;执行sql语句&quot;) # 提交到数据库执行 db.commit() except: #打印错误内容 info = sys.exc_info() print( info[0], &quot;:&quot;, info[1]) #发生错误时回滚 db.rollback() # 关闭数据库连接 db.close() returnwhile True: # read a line from stdin line = sys.stdin.readline() line = line.strip() #提取输入参数。 username,password,client_ip = line.split() #判断密码是否匹配 if matchpasswd(username, password): #输出ok表示验证通过 sys.stdout.write(&#x27;OK\\n 密码验证通过&#x27;) #将客户端ip添加至数据库ip白名单 write_client_ip_to_db(username,client_ip) else: sys.stdout.write(&#x27;ERR\\n 密码验证失败&#x27;) # Flush the output to stdout. sys.stdout.flush() 将AuthPro.py文件拷贝到squid的配置文件夹/etc/squid里 3：外部ACL辅助器新建一个python文件AclHelper.py。在里面添加如下内容: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python# coding=UTF-8import sysimport MySQLdb&quot;&quot;&quot;当用户连接squid，传递用户客户端ip地址到外部辅助器，辅助器通过标准输入读取。辅助器查询数据库符合客户端ip的所有项，如果查询结果，显示客户ip在数据库中，则输出ok，否则输出ERR&quot;&quot;&quot;def matchclientip(client_ip): #数据库地址，数据库名，数据库密码，数据库用户名，数据库编码格式 db=MySQLdb.connect(&quot;localhost&quot;,&quot;squid&quot;,&quot;你的数据库密码&quot;,&quot;squid&quot;,charset=&#x27;utf8&#x27;) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句 sql = &quot;SELECT * FROM sq_client_ip WHERE client_ip = &#x27;%s&#x27;&quot; % (client_ip) try: # 执行sql语句 cursor.execute(sql) result = cursor.fetchone() if result: exist_ip = True else: exist_ip = False except: # 发生错误时回滚 db.rollback() exist_ip = False # 关闭数据库连接 db.close() return exist_ipwhile True: # 从标准输入读取一行，“client_ip” line = sys.stdin.readline() #提取输入参数。squid，输入给辅助器的字符串是&quot;0 xx.xx.xx.xx&quot;格式 #利用split分割字符串，得到0和client_ip的list client_ip = line.strip().split()[1] #判断密码是否匹配 if matchclientip(client_ip): #输出ok表示验证通过 sys.stdout.write(&#x27;OK\\n&#x27;) #print会将信息输出到/var/log/squid/cache.log中。 print(&quot;Acl辅助器验证成功&quot;) else: sys.stdout.write(&#x27;ERR\\n&#x27;) print(&quot;ACL辅助器验证失败&quot;) # Flush the output to stdout. sys.stdout.flush() 将AclHelper.py文件拷贝到squid的配置文件夹/etc/squid里 4：修改squid配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# http_port 设置监听端口，默认为3128http_port 6666#父squid配置，配合国外服务器server2使用nonhierarchical_direct off#转发请求通过stunnel至父squidcache_peer localhost parent 3128 0 defaultnever_direct allow all# access_log 设置access日志，daemon表示在后台将日志写入/var/log/squid/access.log文件, # combined是一个预定义的logformat，也可以使用自定义的logformataccess_log daemon:/var/log/squid/access.log combined # ACLs all, manager, localhost, and to_localhost are predefined.acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT # 拒绝所有非Safe_ports的请求http_access deny !Safe_ports# 拒绝所有非SSL_prots的CONNECT请求http_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost manager#http_access deny manager# 允许来自本地的请求http_access allow localhost#######################################定义一个外部ACL辅助器#使用python解释器，negativettl表示验证错误时的缓存时间单位秒，concurrency表示最多接收的认证通过用户，ipv4必须，如果没有ipv4会报错。external_acl_type MyAclHelper negative_ttl=1 concurrency=30 ipv4 %SRC /usr/bin/python /etc/squid/AclHelper.pyacl MyAcl external MyAclHelperhttp_access allow MyAcl#定义一个验证器#指定python运行目录，和python程序的目录auth_param basic program /usr/bin/python /etc/squid/AuthPro.py#向python程序中输入key_extras变量客户端ip&quot;%&gt;a&quot;auth_param basic key_extras &quot;%&gt;a&quot;#允许多少个子程序auth_param basic children 30#输入框提示信息auth_param basic realm 输入用户名和密码#验证信息的缓存时长auth_param basic credentialsttl 1 second#用户名和密码是否区分大小写auth_param basic casesensitive on#强制用户验证acl authenticated proxy_auth REQUIREDhttp_access allow authenticated################################################# 拒绝所有请求，最后兜底的规则http_access deny all 特别需要注意的是： 必须辅助器配置在前，而验证器配置在后。由于squid特殊的处理机制，当squid从配置文件指定的http_access中找到了符合的条件的allow或deny信息，则后续的判断将不会再生效，也就是说，只有在用户无法通过辅助器验证时，才会进行验证器验证。 辅助器必须设置negative_ttl项，而且设置的不通过验证时间不易过长，最好在几秒内。原因是，当用户连接squid后，首先通过辅助器查找数据库是否有此ip，如果没有辅助器会缓存此ip信息，并将其标记为未通过验证，再进入验证器。而通常，我们首先于squid连接上网的并不是浏览器，可能收微博软件等，这些软件由于无法弹出验证窗口，而导致验证器验证失败。此后即便你打开浏览器，而由于上一次的验证失败而缓存了失败信息，致使，squid不会再进行辅助器和验证器验证，而直接拒绝访问。因此设置验证失败缓存时间短点，可以保证我们打开浏览器时，还能进入辅助器验证和验证器验证。 验证器必须设置credentialsttl项，且设置时间不易过长，最好在几秒内。之所以验证器验证成功的缓存不能太长，是因为当我们首次通过验证器验证后，squid缓存成功验证的用户信息，下次用户则无需再次经过验证器密码验证，直接读取用户名和ip。但是由于squid缓存的是用户的ip和用户名，如果你使用了微博等没有验证框的软件，由于没有向squid发送用户名，会导致无法联网。 所以，我们利用验证器，只是为了保存成功验证的用户ip，然后通过辅助器来验证用户。所以，通过后则清除验证器的缓存。 用户再次上网，便会首先经过辅助器，此时辅助器已经能从数据库读取到刚才验证器保存的客户ip。辅助器，可以设置比较久的成功ttl时长，如果没有设置，默认是一个小时。 5：参考资料《squid中文权威指南》 《用Python脚本打造Squid权限认证后端程序以及Squid3.5 auth_param key_extras新特性介绍》 《使用squid搭建代理服务器》 《Feature: Add-On Helpers for Request Manipulation》 《stackoverflow上关于自定义验证器输入客户端IP的回答》 最后，感谢https://www.hawu.me 站长，提供的一些帮助。","categories":[{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Squid","slug":"Squid","permalink":"https://sci.ci/tags/Squid/"},{"name":"Mysql","slug":"Mysql","permalink":"https://sci.ci/tags/Mysql/"}]},{"title":"利用Stunnel+squid代理实现国内无客户端访问外网","slug":"Stunnel-squid代理加速亚琛教学视频加速","date":"2020-05-28T21:26:23.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/05/28/Stunnel-squid代理加速亚琛教学视频加速/","link":"","permalink":"https://sci.ci/2020/05/28/Stunnel-squid%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E4%BA%9A%E7%90%9B%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E5%8A%A0%E9%80%9F/","excerpt":"","text":"1：加速原理1.1 squid介绍squid是一个用于代理的开源软件，用户主机将http请求发送到部署了squid的服务器，squid可以帮助用户转发http请求。利用squid，我们可以让服务器替我们请求数据，再由服务器转发给我们。 按找squid原理，我们就已经可以进行翻墙了，在国内能够访问的国外服务器上部署squid，将访问谷歌的请求发送给squid，squid替我们请求谷歌数据，再将谷歌数据转发给我们。这就是一个完整的工作过程。 但是由于squid请求报头未加密，在squid服务器向浏览器返回数据时，能够被GFW检测到访问数据来自于谷歌。从而将返回数据过滤掉。之后通过squid返回的数据，都会被GFW过滤掉，即使我们访问的是百度，也会无法收到返回数据。 1.2 Https介绍这篇文章详细介绍了加密的原理：https://blog.csdn.net/clh604/article/details/22179907 1.3 stunnel介绍stunnel是一个开源软件，使用stunnel可以为我们使用tcp协议传输的数据使用SSL协议加密，这样我们的请求，除了客户端和服务器，其他人将无法从数据中提取到有用信息。 为了让GFW无法识别出主机访问谷歌和返回的数据来自谷歌。这里使用stunnel将主机和squid之间的通信数据加密，将http请求的报头也加密。 1.4 代理过程在windows主机上设置全局代理，将windows的tcp请求，转发到国内服务器server 1上，国内服务器server 1与国外服务器server 2搭建stunnel加密隧道连接，国外服务器server 2利用squid，发送主机的访问请求，并将访问结果返回给server 1，server 1在发送给主机浏览器。加速原理如下图。 通常可以只利用一个国外服务器，在国外服务器上部署stunnel和squid，在本地主机上搭建stunnel客户端就可以了。如下图 但是，为了访问方便，即任何用户只需要设置windows上现有的代理服务器就能访问外网，而不需要下载stunnel客户端和配置客户端参数。 相比于主机使用Stunnel客户端，将stunnel客户端部署到国内服务器的缺点是：这需要国内外均有服务器。成本会更高。 更重要的是，我们与国内服务器之间的信息被抓取后，能够获取到我们访问的信息，比如是谷歌、使用的浏览器版本等，但是无法知道具体访问内容。由于是与国内服务器发送信息，因此被探测的几率很小。 2：主机设置代理访问为了让阅读本文的读者，提前的看到成果，将server1和server2都配置好后，先介绍如何利用你搭建好的服务器访问外网。 打开代理服务器色设置 在代理服务器上输入国内服务器server1的IP和stunnel客户端监听的端口号。 使用浏览器登陆google 实际上使用就是这么简单。当然为了你搭建的隧道不会被其他人使用，你也可以对能够访问这条隧道的IP进行限制，或者设置一个密码。会在后续中介绍到。 3：国外服务器配置确保在服务商安全组里开放了3128和3129端口，这两个端口，将用于接收和转发数据。 3.1 安装配置Squid 安装squid ubuntu使用： 1apt-get install squid centos使用： 1yum install squid 使用squid -v检查squid是否安装好。 配置squid 打开squid配置文件/etc/squid/squid.conf。没有就新建此文件 将文件内容修改为： 1234567891011121314151617181920212223242526272829303132333435363738# http_port 设置监听端口，默认为3128http_port 3128# access_log 设置access日志，daemon表示在后台将日志写入/var/log/squid/access.log文件, # combined是一个预定义的logformat，也可以使用自定义的logformataccess_log daemon:/var/log/squid/access.log combined# visible_hotname 设置代理服务器的主机名# 默认取本机的hostnamevisible_hostname funway.aliyun.proxy# ACLs all, manager, localhost, and to_localhost are predefined.acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT# 拒绝所有非Safe_ports的请求http_access deny !Safe_ports# 拒绝所有非SSL_prots的CONNECT请求http_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# 允许来自本地的请求http_access allow localhost# 拒绝所有请求，最后兜底的规则http_access deny all 更多详细的配置参数解释，请参考博文《使用squid搭建代理服务器》 配置squid只能本地地址访问。 运行squid 12service squid start //运行service squid status //查看squid运行状态 3.2 安装配置stunnel服务端 生成自签名证书，如果没有openssl需要先安装。 1openssl req -new -x509 -days 3650 -nodes -out stunnel.pem -keyout stunnel.pem 将生成的证书，复制到/etc/stunnel文件夹下 1cp stunnel.pem /etc/stunnel 这个证书还需要下载到主机，之后上传到国内服务器，用于为stunnle客户端设置的公钥。 下载安装stunnel 1apt-get install stunnel 设置stunnel配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849; 设置工作目录，没有目录需要先创建chroot = /var/run/stunnel/; 设置stunnel的pid文件路径（在chroot下）pid = /stunnel.pid; 设置stunnel工作的用户（组）setuid = rootsetgid = root; 开启日志等级：emerg (0), alert (1), crit (2), err (3), warning (4), notice (5), info (6), or debug (7); 默认为5debug = 7; 日志文件路径（我的server的版本有个bug，这个文件也被放在chroot路径下了，client的版本则是独立的=。=#）output = /stunnel.log; 证书文件，就是在本文2.2中用openssl生成的自签名证书（server端必须设置这两项）cert = /etc/stunnel/stunnel.pem; 私钥文件key = /etc/stunnel/stunnel.pem; 设置stunnel服务，可以设置多个服务，监听同的端口，并发给不同的server。; 自定义服务名squid-proxy[squid-proxy]; 服务监听的端口，client要连接这个端口与server通信accept = 3129; 服务要连接的端口，连接到squid的3128端口，将数据发给squidconnect = localhost:3128; **************************************************************************; * 下面这些配置我都注释掉了，但也需要了解下 *; **************************************************************************; 设置是否对传输数据进行压缩，默认不开启。; 这是跟openssl相关的，如果你的openssl没有zlib，开启这个设置会导致启动失败（failed to initialize compression method）;compression = zlib; 设置ssl版本,这个也是跟安装的openssl有关的;sslVersion = TLSv1; Authentication stuff needs to be configured to prevent MITM attacks; It is important to understand that this option was solely designed for access control and not for authorization; It is not enabled by default!; 下面这些配置用来定义是否信任对方发过来的证书。就好比浏览器访问https的时候，浏览器默认会信任那些由权威CA机构签发的证书，; 对于那些自签名证书，浏览器就会弹出对话框提醒用户这个证书可能不安全，是否要信任该证书。; 这是有效防止中间人攻击的手段; verify 等级2表示需要验证对方发过来的证书（默认0，不需要验证，都信任）; 因为这个配置是server端的，我们不需要理会client的证书（client也不会没事发证书过来啦）;verify = 2; CAfile 表示受信的证书文件，即如果对方发过来的证书在这个CAfile里，那么就是受信任的证书；否则不信任该证书，断开连接。;CAfile = /etc/stunnel/stunnel-client.pem 启动停止stunnel 1234service stunnel start //开启stunnelservice stunnel restart //重启service stunnel stop //停止service stunnel status //查看状态 4：国内服务器配置Stunnel客户端国内服务器，就是在浏览器代理设置中，填入的服务器IP，而端口，则是stunnel接收代理数据的端口。 在服务器提供商网页中的安全组设置里开启stunnel接收数据的端口。 本人使用的阿里云轻量级应用服务器，进入阿里云控制台相应页面后，找到安全组-&gt;防火墙-&gt;添加新规则。在新规则里，开放，TCP协议的3128接口。也可以是其他接口。 配置好安全组后，阿里云服务器本身还有一个防火墙，还需要在服务器里开放3128端口。 查看开放端口，如果没有firewall，请先安装 1firewall-cmd --list-all 设置需要开放的端口 12firewall-cmd --zone=public --add-port=3128/tcp --permanent//设置firewall-cmd --reload//生效 此时再查看开放的端口，就能看到3128端口已开放。 安装stunnel客户端。 ubuntu使用: 1apt-get install stunnel centos使用： 1yum install stunnel 设置stunnel客户端配置文件 1234567891011121314151617181920212223242526; stunnel工作目录,如果没有/var/run/stunnel文件夹，需先创建chroot = /var/run/stunnel/; stunnel工作的用户组setuid = rootsetgid = root; stunnel工作时候的pidpid = /stunnel.pid; 日志等级debug = 7; 日志文件output = /var/log/stunnel/stunnel.log; 表示以client模式启动stunnel，默认client = no，即server模式client = yes; 定义一个服务[squid-proxy]; 监听3128端口，那么用户浏览器的代理设置就是 stunnel-client-ip:3128accept = 3128; 要连接到的stunnel server的ip与端口，修改xx.xx.xx.xx为国外的服务器connect = xx.xx.xx.xx:3129; 需要验证对方发过来的证书verify = 2; 用来进行证书验证的文件（里面有stunnel server的证书）CAfile = /etc/stunnel/stunnel-server.pem; 客户端不需要传递自己的证书，所以注释掉;cert = /etc/stunnel/stunnel.pem;key = /etc/stunnel/stunnel.key 将stunnle公钥证书拷贝一份到stunnel客户端配置文件的指定地址上。 配置文件里CAfile = /etc/stunnel/stunnel-server.pem写明了我们需要将公钥保存的位置和公钥的文件名。 我们只需要将，3.2节生成的证书打开，复制已BEGIN CERTIFICATION开头到END CERTIFICATION结束的公钥。然后，新建/etc/stunnel/stunnel-server.pem文件，将公钥粘贴进去。 这样stunnel客户端就能将数据加密后发送给stunnel服务器了。 启动和停止stunnel 1234service stunnel start &#x2F;&#x2F;开启stunnelservice stunnel restart &#x2F;&#x2F;重启service stunnel stop &#x2F;&#x2F;停止service stunnel status &#x2F;&#x2F;查看状态 5：不足和优化5.1 代理方法的不足 由于客户端的stunnel直接监听3128端口，而没有任何的验证和访问限制，因此，任何知道ip和端口的人都能通过设置代理，使用你的代理接口。 stunnel服务端没有设置对客户端的证书验证，任何通过自建stunnel客户端的人，都有可能使用你的stunnel服务，进行通信。 5.2 优化 配置squid用户授权，即在用户使用代理上网时，弹出输入用户名和密码，输入正确，才能使用squid 修改配置文件/etc/squid/squid.conf，在http_access deny all之前追加以下内容，并注释掉http_access allow localhost 1234567891011121314151617181920# auth_param 设置代理的认证方式# 用法：auth_param scheme parameter [setting]# scheme表示认证机制，squid支持Basic，Digest，NTLM，Negotiate四种认证机制# program 设置认证程序为ncsa_auth（squid自带不少认证程序以及其他拓展程序），程序所需密码文件passwd。。如果linux是32位系统，认证程序/usr/lib/squid/目录下。认证程序名称有可能是basic_ncsa_auth。需要具体打开文件夹后查看。auth_param basic program /usr/lib64/squid/ncsa_auth /etc/squid/passwd# children 设置后台启动几个认证程序进程auth_param basic children 3# credentialsttl 设置认证失效时间，过期后需重新认证auth_param basic credentialsttl 10 hours# realm 设置认证时返回头里夹带的信息“wlecome to using my proxy”auth_param basic realm welecome to using my proxy# ！！！上面只是设置了需要认证，并未将认证生效，还需设置acl与http_access# 添加名为AuthUsers访问列表，表示通过认证的用户acl AuthUsers proxy_auth REQUIRED# 允许AuthUsers的代理请求http_access allow AuthUsers 新建密码文件 1htpasswd -c /etc/squid/passwd qifei 如果没有htpasswd，则按提示安装。输入密码即可。 重启squid 1service squid restart 添加stunnel对客户端的证书验证，需要再新建一个证书文件，同时修改服务端和客户端的配置文件。 6：补充6.1 只能访问谷歌而无法访问YouTube5.30日更新：在经过一段时间的使用后，上种方法存在一些弊端。 在开启代理后，可以访问谷歌，和一些其他外网网站。但是，无法访问youtube、facebook等网站。反复刷新，还是可以访问到youtube。手机上的许多依赖外网的软件比如谷歌商店，无法使用。 利用wireshark对无线网卡进行抓包。发现，在浏览器访问youtube时，浏览器向国内的中转代理服务器，发送了http协议数据。此数据带有明显的请求头urlyoutube.com。猜测可能是国内路由，将含youtube等url的请求头过滤掉了。这样，请求youtube的数据根本无法到达中转服务器。 而多次刷新youtube网站，还是能够连同，说明国内路由并没有完全丢弃youtube请求，而是部分丢弃了我们的请求。 之所以谷歌能完全无阻地接通，我猜测，是因为国内许多网站，有依赖谷歌的各种api，因此屏蔽的损失远大于封锁的损失。因此只在国际出口上，对谷歌进行了封锁，而国内服务器之间的通信没有问题。 查阅https协议的工作原理不难知道。浏览器需要首先使用http协议，向youtube服务器发送请求，youtube服务器返回给浏览器SSL证书公钥，之后浏览器和youtube服务器才会使用SSL加密后的数据进行通讯。 在youtube服务器和浏览器之间添加代理，也只是转发数据，并没有改变浏览器访问youtube服务器时，发送包含包头的http数据的事实。 因此，即便我们在国内stunnel客户端和国外的stunnel客户端之间的数据进行了加密，也无法规避掉浏览器到国内stunnel服务器之间有http请求，造成请求被丢弃的问题。 最好的办法还是，在浏览器所在主机按转stunnel客户端。直接使用stunnel客户端向国外stunnel服务器发送数据，将浏览器的所有出口流量加密，直到发送到国外再解密，并转发。 这样做，其实和使用ss或者ssr原理相同。但是，缺少一些伪装。 5.31日更新：我使用ping.pe网站提供的端口测试，发现，当我访问国内服务器3128端口时，除了中国移动的网络，其他包括中国电信和联通，外网在内的所有运营商均能ping同3128端口。 我猜测可能中国移动会对3128端口进行随机丢包。来阻止squid代理的使用。 我修改了接收代理的端口号。再次在Ping.pe上测试，移动已经能够ping通端口。然而，仍然存在谷歌能够访问，而youtube和fb不能访问的问题。 猜测，可能中国移动会随机丢弃请求地址是youtube的http请求数据。于是我更换了我的联通手机卡，来代理上网。发现谷歌、youtube和其他外网网站，均能很好的访问。我又测试了电信网络，发现结果也是好的。 结论，中国移动，在我们使用代理上网时，会对请求url为youtube.com之类的http请求进行人为随机丢包，而且丢包率极高。预测超过百分之八十。。了解移动国际带宽保有率，不难发现，移动的国际带宽占有率是三大运营商里最低的，却有第二的国际用户。可见为了解决带宽不足问题，他在国内便对youtube流量进行了丢弃，而不是到国际出口再丢弃。。 这么做的好处是，减少了youtube这类在国际出口会被拦截的流量占用传递时的带宽，降低国际出口过滤设备的投入。缺点是，会加大在国内路由过滤设备的投入。 通过对https原理和移动过滤youtube流量的分析，我们应该知道，在使用国内中转方式进行外网访问时，运营商能够知道你正在访问外网。虽然流量流向了国内服务器，如果网警对拦截的流量进行分析，是能够知道你访问了哪些外国网站的。。反向溯源，如果你使用了手机4G网络访问，那么，营运商配合，能够定位到你本人。如果使用wifi访问，能够定位到你的家庭。如果网警查看路由器日志，不难找到，是哪个手机访问了这些外网。 而http请求头中包含的设备信息，比如是什么电脑，浏览器品牌和版本等，无疑降低了找到你的难度。 总的来说，为了网络安全，降低被审查的风险。在本地主机部署stunnel客户端，比在国内服务器中转更加安全。但是长时间的加密连接国外服务器，不难让人猜出，你正在使用vpn之类的软件访问外网。使用wifi的代理比使用手机网络的代理更加安全。 6.2 使用用户名和密码手机软件不能弹出登陆框在实际代理过程中，如果使用wifi或手机网络的软件，无法弹出squid的代理认证框，从而无法输入账号和密码。因此，软件会没办法访问外网，只有浏览器可以访问。 方法1：完全开放代理修改squid.conf关闭用户名和密码验证。允许本地ip登陆。此时所有知道IP和端口的用户都能使用代理访问。。这种方法是极不安全的，因为，有许多爬虫软件，能够通过扫描ip和端口，收集能够使用代理的ip和对应端口。短时间的使用方法一是可以的，但长期下来，容易被攻破。 方法2：IP限制在国内中转服务器上也安装squid。用户连接squid端口，squid将内容发送到中转服务器的stunnel接口，stunnel加密传输到国外，国外服务器，stunnel解密再分发请求。 完整拓扑结构：用户主机-&gt;squid（国内）-&gt;stunnel（国内）-&gt;stunnel（国外）-&gt;squid（国外）-&gt;网站服务器 添加squid的目的是，squid可以验证用户主机ip。通过squid设置能够连接squid的ip池。stunnel是无法验证的。我们之前的用户名和密码验证，是通过国外squid验证的，国外squid无法验证ip，是因为，国外squid接收的信息，全部来自localhost的端口。也就是国外stunnel发出的。 方法3：网页验证加自定义ACL辅助器验证第一次登陆跳转网页验证用户名和密码，之后永久或缓存保存ip，免于此ip验证。 设计思路 用户设置ip和端口，无密码连接代理服务器。 用户打开浏览器，访问任意网页 利用squidSGuard重定向无访问权限ip的访问url，转到认证网页。输入用户名和密码。 网页后台验证用户输入的用户名和密码。并保存用户ip。 编写squid ACL辅助器，读取并验证查找是否有这个ip。存在则通过，不存在，则进行重定向到验证页面。 方法4：自定义验证器加ACL辅助器验证第一次登陆，弹出代理登陆框，通过后保存ip 用户设置ip和端口，连接代理服务器。 代理服务器通过ACL辅助器验证此IP是否在白名单中。 不在白名单则，进入自定义验证器，在，则通过代理。 进入验证器，验证器验证用户名和密码，如果通过，则保存IP到白名单，否则不通过。 我采用方法四进行用户验证，其中蛮多细节，于是另起一文讲解。","categories":[{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Stunnel代理","slug":"Stunnel代理","permalink":"https://sci.ci/tags/Stunnel%E4%BB%A3%E7%90%86/"}]},{"title":"利用Stunnel+Squid代理实现国内无客户端访问外网","slug":"利用Stunnel+squid代理实现国内无客户端访问外网","date":"2020-05-28T21:26:23.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/05/28/利用Stunnel+squid代理实现国内无客户端访问外网/","link":"","permalink":"https://sci.ci/2020/05/28/%E5%88%A9%E7%94%A8Stunnel+squid%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%9B%BD%E5%86%85%E6%97%A0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91/","excerpt":"","text":"1：加速原理1.1 squid介绍squid是一个用于代理的开源软件，用户主机将http请求发送到部署了squid的服务器，squid可以帮助用户转发http请求。利用squid，我们可以让服务器替我们请求数据，再由服务器转发给我们。 按找squid原理，我们就已经可以进行翻墙了，在国内能够访问的国外服务器上部署squid，将访问谷歌的请求发送给squid，squid替我们请求谷歌数据，再将谷歌数据转发给我们。这就是一个完整的工作过程。 但是由于squid请求报头未加密，在squid服务器向浏览器返回数据时，能够被GFW检测到访问数据来自于谷歌。从而将返回数据过滤掉。之后通过squid返回的数据，都会被GFW过滤掉，即使我们访问的是百度，也会无法收到返回数据。 1.2 Https介绍这篇文章详细介绍了加密的原理：https://blog.csdn.net/clh604/article/details/22179907 1.3 stunnel介绍stunnel是一个开源软件，使用stunnel可以为我们使用tcp协议传输的数据使用SSL协议加密，这样我们的请求，除了客户端和服务器，其他人将无法从数据中提取到有用信息。 为了让GFW无法识别出主机访问谷歌和返回的数据来自谷歌。这里使用stunnel将主机和squid之间的通信数据加密，将http请求的报头也加密。 1.4 代理过程在windows主机上设置全局代理，将windows的tcp请求，转发到国内服务器server 1上，国内服务器server 1与国外服务器server 2搭建stunnel加密隧道连接，国外服务器server 2利用squid，发送主机的访问请求，并将访问结果返回给server 1，server 1在发送给主机浏览器。加速原理如下图。 通常可以只利用一个国外服务器，在国外服务器上部署stunnel和squid，在本地主机上搭建stunnel客户端就可以了。如下图 但是，为了访问方便，即任何用户只需要设置windows上现有的代理服务器就能访问外网，而不需要下载stunnel客户端和配置客户端参数。 相比于主机使用Stunnel客户端，将stunnel客户端部署到国内服务器的缺点是：这需要国内外均有服务器。成本会更高。 更重要的是，我们与国内服务器之间的信息被抓取后，能够获取到我们访问的信息，比如是谷歌、使用的浏览器版本等，但是无法知道具体访问内容。由于是与国内服务器发送信息，因此被探测的几率很小。 2：主机设置代理访问为了让阅读本文的读者，提前的看到成果，将server1和server2都配置好后，先介绍如何利用你搭建好的服务器访问外网。 打开代理服务器色设置 在代理服务器上输入国内服务器server1的IP和stunnel客户端监听的端口号。 使用浏览器登陆google 实际上使用就是这么简单。当然为了你搭建的隧道不会被其他人使用，你也可以对能够访问这条隧道的IP进行限制，或者设置一个密码。会在后续中介绍到。 3：国外服务器配置确保在服务商安全组里开放了3128和3129端口，这两个端口，将用于接收和转发数据。 3.1 安装配置Squid 安装squid ubuntu使用： 1apt-get install squid centos使用： 1yum install squid 使用squid -v检查squid是否安装好。 配置squid 打开squid配置文件/etc/squid/squid.conf。没有就新建此文件 将文件内容修改为： 1234567891011121314151617181920212223242526272829303132333435363738# http_port 设置监听端口，默认为3128http_port 3128# access_log 设置access日志，daemon表示在后台将日志写入/var/log/squid/access.log文件, # combined是一个预定义的logformat，也可以使用自定义的logformataccess_log daemon:/var/log/squid/access.log combined# visible_hotname 设置代理服务器的主机名# 默认取本机的hostnamevisible_hostname funway.aliyun.proxy# ACLs all, manager, localhost, and to_localhost are predefined.acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT# 拒绝所有非Safe_ports的请求http_access deny !Safe_ports# 拒绝所有非SSL_prots的CONNECT请求http_access deny CONNECT !SSL_ports# Only allow cachemgr access from localhosthttp_access allow localhost managerhttp_access deny manager# 允许来自本地的请求http_access allow localhost# 拒绝所有请求，最后兜底的规则http_access deny all 更多详细的配置参数解释，请参考博文《使用squid搭建代理服务器》 配置squid只能本地地址访问。 运行squid 12service squid start //运行service squid status //查看squid运行状态 3.2 安装配置stunnel服务端 生成自签名证书，如果没有openssl需要先安装。 1openssl req -new -x509 -days 3650 -nodes -out stunnel.pem -keyout stunnel.pem 将生成的证书，复制到/etc/stunnel文件夹下 1cp stunnel.pem /etc/stunnel 这个证书还需要下载到主机，之后上传到国内服务器，用于为stunnle客户端设置的公钥。 下载安装stunnel 1apt-get install stunnel 设置stunnel配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849; 设置工作目录，没有目录需要先创建chroot = /var/run/stunnel/; 设置stunnel的pid文件路径（在chroot下）pid = /stunnel.pid; 设置stunnel工作的用户（组）setuid = rootsetgid = root; 开启日志等级：emerg (0), alert (1), crit (2), err (3), warning (4), notice (5), info (6), or debug (7); 默认为5debug = 7; 日志文件路径（我的server的版本有个bug，这个文件也被放在chroot路径下了，client的版本则是独立的=。=#）output = /stunnel.log; 证书文件，就是在本文2.2中用openssl生成的自签名证书（server端必须设置这两项）cert = /etc/stunnel/stunnel.pem; 私钥文件key = /etc/stunnel/stunnel.pem; 设置stunnel服务，可以设置多个服务，监听同的端口，并发给不同的server。; 自定义服务名squid-proxy[squid-proxy]; 服务监听的端口，client要连接这个端口与server通信accept = 3129; 服务要连接的端口，连接到squid的3128端口，将数据发给squidconnect = localhost:3128; **************************************************************************; * 下面这些配置我都注释掉了，但也需要了解下 *; **************************************************************************; 设置是否对传输数据进行压缩，默认不开启。; 这是跟openssl相关的，如果你的openssl没有zlib，开启这个设置会导致启动失败（failed to initialize compression method）;compression = zlib; 设置ssl版本,这个也是跟安装的openssl有关的;sslVersion = TLSv1; Authentication stuff needs to be configured to prevent MITM attacks; It is important to understand that this option was solely designed for access control and not for authorization; It is not enabled by default!; 下面这些配置用来定义是否信任对方发过来的证书。就好比浏览器访问https的时候，浏览器默认会信任那些由权威CA机构签发的证书，; 对于那些自签名证书，浏览器就会弹出对话框提醒用户这个证书可能不安全，是否要信任该证书。; 这是有效防止中间人攻击的手段; verify 等级2表示需要验证对方发过来的证书（默认0，不需要验证，都信任）; 因为这个配置是server端的，我们不需要理会client的证书（client也不会没事发证书过来啦）;verify = 2; CAfile 表示受信的证书文件，即如果对方发过来的证书在这个CAfile里，那么就是受信任的证书；否则不信任该证书，断开连接。;CAfile = /etc/stunnel/stunnel-client.pem 启动停止stunnel 1234service stunnel start //开启stunnelservice stunnel restart //重启service stunnel stop //停止service stunnel status //查看状态 4：国内服务器配置Stunnel客户端国内服务器，就是在浏览器代理设置中，填入的服务器IP，而端口，则是stunnel接收代理数据的端口。 在服务器提供商网页中的安全组设置里开启stunnel接收数据的端口。 本人使用的阿里云轻量级应用服务器，进入阿里云控制台相应页面后，找到安全组-&gt;防火墙-&gt;添加新规则。在新规则里，开放，TCP协议的3128接口。也可以是其他接口。 配置好安全组后，阿里云服务器本身还有一个防火墙，还需要在服务器里开放3128端口。 查看开放端口，如果没有firewall，请先安装 1firewall-cmd --list-all 设置需要开放的端口 12firewall-cmd --zone=public --add-port=3128/tcp --permanent//设置firewall-cmd --reload//生效 此时再查看开放的端口，就能看到3128端口已开放。 安装stunnel客户端。 ubuntu使用: 1apt-get install stunnel centos使用： 1yum install stunnel 设置stunnel客户端配置文件 1234567891011121314151617181920212223242526; stunnel工作目录,如果没有/var/run/stunnel文件夹，需先创建chroot = /var/run/stunnel/; stunnel工作的用户组setuid = rootsetgid = root; stunnel工作时候的pidpid = /stunnel.pid; 日志等级debug = 7; 日志文件output = /var/log/stunnel/stunnel.log; 表示以client模式启动stunnel，默认client = no，即server模式client = yes; 定义一个服务[squid-proxy]; 监听3128端口，那么用户浏览器的代理设置就是 stunnel-client-ip:3128accept = 3128; 要连接到的stunnel server的ip与端口，修改xx.xx.xx.xx为国外的服务器connect = xx.xx.xx.xx:3129; 需要验证对方发过来的证书verify = 2; 用来进行证书验证的文件（里面有stunnel server的证书）CAfile = /etc/stunnel/stunnel-server.pem; 客户端不需要传递自己的证书，所以注释掉;cert = /etc/stunnel/stunnel.pem;key = /etc/stunnel/stunnel.key 将stunnle公钥证书拷贝一份到stunnel客户端配置文件的指定地址上。 配置文件里CAfile = /etc/stunnel/stunnel-server.pem写明了我们需要将公钥保存的位置和公钥的文件名。 我们只需要将，3.2节生成的证书打开，复制已BEGIN CERTIFICATION开头到END CERTIFICATION结束的公钥。然后，新建/etc/stunnel/stunnel-server.pem文件，将公钥粘贴进去。 这样stunnel客户端就能将数据加密后发送给stunnel服务器了。 启动和停止stunnel 1234service stunnel start &#x2F;&#x2F;开启stunnelservice stunnel restart &#x2F;&#x2F;重启service stunnel stop &#x2F;&#x2F;停止service stunnel status &#x2F;&#x2F;查看状态 5：不足和优化5.1 代理方法的不足 由于客户端的stunnel直接监听3128端口，而没有任何的验证和访问限制，因此，任何知道ip和端口的人都能通过设置代理，使用你的代理接口。 stunnel服务端没有设置对客户端的证书验证，任何通过自建stunnel客户端的人，都有可能使用你的stunnel服务，进行通信。 5.2 优化 配置squid用户授权，即在用户使用代理上网时，弹出输入用户名和密码，输入正确，才能使用squid 修改配置文件/etc/squid/squid.conf，在http_access deny all之前追加以下内容，并注释掉http_access allow localhost 1234567891011121314151617181920# auth_param 设置代理的认证方式# 用法：auth_param scheme parameter [setting]# scheme表示认证机制，squid支持Basic，Digest，NTLM，Negotiate四种认证机制# program 设置认证程序为ncsa_auth（squid自带不少认证程序以及其他拓展程序），程序所需密码文件passwd。。如果linux是32位系统，认证程序/usr/lib/squid/目录下。认证程序名称有可能是basic_ncsa_auth。需要具体打开文件夹后查看。auth_param basic program /usr/lib64/squid/ncsa_auth /etc/squid/passwd# children 设置后台启动几个认证程序进程auth_param basic children 3# credentialsttl 设置认证失效时间，过期后需重新认证auth_param basic credentialsttl 10 hours# realm 设置认证时返回头里夹带的信息“wlecome to using my proxy”auth_param basic realm welecome to using my proxy# ！！！上面只是设置了需要认证，并未将认证生效，还需设置acl与http_access# 添加名为AuthUsers访问列表，表示通过认证的用户acl AuthUsers proxy_auth REQUIRED# 允许AuthUsers的代理请求http_access allow AuthUsers 新建密码文件 1htpasswd -c /etc/squid/passwd qifei 如果没有htpasswd，则按提示安装。输入密码即可。 重启squid 1service squid restart 添加stunnel对客户端的证书验证，需要再新建一个证书文件，同时修改服务端和客户端的配置文件。 6：问题和调试6.1 国内squid能接通，但无法访问网络这可能是服务器端口没开 1http:&#x2F;&#x2F;port.ping.pe&#x2F;xx.xx.xx.xx:port 将上述网址，修改ip地址和端口后，通过浏览器打开，看看服务器端口是否能够接通，如果显示failed，那么参照第四章内容，安装firewald，并打开对应端口。 6.2 中国移动只能访问谷歌而无法访问YouTube5.30日更新：在经过一段时间的使用后，上种方法存在一些弊端。 在开启代理后，可以访问谷歌，和一些其他外网网站。但是，无法访问youtube、facebook等网站。反复刷新，还是可以访问到youtube。手机上的许多依赖外网的软件比如谷歌商店，无法使用。 利用wireshark对无线网卡进行抓包。发现，在浏览器访问youtube时，浏览器向国内的中转代理服务器，发送了http协议数据。此数据带有明显的请求头urlyoutube.com。猜测可能是国内路由，将含youtube等url的请求头过滤掉了。这样，请求youtube的数据根本无法到达中转服务器。 而多次刷新youtube网站，还是能够连同，说明国内路由并没有完全丢弃youtube请求，而是部分丢弃了我们的请求。 之所以谷歌能完全无阻地接通，我猜测，是因为国内许多网站，有依赖谷歌的各种api，因此屏蔽的损失远大于封锁的损失。因此只在国际出口上，对谷歌进行了封锁，而国内服务器之间的通信没有问题。 查阅https协议的工作原理不难知道。浏览器需要首先使用http协议，向youtube服务器发送请求，youtube服务器返回给浏览器SSL证书公钥，之后浏览器和youtube服务器才会使用SSL加密后的数据进行通讯。 在youtube服务器和浏览器之间添加代理，也只是转发数据，并没有改变浏览器访问youtube服务器时，发送包含包头的http数据的事实。 因此，即便我们在国内stunnel客户端和国外的stunnel客户端之间的数据进行了加密，也无法规避掉浏览器到国内stunnel服务器之间有http请求，造成请求被丢弃的问题。 最好的办法还是，在浏览器所在主机按转stunnel客户端。直接使用stunnel客户端向国外stunnel服务器发送数据，将浏览器的所有出口流量加密，直到发送到国外再解密，并转发。 这样做，其实和使用ss或者ssr原理相同。但是，缺少一些伪装。 5.31日更新：我使用ping.pe网站提供的端口测试，发现，当我访问国内服务器3128端口时，除了中国移动的网络，其他包括中国电信和联通，外网在内的所有运营商均能ping同3128端口。 我猜测可能中国移动会对3128端口进行随机丢包。来阻止squid代理的使用。 我修改了接收代理的端口号。再次在Ping.pe上测试，移动已经能够ping通端口。然而，仍然存在谷歌能够访问，而youtube和fb不能访问的问题。 猜测，可能中国移动会随机丢弃请求地址是youtube的http请求数据。于是我更换了我的联通手机卡，来代理上网。发现谷歌、youtube和其他外网网站，均能很好的访问。我又测试了电信网络，发现结果也是好的。 结论，中国移动，在我们使用代理上网时，会对请求url为youtube.com之类的http请求进行人为随机丢包，而且丢包率极高。预测超过百分之八十。。了解移动国际带宽保有率，不难发现，移动的国际带宽占有率是三大运营商里最低的，却有第二的国际用户。可见为了解决带宽不足问题，他在国内便对youtube流量进行了丢弃，而不是到国际出口再丢弃。。 这么做的好处是，减少了youtube这类在国际出口会被拦截的流量占用传递时的带宽，降低国际出口过滤设备的投入。缺点是，会加大在国内路由过滤设备的投入。 通过对https原理和移动过滤youtube流量的分析，我们应该知道，在使用国内中转方式进行外网访问时，运营商能够知道你正在访问外网。虽然流量流向了国内服务器，如果网警对拦截的流量进行分析，是能够知道你访问了哪些外国网站的。。反向溯源，如果你使用了手机4G网络访问，那么，营运商配合，能够定位到你本人。如果使用wifi访问，能够定位到你的家庭。如果网警查看路由器日志，不难找到，是哪个手机访问了这些外网。 而http请求头中包含的设备信息，比如是什么电脑，浏览器品牌和版本等，无疑降低了找到你的难度。 总的来说，为了网络安全，降低被审查的风险。在本地主机部署stunnel客户端，比在国内服务器中转更加安全。但是长时间的加密连接国外服务器，不难让人猜出，你正在使用vpn之类的软件访问外网。使用wifi的代理比使用手机网络的代理更加安全。 6.3 使用用户名和密码手机软件不能弹出登陆框在实际代理过程中，如果使用wifi或手机网络的软件，无法弹出squid的代理认证框，从而无法输入账号和密码。因此，软件会没办法访问外网，只有浏览器可以访问。 方法1：完全开放代理修改squid.conf关闭用户名和密码验证。允许本地ip登陆。此时所有知道IP和端口的用户都能使用代理访问。。这种方法是极不安全的，因为，有许多爬虫软件，能够通过扫描ip和端口，收集能够使用代理的ip和对应端口。短时间的使用方法一是可以的，但长期下来，容易被攻破。 方法2：IP限制在国内中转服务器上也安装squid。用户连接squid端口，squid将内容发送到中转服务器的stunnel接口，stunnel加密传输到国外，国外服务器，stunnel解密再分发请求。 完整拓扑结构：用户主机-&gt;squid（国内）-&gt;stunnel（国内）-&gt;stunnel（国外）-&gt;squid（国外）-&gt;网站服务器 添加squid的目的是，squid可以验证用户主机ip。通过squid设置能够连接squid的ip池。stunnel是无法验证的。我们之前的用户名和密码验证，是通过国外squid验证的，国外squid无法验证ip，是因为，国外squid接收的信息，全部来自localhost的端口。也就是国外stunnel发出的。 方法3：网页验证加自定义ACL辅助器验证第一次登陆跳转网页验证用户名和密码，之后永久或缓存保存ip，免于此ip验证。 设计思路 用户设置ip和端口，无密码连接代理服务器。 用户打开浏览器，访问任意网页 利用squidSGuard重定向无访问权限ip的访问url，转到认证网页。输入用户名和密码。 网页后台验证用户输入的用户名和密码。并保存用户ip。 编写squid ACL辅助器，读取并验证查找是否有这个ip。存在则通过，不存在，则进行重定向到验证页面。 方法4：自定义验证器加ACL辅助器验证第一次登陆，弹出代理登陆框，通过后保存ip 用户设置ip和端口，连接代理服务器。 代理服务器通过ACL辅助器验证此IP是否在白名单中。 不在白名单则，进入自定义验证器，在，则通过代理。 进入验证器，验证器验证用户名和密码，如果通过，则保存IP到白名单，否则不通过。 我采用方法四进行用户验证，其中蛮多细节，于是另起一文讲解。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"}],"tags":[{"name":"Stunnel","slug":"Stunnel","permalink":"https://sci.ci/tags/Stunnel/"},{"name":"Squid","slug":"Squid","permalink":"https://sci.ci/tags/Squid/"}]},{"title":"亚琛工大教学视频添加中德字幕","slug":"亚琛工大教学视频添加中德字幕","date":"2020-05-27T20:02:51.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/05/27/亚琛工大教学视频添加中德字幕/","link":"","permalink":"https://sci.ci/2020/05/27/%E4%BA%9A%E7%90%9B%E5%B7%A5%E5%A4%A7%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E6%B7%BB%E5%8A%A0%E4%B8%AD%E5%BE%B7%E5%AD%97%E5%B9%95/","excerpt":"","text":"第一章 插件用户手册1.1 适用场景和功能说明 本插件适用于基于chromium内核开发的浏览器，包括Chrome浏览器、360安全浏览器、QQ浏览器等。 插件只在满足https://*/rwth-aachen.de/*域名匹配时工作，且除了添加字幕外无其他功能。 支持德语、中文、双语字幕 插件只能为数据库里存在的视频资源添加字幕。更多视频字幕，会逐渐上传。 1.2 效果图预览以下仅展示了双语字幕。 1.3 插件安装 下载插件https://lanzous.com/ick15oh 解压插件到桌面。获得以captions-for-moodle为名的文件夹。 打开chrome浏览器，依次点击右上角的三个点图标—&gt;更多工具—&gt;扩展程序。或者在地址栏输入chrome://extensions/以打开扩展程序。 单击打开扩展程序右上角的开发者选项。 然后开发者模式下方将出现加载已解压的扩展程序。 点击加载已解压的扩展程序，在弹出页面，选择名称为captions-for-moodle文件夹。点击选择文件夹。此时页面出现Captions for Moodle RWTH 1.0插件。 至此插件安装完成，确认插件卡片里的选择按钮为蓝色，表示插件已激活。插件激活后，在浏览器右上角，将出现RWTH的图标。 且当你打开，moodle.rwth-aachen.de时，页面出现绿色浮动按钮。 1.4 插件使用 打开moodle课程视频页面，页面出现绿色悬浮按钮。 点击播放视频，直到视频加载成功且开始播放，单击绿色悬浮按钮，！重要，等待几秒钟。待字幕下载完毕，会自动加载到视频上。 下载完毕的字幕，默认为德语字幕，再次单击绿色按钮，切换中文字幕；再次单击，切换双语字幕；再次单击清除字幕。依次循环。 若当前视频还没有上传字幕，视频字幕会显示 在出现此字幕时，单击三次按钮，即此清除字幕或当视频播放到两分钟时自动清除。 下载字幕到本地 如果当前视频存在字幕，待页面加载完毕后，点击浏览器右上角插件图标，即可看到字幕下载链接和视频下载链接。 1.5 其他说明目前已支持的课程有 Bioenergie Grundoperationen der Energietechnik (VO) Petrochemie und Raffinerietechnik (VU) 待添加 第二章 教学视频下载和字幕转换2.1 系统要求和网络要求插件用户安装我提供的视频下载和字幕转换工具。插件没提供的字幕，用户可自行本地转换，字幕转换成功后，可通过上传接口，将转换的字幕共享给每一位使用插件的用户。 系统要求 此教程仅适用于windows系统，若有需求，后续可出Ubuntu系统教程。Mac系统暂不支持。 网络要求⭐ 软件的安装需要连接外网！ 视频下载不需要连接外网！ 生成字幕需连接外网！字幕转换将请求谷歌的文字翻译API接口。请确保你在进行本章第5节内容，即获取字幕时，满足以下两种条件： 用户电脑网络处于除中国大陆以外的地区。 用户连接网速较好的VPN网络。注意：VPN网络不佳，将使字幕转换出现中断。 2.2 软件环境搭建 打开命令管理器。 打开windows桌面右上角搜索功能 在搜索框输入cmd，并点击“以管理员身份运行”。 打开后如图。注意：命令行开头是：C:\\WINDOWS\\system32 安装包管理器chocolatey 复制以下指令 1@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;chocolatey.org&#x2F;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH&#x3D;%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; ⭐⭐⭐温馨提示：命令提示符里，使用右键单击即可复制和粘贴！ 在命令框里，右键单击。如图，然后回车运行。等待安装完成。 通常，未出现红色提示，则表示安装成功。 当然为了确保成功安装，你可以通过在命令提示符里输入指令，注意V是大写 1choco -V 输出绿色版本号。则安装成功，例如:0.10.15。 安装 git python curl ffmpeg。 1choco install git python curl ffmpeg -y 此安装过程较长，且取决于你当前所处网络环境。请耐心等待，保持电脑激活状态。 安装过程中，未提示红色字体，则表示安装成功。 ⭐⭐安装完成后，退出cmd，重新用管理员权限打开，以刷新git、python等的环境变量。 可选：你可通过分别输入git --version，python -V,curl -V，ffmpeg -V。依次查看这几个软件是否安装成功，若出现版本号则表示安装成功。 如果某个程序没有安装上，比如python，你可单独使用指令 choco install python -y来安装。安装完成后需重启cmd，才能使用python -V指令查看版本信息。 下载python程序并安装，⭐此步骤需要连接外网，否则会报错 12python get-pip.pypip install git+https:&#x2F;&#x2F;github.com&#x2F;BingLingGroup&#x2F;autosub.git@alpha ffmpeg-normalize langcodes 安装成功。输入指令 1autosub -V 显示版本号，则安装成功。 若出现错误提示如下图 可能是你系统的未安装Microsoft Visual C++ 14.0。 打开连接 https://964279924.ctfile.com/fs/1445568-239446865 下载安装VC++**。安装后，重复第4步**。 2.3 获得视频地址视频下载地址，将在第一章，1.4节插件使用中有详细介绍。 在打开视频地址后，点击右上角插件图标，即可看到视频下载地址的url。 2.4 下载视频如果你需要转换字幕，请跳过此节，下节内容，将包括视频的下载和字幕转换。 如果你只想下载视频，而不需要转换字幕，请看此章。 你已经安装了第二节提供的软件，并在第三节获取到了视频的下载地址，那么在这节，你将知道，如何利用ffmpeg工具，将m3u8文件转为mp4格式视频。关于m3u8文件，可看本节补充说明。 打开命令提示符，无需用管理员权限打开！在搜索栏输入cmd。双击打开。 复制以下代码，在cmd窗口右键单击，然后回车运行。 1cd %USERPROFILE%\\Desktop &amp;&amp; curl -O https:&#x2F;&#x2F;gitee.com&#x2F;xieqifei&#x2F;captions_for_moodle&#x2F;raw&#x2F;master&#x2F;getcaptions.bat &amp;&amp; call getcaptions.bat 在选择操作时，输入2：网络下载视频，但不生成字幕， 在输入视频的网络地址里，输入2.3节获取的，以.m3u8结尾的链接。然后回车 输入保存视频和字幕的地址，这里直接回车，将字幕保存到桌面。此时，软件开始工作。 补充说明：m3u8是一个视频片段的地址列表，利用视频处理工具，读取这个地址表，将切割成片段的ts格式视频拼接成一个ts格式视频，在将ts格式视频转化为mp4格式。 2.5 转换字幕和上传字幕⭐请注意，执行本节内容之前，请确保，你的网络已连接外网，并且能打开https://www.google.com，否则将无法进行字幕转换操作。 字幕上传功能，仅在你使用此脚本的选项“网络下载视频，并生成中德字幕”时启用。 搜索并打开cmd命令提示符 输入以下命令，下载并执行批处理脚本 1cd %USERPROFILE%\\Desktop &amp;&amp; curl -O https://gitee.com/xieqifei/captions_for_moodle/raw/master/getcaptions.bat &amp;&amp; call getcaptions.bat 按照提示开始选择指令。直接回车。选择1：网络下载视频，并生成中德字幕。 填写视频的下载链接，参照第三节内容，复制第三节获取到的视频链接。直接在cmd窗口上右键单击，即可粘贴。 链接例子：https://streaming.rwth-aachen.de/rwth/smil:engage-player_0fe26b35-3e44-47f0-acf6-a9c4fd05b0bc_presentation.smil/playlist.m3u8 填写视频和字幕的保存地址。直接回车，默认保存到桌面。 程序将自动开始运行，现在，你可以去泡杯茶，等待视频和字幕转换完成。 字幕转换完成，检查字幕文件是否正确无误，然后继续回车上传字幕。 出现字幕上传成功字样，则字幕已更新至服务器，可通过插件在线给视频添加字幕，其他用户也可以点击右上角插件按钮下载字幕。 下次运行脚本，可以直接在桌面双击打开getcaptions.bat文件,而无需再次下载此脚本。若脚本有更新，可执行步骤2的代码。","categories":[{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://sci.ci/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]},{"title":"ShopXO商城优化-商城后台、小程序、飞鹅订单打印、公众号新订单推送","slug":"ShopXO商城优化商品价格修改","date":"2020-05-26T09:40:33.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/05/26/ShopXO商城优化商品价格修改/","link":"","permalink":"https://sci.ci/2020/05/26/ShopXO%E5%95%86%E5%9F%8E%E4%BC%98%E5%8C%96%E5%95%86%E5%93%81%E4%BB%B7%E6%A0%BC%E4%BF%AE%E6%94%B9/","excerpt":"","text":"1：内容梗概ShopXO是款非常优秀的开源商城软件。为了让商城更加适合没有网站管理经验的人使用，我优化了手机和电脑端的商城后台。修复了小程序的一些BUG，并做了一些其他优化。使用飞鹅打印机，接收新订单推送通知和订单打印。利用微信认证的公众号，在有新订单时，通过公众号给微信推送新订单消息。 特别说明：此篇文章建议有一定前后端基础的朋友阅读，否则，你在按照本文修改你的网站时，可能由于我在写作时，将某个环节遗漏，而导致你的网站无法做到像我修改后一样的结果。此时，会得不偿失。同时，若你对本文内容有任何疑问，欢迎你通过邮箱与我联系。邮箱几乎每天一看。 在进行下面修改时，建议你先将你的网站压缩打包，保存一下。避免操作失误无法修复。如果你的修改在达到理想效果后，建议你都进行一下保存操作 2：商城后台优化2.1 优化说明 优化说明： 手机端显示商品缩率图 直接点击价格，弹出价格修改框，快速改价。 隐藏“查看更多”按钮。（给缩略图让空间） 对比： 优化后点击商品价格改价： 2.2 优化工作 首先在手机端显示缩率图和价格。隐藏查看更多。 核心代码：替换原有的价格显示样式，并添加一个js控制的弹窗。 1234567891011121314151617181920&lt;td &gt; &lt;button class&#x3D;&quot;am-btn am-btn-success price-changed am-btn-xs am-radius&quot; data-id&#x3D;&quot;&#123;&#123;$v.id&#125;&#125;&quot; data-url&#x3D;&quot;&#123;&#123;:MyUrl(&#39;admin&#x2F;goods&#x2F;pricechanged&#39;)&#125;&#125;&quot; id&#x3D;&quot;doc-prompt-toggle&#123;&#123;$v.id&#125;&#125;&quot; &gt;&#123;&#123;$v.price&#125;&#125;&lt;&#x2F;button&gt; &lt;div class&#x3D;&quot;am-modal am-modal-prompt&quot; tabindex&#x3D;&quot;-1&quot; id&#x3D;&quot;my-prompt&#123;&#123;$v.id&#125;&#125;&quot;&gt; &lt;div class&#x3D;&quot;am-modal-dialog&quot;&gt; &lt;div class&#x3D;&quot;am-modal-hd&quot;&gt;&#123;&#123;$v.title&#125;&#125;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;am-modal-bd&quot;&gt; &lt;img src&#x3D;&quot;&#123;&#123;$v[&#39;images&#39;]&#125;&#125;&quot; class&#x3D;&quot;am-radius&quot; style&#x3D;&quot;width:100%&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;number&quot; class&#x3D;&quot;am-modal-prompt-input&quot; pattern&#x3D;&quot;^([0-9]&#123;1&#125;\\d&#123;0,6&#125;)(\\.\\d&#123;1,2&#125;)?$&quot; data-validation-message&#x3D;&quot;请填写有效的销售金额&quot; placeholder&#x3D;&quot;&#123;&#123;$v.price&#125;&#125;&quot;&gt;元 &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;am-modal-footer&quot;&gt; &lt;span class&#x3D;&quot;am-modal-btn&quot; data-am-modal-cancel&gt;取消&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;am-modal-btn&quot; data-am-modal-confirm&gt;提交&lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &#123;&#123;if !empty($v[&#39;original_price&#39;]) and $v[&#39;original_price&#39;] gt 0&#125;&#125; &lt;br &#x2F;&gt;&lt;span class&#x3D;&quot;am-badge am-radius&quot;&gt;原价 &#123;&#123;$v.original_price&#125;&#125;&lt;&#x2F;span&gt; &#123;&#123;&#x2F;if&#125;&#125;&lt;&#x2F;td&gt; 完整index.html代码链接：https://github.com/xieqifei/shopxo/blob/master/application/admin/view/default/goods/index.html 将此链接中的代码下载下来，替换原后台商品管理的html代码。替换你的网站根目录/application/admin/view/default/goods/index.html。 修改js文件，实现点击价格，弹出对话框，提交发送post请求修改数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * [doc-prompt-toggle 价格修改弹窗] * @author Qifei * @blog https://sci.ci/ * @version 0.0.1 * @datetime 2020-05-25T14:22:39+0800 * @param &#123;[int] [data-id] [数据id]&#125; * @param &#123;[int] [data-field][数据库内容]&#125; * @param &#123;[string] [data-url] [请求地址]&#125; */ $(document).on(&#x27;click&#x27;,&#x27;.price-changed&#x27;, function() &#123; var tag = $(this); var id = tag.attr(&#x27;data-id&#x27;); var $my_prompt=&#x27;#my-prompt&#x27;+id; var url = tag.attr(&#x27;data-url&#x27;); var field = tag.attr(&#x27;data-field&#x27;) || &#x27;&#x27;; $($my_prompt).modal(&#123; relatedElement: this, onConfirm: function(data) &#123; //获取input标签中的value值 price=data[&#x27;data&#x27;]; if(id == undefined || url == undefined) &#123; Prompt(&#x27;参数配置有误&#x27;); return false; &#125; // 请求更新数据 $.ajax(&#123; url:url, type:&#x27;POST&#x27;, dataType:&quot;json&quot;, timeout:tag.attr(&#x27;data-timeout&#x27;) || 30000, data:&#123;&quot;id&quot;:id, &quot;price&quot;:price, &quot;field&quot;:field&#125;, success:function(result) &#123; if(result.code == 0) &#123; Prompt(result.msg, &#x27;success&#x27;); // 成功则更新价格 tag.html(price); &#125; else &#123; Prompt(result.msg); &#125; &#125;, error:function(xhr, type) &#123; Prompt(&#x27;网络异常出错&#x27;); &#125; &#125;); &#125;, onCancel: function() &#123; &#125; &#125;); &#125;); 以上代码加入到common.js文件中，或者下载我的commonjs完全替换这个文件 替换你的网站/public/static/common/js/common.js 完整代码：https://github.com/xieqifei/shopxo/blob/master/public/static/common/js/common.js 在Goods控制器里新建一个控制器函数PriceChanged()。实现接收POST数据。 在application/admin/controller/Goods.php里添加下面的代码。或者完全替换为我的Goods.php。 12345678910111213141516171819202122232425/** * [PriceChanged 修改商品价格] * @author Qifei * @blog https://sci.ci/ * @version 0.0.1 * @datetime 2020-05-25T22:23:06+0800 */ public function PriceChanged()&#123; // 是否ajax if(!IS_AJAX) &#123; return $this-&gt;error(&#x27;非法访问&#x27;); &#125; $filename=&quot;a.txt&quot;; $handle=fopen($filename,&quot;a+&quot;); $str=fwrite($handle,&quot;test\\n&quot;); fclose($handle); // 开始操作 $params = input(&#x27;post.&#x27;); $params[&#x27;admin&#x27;] = $this-&gt;admin; $params[&#x27;field&#x27;] = &#x27;price&#x27;; //调用商品管理服务，更新数据库。 return GoodsService::GoodsPriceUpdate($params);&#125; 替换你的网站/application/admin/controller/Goods.php 完整的Goods.php代码：https://github.com/xieqifei/shopxo/blob/master/application/admin/controller/Goods.php 在商品后台服务中添加更新价格的服务函数 将以下代码添加到你的网站/application/service/GoodsService.php,或者下载我的GoodsService.php文件，完全替换它。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 修改商品价格 * @author Qifei * @blog https://sci.ci/ * @version 1.0.0 * @date 2020-05-25 * @desc description * @param [int] $goods_id [商品id] */ public static function GoodsPriceUpdate($params = []) &#123; // 请求参数 $p = [ [ &#x27;checked_type&#x27; =&gt; &#x27;empty&#x27;, &#x27;key_name&#x27; =&gt; &#x27;id&#x27;, &#x27;error_msg&#x27; =&gt; &#x27;操作id有误&#x27;, ], [ &#x27;checked_type&#x27; =&gt; &#x27;empty&#x27;, &#x27;key_name&#x27; =&gt; &#x27;field&#x27;, &#x27;error_msg&#x27; =&gt; &#x27;未指定操作字段&#x27;, ], [//价格在0到5000这个区间 &#x27;checked_type&#x27; =&gt; &#x27;between&#x27;, &#x27;key_name&#x27; =&gt; &#x27;price&#x27;, &#x27;checked_data&#x27; =&gt; [0,5000], &#x27;error_msg&#x27; =&gt; &#x27;价格不能小于0，大于5000&#x27;, ], ]; $ret = ParamsChecked($params, $p); if($ret !== true) &#123; return DataReturn($ret, -1); &#125; // 数据更新 if(Db::name(&#x27;Goods&#x27;)-&gt;where([&#x27;id&#x27;=&gt;intval($params[&#x27;id&#x27;])])-&gt;update([$params[&#x27;field&#x27;]=&gt;number_format($params[&#x27;price&#x27;],2),&#x27;min_price&#x27;=&gt;number_format($params[&#x27;price&#x27;],2),&#x27;max_price&#x27;=&gt;number_format($params[&#x27;price&#x27;],2), &#x27;upd_time&#x27;=&gt;time()])&amp;&amp;Db::name(&#x27;GoodsSpecBase&#x27;)-&gt;where([&#x27;goods_id&#x27;=&gt;intval($params[&#x27;id&#x27;])])-&gt;update([$params[&#x27;field&#x27;]=&gt;number_format($params[&#x27;price&#x27;],2)])) &#123; return DataReturn(&#x27;操作成功&#x27;); &#125; return DataReturn(&#x27;操作失败&#x27;, -100); &#125; 完整GoodsService.php地址：https://github.com/xieqifei/shopxo/blob/master/application/service/GoodsService.php 替换你的网站/application/service/GoodsService.php 最后，你需要给新的控制器方法添加访问数据库权限。 打开ShopXO网站后台你的网站网址/admin.php 添加权限： 点击保存。至此商品后台优化已经完成。 3：WX小程序优化3.1 优化说明 优化内容： 修改首页导航栏上传图片，显示太小 修改分类无法查看一级分类。 修改前后对比 3.2 优化工作 导航栏修改 打开小程序源代码，找到components-&gt;icon-nav 替换icon-nav.wxml内容为： 12345678910111213&lt;view wx:if=&quot;&#123;&#123;propData.length &gt; 0&#125;&#125;&quot;&gt; &lt;view class=&quot;data-list&quot;&gt; &lt;view class=&quot;items&quot; wx:for=&quot;&#123;&#123;propData&#125;&#125;&quot; wx:key=&quot;key&quot;&gt; &lt;view wx:if=&quot;&#123;&#123;item.bg_color===&#x27;#FFFFFF&#x27;&#125;&#125;&quot; class=&quot;items-content&quot; data-value=&quot;&#123;&#123;item.event_value&#125;&#125;&quot; data-type=&quot;&#123;&#123;item.event_type&#125;&#125;&quot; bindtap=&quot;navigation_event&quot; style=&quot;background-color:#fff;padding:0;height:110rpx;width:110rpx;border-radius:0%&quot;&gt; &lt;image src=&quot;&#123;&#123;item.images_url&#125;&#125;&quot; mode=&quot;aspectFit&quot; style=&quot;width:110rpx;height:110rpx&quot;/&gt; &lt;/view&gt; &lt;view wx:else class=&quot;items-content&quot; data-value=&quot;&#123;&#123;item.event_value&#125;&#125;&quot; data-type=&quot;&#123;&#123;item.event_type&#125;&#125;&quot; bindtap=&quot;navigation_event&quot; style=&quot;background-color:&#123;&#123;item.bg_color&#125;&#125;;&quot;&gt; &lt;image src=&quot;&#123;&#123;item.images_url&#125;&#125;&quot; mode=&quot;aspectFit&quot; style=&quot;&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 代码逻辑：当检测到导航栏背景颜色为白色时，设置图片上一层View标签的内边距padding 为0（原为20rpx）高宽设置为110rpx。并且将图片高宽均增加40rpx（原为70rpx），弥补内边距。 修改icon-nav.wxss文件 12345.data-list .items image &#123; width: 60rpx ; height: 60rpx ; margin-top: 5rpx;&#125; 将原来的高宽后面的!important去掉，为了使步骤1中内联的高宽样式生效。 最后，特别注意：你在网站后台修改导航栏图片时，必须设置导航栏背景色为白色。不设置或者设置为其他颜色，则采用默认的样式。此时图片会比较小。 修改导航栏：你的网站/admin.php-&gt;手机端管理-&gt;首页导航,修改导航栏 确保颜色代码为#FFFFFF 添加分类全部选项 完全替换小程序源代码中pages-&gt;goods-category-&gt;goods-category.wxml文件 1234567891011121314151617181920212223242526&lt;view class&#x3D;&#39;left-nav&#39;&gt; &lt;block wx:for&#x3D;&quot;&#123;&#123;data_list&#125;&#125;&quot; wx:key&#x3D;&quot;key&quot;&gt; &lt;view class&#x3D;&#39;items &#123;&#123;item.active || &quot;&quot;&#125;&#125;&#39; data-index&#x3D;&quot;&#123;&#123;index&#125;&#125;&quot; bindtap&#x3D;&#39;nav_event&#39;&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;text&gt; &lt;&#x2F;view&gt; &lt;&#x2F;block&gt;&lt;&#x2F;view&gt;&lt;view class&#x3D;&#39;right-content bg-white&#39;&gt; &lt;view class&#x3D;&quot;content-items&quot; data-value&#x3D;&quot;&#123;&#123;data_first_class[&#39;id&#39;]&#125;&#125;&quot; bindtap&#x3D;&quot;category_event&quot;&gt; &lt;view class&#x3D;&quot;text single-text&quot;&gt;全部&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;block wx:if&#x3D;&quot;&#123;&#123;data_content.length &gt; 0&#125;&#125;&quot;&gt; &lt;block wx:for&#x3D;&quot;&#123;&#123;data_content&#125;&#125;&quot; wx:key&#x3D;&quot;keys&quot; wx:for-item&#x3D;&quot;v&quot;&gt; &lt;view class&#x3D;&quot;content-items&quot; data-value&#x3D;&quot;&#123;&#123;v.id&#125;&#125;&quot; bindtap&#x3D;&quot;category_event&quot;&gt; &lt;image wx:if&#x3D;&quot;&#123;&#123;(v.icon || null) !&#x3D; null&#125;&#125;&quot; src&#x3D;&quot;&#123;&#123;v.icon&#125;&#125;&quot; mode&#x3D;&quot;aspectFit&quot; class&#x3D;&quot;icon&quot; &#x2F;&gt; &lt;view class&#x3D;&quot;text single-text&quot;&gt;&#123;&#123;v.name&#125;&#125;&lt;&#x2F;view&gt; &lt;&#x2F;view&gt; &lt;&#x2F;block&gt; &lt;&#x2F;block&gt;&lt;&#x2F;view&gt;&lt;view wx:if&#x3D;&quot;&#123;&#123;data_list.length &#x3D;&#x3D; 0 &amp;&amp; data_list_loding_status !&#x3D; 0&#125;&#125;&quot;&gt; &lt;import src&#x3D;&quot;&#x2F;pages&#x2F;common&#x2F;nodata.wxml&quot; &#x2F;&gt; &lt;template is&#x3D;&quot;nodata&quot; data&#x3D;&quot;&#123;&#123;status: data_list_loding_status&#125;&#125;&quot;&gt; &lt;&#x2F;template&gt;&lt;&#x2F;view&gt; 修改pages-&gt;goods-category-&gt;goods-category.js中部分代码 1234567891011121314// 导航事件 nav_event(e) &#123; var index = e.currentTarget.dataset.index; var temp_data = this.data.data_list; for(var i in temp_data) &#123; temp_data[i][&#x27;active&#x27;] = (index == i) ? &#x27;nav-active&#x27; : &#x27;&#x27;; &#125; this.setData(&#123; data_list: temp_data, data_first_class: temp_data[index], data_content: temp_data[index][&#x27;items&#x27;], &#125;); &#125;, 编译运行，即修改完毕。 有个小bug，打开分类页面，第一个一级分类的“全部”，在第一次打开时，会指向全部商品，而不是一级分类的商品。切换到第二个一级分类，再回来，此时点击“全部”，就变正常了。。后续再修复吧。 4：新订单通知推送新订单推送，是为了方便商家，接收各个端下单消息。通常，通常都是使用短信和邮箱方式来接收消息，但是邮箱接收效率太低。短信又需要收费。 这里我们使用两种及时的推送方式，第一种，飞鹅打印机。入住美团、饿了么的商家，通常都会购买这个打印机，因为他是全平台的，而且可以调用它的API接口，自定义打印内容。 第二种，微信公众号推送。当网站后台接收到新订单，即通过微信公众号的模板消息功能，向指定微信推送新订单消息。 当然如果你具备一些编程知识，还可以自己写个程序，向下单的用户推送订单的进展。（开发一个插件，调用订单的相关钩子。） 为了减少工作量，消息通知，是在原有插件新订单提醒基础上进行的修改。新的插件具有了除邮箱和短信以外的公众号和飞鹅打印功能。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"ShopXO","slug":"ShopXO","permalink":"https://sci.ci/tags/ShopXO/"}]},{"title":"机器学习深度学习李宏毅版-学习笔记","slug":"机器学习深度学习-学习笔记","date":"2020-05-21T15:02:29.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/05/21/机器学习深度学习-学习笔记/","link":"","permalink":"https://sci.ci/2020/05/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章 Regression 回归$$f(input)=output$$ 输入一个对象后，有指定的输出结果。 示例应用：数码宝贝原始cp值，求进化一次后的cp值 Step 1: Model 定义一个函数：确定输入原始cp值和输出进化后的cp值。$$y=b+w*x_{cp}$$ w and b are parameters Step 2: Goodness of Function方程好坏 对象1：function input: cp612-&gt;x1 function output:cp979-&gt;y1$$(x^1,y^1)$$ $$(x^2,y^2)$$ $$……$$ $$(x^{10},y^{10})$$ 定义另一个函数：确定第一个函数效果如何。输入一个函数，输出函数好坏程度。 Loss Function$$\\begin{split}L(f) &amp;= L(w,b)\\ &amp;=\\sum_{n=1}^{10}\\left(y^n-\\left(b+w*x^n_{cp}\\right)\\right)^2\\end{split}$$Step 3: Best Function最好的函数 Gradient Descent$$w^*=arg\\ min\\ L(w)$$枚举w值，找到Loss Function最小的w值。 随机选择一个初始w0, $$\\frac{dL}{dw}|w=w^0$$ 在w0位置，如果斜率为正，则w向小的位置移动，反之向w增大的位置移动，目的是找到L(w)更小的位置。下一个位置w1。$$w^1=w^0-\\eta\\frac{\\partial L}{\\partial w}|w=w^0,b=b^0\\b^1=b^0-\\eta\\frac{\\partial L}{\\partial b}|w=w^0,b=b^0\\\\eta表示学习率。$$最终找到一个最佳的w和b，确定一个L(f)最小。 然而，由于数码宝贝的物种不同，b和w的取值将不同。 修改模型 Step 1:选择模型$$y=b_1\\delta(x^s=宝贝1)+w_1\\delta(x_s=宝贝1)x_{cp}+b_2\\delta(x^s=宝贝2)+w_2*\\delta(x_s=宝贝2)*x_{cp}+……$$ $$\\delta(x_s=宝贝1)\\begin{cases}=1\\ if,x_s=宝贝1 \\\\=0\\ else\\end{cases}$$ 此时已经很精准了，但是可能还存在其他除了种类以外的影响因素，比如身高，体重，hp。 回到Step 2:Regularization$$y=b+\\sum w_ix_i\\L=\\sum_n(y^n-(b+\\sum w_ix_i))^2+\\lambda\\sum (w_i)^2$$为了获取一个更光滑的曲线，来减少噪音对输出结果的影响。 采用较小的拟合次数简单的model，通常具有更小的方差，但偏差更大，即结果集中但集中位置偏离真实值；较大的拟合次数复杂的model，方差比较大，但偏差更小。 偏差大： 更多训练数据 更复杂的模型 方差大： 更多训练数据 获取模型：Validation 训练数据-&gt;分三份，两份获取模型，一份验证模型。 第二章 Gradient Descent梯度下降法在第一章Step 3中，我们要找到一个最低的loss function$$\\theta^*=arg\\ max\\ L(\\theta) \\ \\ \\ \\ L:loss\\ function\\ \\ \\theta:parameters$$假设$\\theta$有两个参数${\\theta_1,\\theta_2}$ 随机设置一个$\\theta^0=\\begin{bmatrix}\\theta_1^0\\\\theta_2^0\\end{bmatrix}$$$\\begin{bmatrix}\\theta_1^1\\\\theta_2^1\\end{bmatrix}=\\begin{bmatrix}\\theta_1^0\\\\theta^0_2\\end{bmatrix}-\\eta\\begin{bmatrix}\\frac{\\partial(\\theta_1^0)}{\\partial\\theta_1}\\\\frac{\\partial(\\theta_2^0)}{\\partial\\theta_2}\\end{bmatrix}$$ $$\\begin{bmatrix}\\theta_1^2\\\\theta_2^2\\end{bmatrix}=\\begin{bmatrix}\\theta_1^1\\\\theta^1_2\\end{bmatrix}-\\eta\\begin{bmatrix}\\frac{\\partial(\\theta_1^1)}{\\partial\\theta_1}\\\\frac{\\partial(\\theta_2^1)}{\\partial\\theta_2}\\end{bmatrix}$$ 简化公式：$$\\bigtriangledown L(\\theta)=\\begin{bmatrix}\\frac{\\partial L(\\theta_1)}{\\partial\\theta_1}\\\\frac{\\partial L(\\theta_2)}{\\partial\\theta_2}\\end{bmatrix}\\\\theta^1=\\theta^0-\\eta\\bigtriangledown L(\\theta^0)$$需要调节学习率（步长）$\\eta$到合适的值。 不同的$\\theta$给不同的$\\eta$。 Adagrad:随着参数增加，步长逐渐减小。$$w^1\\gets w^1-\\frac{\\eta^0}{\\sigma^0}g^0 \\ \\ \\ \\sigma^0=\\sqrt{(g^0)^2}\\\\vdots\\\\vdots\\w^{t+1}\\gets w^t-\\frac{\\eta^t}{\\sigma^t}g^t\\ \\ \\ \\sigma^t=\\sqrt{\\frac{1}{t+1}\\sum^t_{i=0}(g^i)^2}$$ $$\\eta^t=\\frac{\\eta}{\\sqrt{t+1}}$$ Feature Scaling: 将多个x输入的范围统一到一个范围，以保证在计算L(f)时，每个w对L(f)的影响相同。 Gradient Descent会卡在局部最小值的位置 第三章 New Optimizers for Deep Learning 优化一些记号： $\\theta_t$:模型参数 $m_{t+1}$:从step 0到step t 的动量。 SGD： SGDM、Learning rate scheduling、NAG 走到最低点时，还不会停下来，由于之前的动量影响，存在一个类似的惯性作用，会继续向上爬坡。 Adam： Adagrad、RMSProp、AMSGrad、AdaBound、RAdam、Nadam、AdamW SGD+Adam-&gt;SWATS Lookahead 第四章 Classification 分类例：投简历 输入：收入、存款、专业、年纪 输出：录取或拒绝 模型：$$x\\rightarrow f(x)\\begin{cases}g(x)&gt;0\\ &amp;Output=class1\\else \\ \\ &amp;Output=class2\\end{cases}$$Loss function：$$L(f)=\\sum_n\\delta(f(x^n)\\ne y^n)$$79个水系（C1）宝可梦，61只普通系（C2）的宝可梦 $P(x|C_1)$的可能性。 $P(x|C_1)$满足高斯分布（正态分布），找到最合适的高速分布系数$\\mu$和$E$ 使用贝叶斯公式，求测试数据$P(C_1|x)$的概率。 所以： 模型$$x\\rightarrow P(C_1|x)=\\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}$$函数的好坏： 平均值$\\mu$和$E$。 一堆数学运算…… 模型：$$P_{w,b}(C_2|x)=\\sigma(z)\\\\sigma(z)=\\frac{1}{1+exp(-z)}\\z=w*x+b$$ 第五章 Logistic Regression$$f_{w,b}(x)=\\sigma(\\sum w_ix+b)$$$x_1$属于$C_1$,$x_2$属于$C_1$,$x_3$属于$C_2$……$$L(w,b)=f_{w,b}(x^1)f_{w,b}(x^2)(1-f_{w,b}(x^3))…$$找到一个$w^*,b^*$满足$arg\\ max,L(w,b)$最大。 第六章 Deep learning历史： 1958: Perceptron(linear model) 1980: Multi-layer perceptron 1986: Backpropagation 1989: 1 hidden layer is “good enough” 2006: RBM initialization 2009: GPU 2011: Speech recognizition 步骤： 找到一个函数-&gt;Neural Network Deep = Many hidden layers 第七章 Backpropagation 反向传播让计算梯度下降法的参数更有效。 Chain Rule 链式法则： Case1：$$y=g(x) \\ \\ \\ \\ z=h(y)\\\\triangle x \\rightarrow \\triangle y\\rightarrow \\triangle z\\ \\frac{dz}{dx}=\\frac{dz}{dy}\\frac{dy}{dx}$$Case2:$$x=g(s) \\ \\ y=h(s) \\ \\ z=k(x,y)\\ \\frac{dz}{ds}=\\frac{\\partial z}{\\partial x}\\frac{dx}{ds}+\\frac{\\partial z}{\\partial y}\\frac{dy}{ds}$$ Loss function是所有输入经神经网络处理后的输出，与理想输出误差之和。$$L(\\theta)=\\sum_nC(\\theta)$$对Loss function求导：$$\\frac{\\partial L}{\\partial w}=\\sum_n\\frac{\\partial C}{\\partial w}$$只讨论神经网络的一个节点。 $$\\frac{\\partial C}{\\partial w}=\\frac{\\part C}{\\part z}\\frac{\\part z}{\\part w}$$求z对w求导，很简单，对w1求导是x1，对w2求导是x2。 假设第二层神经节点的输入a，是将z通过一个信号函数(signal) $\\sigma(z)$得到的现在求$\\frac{\\part C}{\\part z}$$$\\frac{\\part C}{\\part z}=\\frac{\\part a}{\\part z}\\frac{\\part C}{\\part a}$$利用链式法则，求$\\frac{\\part C}{\\part a}$ 公式见上图。此时，通过反向传递法则。假设红色的信号节点就是神经网络的最后一个节点，对应输出就是神经网络输出。那么可以倒推回去。$\\frac{\\part C}{\\part z^,}$就等于最后的sign函数导数。因此能求得$\\frac{\\part C}{\\part a}$，这样依次反推回去。最终求得每个节点的$\\frac{\\part C}{\\part z}$。从而求得Loss function的导数。 第八章 Tips for Deep Learning 定义一个方程 方程好坏 选择最好的方程 获得一个Neural Network 是否获得一个好的结果在Training Data，如果不好重新选择最好的方程 在Testing Data获得不好的结果，overfitting，则重新定义一个方程。 ReLU Rectified Linear Unit.矫正线性单元 如果某个节点，输出是零，那么他对最后的结果没有任何影响。所以，输出为零关联的之后节点都可以被拿掉。 ReLU -variant 当z小于0时，a=mz。 Leaky ReLU ：m=0.01 Parametric: m可变 Maxout 最大输出，将不同输入的输出z分组，组内选出最大的值，作为下一个节点输入。 RMSProp$$w^1 \\leftarrow w^0-\\frac{\\eta}{\\sigma^0}g^0 \\ \\ \\ \\ \\ \\sigma^0=g^0\\w^2 \\leftarrow w^1-\\frac{\\eta}{\\sigma^1}g^1 \\ \\ \\ \\ \\ \\sigma^1=\\sqrt{\\alpha (\\sigma^0)^2+(1-\\alpha)(g^1)^2}\\……$$$\\alpha$可以设置。 Momentum 在初始点$\\theta^0$处，加速度方向为gradient方向。 初始移动距离:$v_0=0$ 加速度(第一点处的gradient):$\\triangledown L(\\theta^0)$ 移动距离:$v^1=\\lambda v^0-\\eta \\triangledown L(\\theta^0)$ 移到第二点:$\\theta^1=\\theta^0+v^1$ 计算第二点的加速度:$\\triangledown L(\\theta^1)$ 下一次移动距离:$v^2=\\lambda v^1-\\eta \\triangledown L(\\theta^1)$ 移动到第三点:$\\theta^2=\\theta^1+v^2$ Adam:RMSProp+Momentum 过拟合问题 early stop 通过情况可能出席，当训练集增加时，测试集的正确率反而下降，因此通过减少训练集的数据来达到防止过拟合。 Regularization $$L^,(\\theta)=L(\\theta)+\\lambda \\frac{1}{2}||\\theta||_2$$ $$||\\theta||_2=(w_1)^2+(w_2)^2+……$$ $||\\theta||_2$不考虑biases，因为正则化是为了让loss function更加平滑，biases并不会起到作用。 Loss function求导:$$\\frac{\\partial L^,}{\\partial w}=\\frac{\\partial L}{\\part w}+\\lambda w$$在找下一个$$w^{t+1}\\rightarrow w^t-\\eta\\frac{\\part L^,}{\\part w} =w^t-\\eta(\\frac{\\part L}{\\part w}+\\lambda w^t)=(1-\\eta\\lambda)w^t-\\eta\\frac{\\part L}{\\part w}$$ Dropout 在更新参数之前： 每个节点有p%几率被丢掉 使用新的网络去训练 测试时： 没有丢弃节点 如果丢弃率为p%，所有的weights times(1-p)% 可以理解为，在训练时，腿上绑重物，测试时把重物拿掉。 为什么要乘(1-p)% 假设丢弃率为50%,在训练时一半节点被拿掉，而测试时使用了所有节点，导致节点z相差两倍，在测试时将所有weight乘50%，保证测试时的$z’\\approx z$ 第八章 Why deep矮胖？高瘦？ 实验数据表明，相同参数情况下，deep的错误率更小。 Modularization Deep-&gt;Modularization 比如辨别男生长发、男生短发、女生长发、女生长发。 男生长发的训练集是很少的。 使用模组化，可以先辨别性别，在辨别头发长短。这样性别和长短发的训练集都是差不多的。这样男生长发也有好的正确率。 Deep-&gt;Modularization-&gt;Less training data Modularization-Speech 人类语言的架构 Phoneme:人类发音的音节， Tri-phone:不同的组合 State: 不同的节 语音识别： 分类：input-&gt;acoustic feature,output-&gt;state deep的好处是，可以把复杂的问题，使用很多个简单的function连接在一起。 第九章 Pytorch指定设备，迁移到某个设备 12345cpu = torch.device(&quot;cpu&quot;)gpu=torch.device(&quot;gpu&quot;)x= torch.rand(10)print(x)x=x.to(gpu)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://sci.ci/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"计算机网络技术学习笔记","slug":"计算机网络技术学习笔记","date":"2020-04-26T11:05:49.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/04/26/计算机网络技术学习笔记/","link":"","permalink":"https://sci.ci/2020/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1：基础概念 局域网、城域网、广域网的区别 实训任务：宽带城域网的逻辑结构，“三个平台一个出口” 管理平台、业务平台、网络平台（核心层、汇聚层、接入层）、城市宽带出口- 核心层： 为汇聚层的网络提供高速分组转发，为城市提供一个高速安全与具有QoS保障能力的数据传输环境 提供城市的宽带IP出口 用户访问Internet所需的路由访问 汇聚层： 汇聚接入层的用户流量 进行本地路由，QoS优先级的管理等 用户流量转发到核心层 接入层： 连接最终用户 三层结构思想：上层负责下层的数据汇聚，核心提供出口和QoS、汇聚本地路由、接入服务用户。 QoS服务质量的保证： 资源预留、区分服务、多协议标记交换 RPR：弹性分组环，工作技术，动态分组传输（DPT），在光以太网上高效传输IP分组的传输技术。顺时针传输的光纤叫做外环，内外环都可以传输数据分组和控制分组 2：中小型网格系统总体规划考点：路由器技术指标、网格系统分层设计、交换机技术指标、网络服务器性能 2.1 基础知识2.1.1 基于网络的信息系统基本结构 网络运行环境：机房和电源 网络系统 网络操作系统 网络应用软件开发和运行环境 2.1.2 网络需求调研与系统设计的基本原则2.2 实训任务2.2.1 网络用户调查与网络工程需求分析网络需求分析包括：网络总体需求分析、综合布线需求分析、网络可用性与可靠性分析、网络安全性分析 2.2.2 路由器选型的依据 路由器的分类——根据路由器背板交换能力划分 交换能力大于40Gbps的为高端路由器 路由器的技术指标 吞吐量：包转发能力。能力与端口数量、端口效率、包长、包类型有关 背板能力：路由器的输入端与输出端之间的物理通道。传统，共享背板，高性能，交换式结构。背板能力决定了吞吐量 丢包率：持续负荷下，包丢失的概率。衡量路由器超负荷工作时的指标 延时与延时抖动：第一个比特进入路由器，到该帧的最后一个比特离开路由器所经历的时间。高速路由器，1518B的IP包，延时要求小于1ms。延时抖动指延时的变化量，语音、视频对延时抖动要求较高。 突发处理能力：最小帧间隔发送数据包而不引起丢失的最大发送速率 路由表容量 服务质量：主要表现在队列管理机制、端口硬件队列管理和QoS协议上 网管能力 可靠性和可用性：设备的冗余、热插拔、无故障工作时间、内部钟表精度 2.2.3 交换机分类与主要技术指标 交换机的分类 交换机的性能指标 背板带宽 全双工端口带宽：端口数x端口速率x2 2.2.4 网络服务器选型 分类 文件服务器、数据库服务器、Internet通用服务器、应用服务器 应用服务器的主要技术特点：采用浏览器/服务器（B/S）模式。传统的（C/S）客户/服务器 功能 热插拔 RAID磁盘冗余阵列 CISC处理器结构 网络服务器性能 运算处理能力 磁盘存储能力 系统的高可靠性=MTBF/（MTBF+MRBR），MTBF，平均无故障时间，MRBR，平均修复时间 3：IP地址规划设计3.1 基础知识3.1.1 IP地址的概念和划分地址新技术的研究标准分类：A类、B类、C类IP地址采用包括网络号-主机号 划分子网的三级结构：网络号-子网号-主机号 无类域间路由（CIDR）：也称超网，将连续小的网络组成一个大的网络 网络地址转换（NAT）：公司内部每一台主机分配不能再Internet上使用的专用IP地址，访问外网时，专用IP地址转换成全局IP地址。 3.1.2 标准分类IP地址A类：0+7位网络号+24位主机号：1.0.0.0~127.255.255.255 B类：10+14位网络号+16位主机号：128.0.0.0~191.255.255.255 C类：110+21位网络号+8位主机号：192.0.0.0~223.255.255.255 D类：1110+21位组播地址：224.0.0.0~ E类：11110+保留号 A类地址，一共127块，第一块和最后一块保留用作特殊用途，另外，网络号=10的，用于专用地址，其余125块可指派给一些机构，可用的主机号为2^24-2. B类地址，网络号长度为14位，网络号总数为16384，因此每个B类网络可以有2^16=65536个主机号。全0和全1保留用于特殊目的，因此允许分配的主机号位65534个。 C类地址，网络号长度21位，主机号长度为8位，允许有2097152个网络位，允许分配的主机号为254个。 特殊地址形式： 直接广播地址：在A类B类C类IP地址中，主机号是全1，那么这个主机号为直接广播地址 受限广播地址：32位全为1的广播地址（255.255.255.255）为受限广播地址，用来将一个分组以广播方式发送给本网络的所有主机。 这个网络上的特定主机地址：网络号全零，主机号不变 回送地址：A类地址中的127.0.0.0是回送地址，他是一个保留地址，会送地址用于网络软件测试和本地进程间通信 3.1.3 划分子网的三级网络结构 子网的基本概念 三级层次是IP地址：netID——subnetID——hostID 子网掩码的概念：如何从一个IP地址中提取出子网号。 A类地址：8位网络号：全1，24位主机号全0-。255.0.0.0 B类：255.255.0.0 C类：255.255.255.0 计算： B类地址，要分出64个子网，从主机位借6位，现在网络号22位，主机位10位，子网掩码是，网络号全1，主机号全0，所以子网掩码为，255.255.252.0或者“网络号/22”. 分128个子网，则网络号23位，主机号9位，子网掩码：255.255.254.0 3.2 实训任务网络地址转换NAT工作原理 静态NAT（一对一） 动态地址NAT（一对多） 网络地址端口装欢NAPT（端口区分） IPv6地址的主要特征 新的协议格式，巨大的地址空间，有效的分机寻址和路由结构，地址自动配置，支持QoS服务 IP v6地址长度规定为128位，用16位边界划分，每个16位段转换更4位十六进制数字，用冒号分隔 压缩零，有一段连续的十六进制段都为0，用双冒号压缩，FE8C::2AA:FF:FE9A:4CA2。段内压缩，只能压缩前面的零，双冒号在一个地址中只能出现一次。 IPv6不支持子网掩码，FE8C::2AA:FF:FE9A:4CA2/48。用前缀位表示48位前缀。 4：路由设计技术考点：RIP路由协议、OSPF、BGP、IP路由选择和路由汇聚 内部路由协议：RIP、OSPF 外部路由协议：BGP 4.1 路由信息协议（RIP）的工作过程： 路由表的建立，初始化的路由只包含所有与该路由器直接相连的网络的路由。距离为0. 路由表信息的更新 如果自己的路由表没有该项，增加该项，距离+1 如果自己的路由表已有该项 原距离比对方的距离（跳数）+1还要大，距离设置为对方距离+1。路由为对方 原距离比对方的距离+1还要小，保持不变。 相同不变 路由刷新保温主要内容是由若干（V、D）组成的表 4.2 最短路径优先协议（OSPF）4.2.1 和RIP比较，其特点 OSPF是使用分布式链路状态协议； 链路状态度量主要是指费用、距离、延时、带宽。RIP主要看跳数； 链路状态发生变化时，用洪泛法向所有路由器发送此信息； 所有的OSFPF路由器交换链路状态信息，最终建立一个链路状态数据库，这个数据库实际上就是全网的拓扑结构图； OSPF可以将一个自治系统再划分为若干个更小的范围，即区域，每个区域有一个32位的区域标识符，一个区域路由器不超过200个。 自治系统内部的区域划分，好处在于利用洪泛法将链路状态信息范围局限再每个区域而不是整个自治系统。层次结构划分，将一个自治系统划分成若干区域与一个主干区域。主干区域内部的路由器叫主干路由器，连接各个区域的路由器叫做区域边界路由器，区域边界路由器接收从其他区域来的信息。 4.2.2 OSPF协议的执行过程 初始化过程：OSPF让每个路由器用数据库描述分组和相邻路由器交换本数据库已有的链路状态摘要信息，摘要信息主要址出哪些路由器的链路状态信息已经写入数据库。 网络云心过程：只要一个路由器的链路发生变化，该路由器就要使用链路状态发送分组信息。 4.3 外部网关协议BGP基本思想： 外部网关协议是不同自治系统的路由器之间交换路由信息的协议。 BGP-4采用了路由向量路由协议，每个自治系统至少选择一个路由器作为自治系统的“发言人”，一个BGP发言人与其他自治系统的发言人交换路由信息要先建立TCP连接。 BGP路由选择协议的工作过程 BGP初始化过程：BGP刚刚运行时，交换整个路由表，以后只需要在发生变化时更新有变化的部分； BGP协议的四种分组： 打开分组：与另一个BGP发言人建立关系； 更新分组：发送某一路由信息，以及列出要撤销的多条路由； 保活分组：确认打开分组，以及周期证实相邻边界路由器存在； 通知分组：发送检测到的差错。 BGP发言人周期（30秒）交换“保活分组”。 “更新分组”是BGP协议的核心。 5：局域网技术考点：以太网组网方法（快速以太网）、局域网组网设备（集线器、交换机）、综合布线子系统设计（水平子系统、建筑群子系统） 5.1 基础知识5.1.1 局域网组网的基础知识局域网（LAN）是指分布在相对较小距离范围内的计算机网络。 局域网标准：IEEE802——&gt;数据链路层分为了两个子层，LLC子层和MAC子层 交换式局域网的基本概念，交换局域网是相对共享式局域网而言。局域网交换机可以在多个端口之间建立多个并发连接。主要采用快捷交换方式和存储转发方式 虚拟局域网的基本概念（VLAN），以软件的方法将网络中的节点按工作性质与需要划分成若干“逻辑局域网”。 方法通常四种： 基于端口的虚拟局域网 基于MAC地址的虚拟局域网 基于网络层地址定义的虚拟局域网 基于IP广播组的虚拟局域网 5.1.2 综合布线的概念综合布线是一种模块化的、灵活性极高的建筑物内或建筑群之间的信息传输通道。由不同系列和规格的不见组成，包括：传输介质、相关连接硬件以及电气保护设备。 特点：兼容性、开放性等 组成：工作区、配线（水平子系统）、干线（垂直子系统）、设备间、建筑群、管理六大子系统 5.2 实训任务 以太网组网的基本方法 以太网的物理层标准的命名方法： IEEE802.3x(Mb/s) |Type-y|Name(局域网名称) 10BASE-5，10M网，Base基带传输方式，y为网络的最大长度，单位100m。 10BASE-T标准以太网组网的设计方法，-T表示非屏蔽双绞线和RJ-45接口 快速以太网组网的基本设计方法： 特点：IEEE802.3u、 可工作在10M和100M 快速以太网介质专用接口MII 快速以太网的物理标准： 100BASE-TX：使用5类非屏蔽双绞线或屏蔽双绞线（抗干扰性更强），两队双绞线，一对用于发送，一对用于接收。在传输中使用4B/5B编码方式。最大网段长度为100m。支持全双工 100BASE-FX：两条光纤。全双工 100BASE-T4：4对3类非屏蔽双绞线，3对用于传送数据，1对用于检测冲突信号。传输8B/6T编码。半双工。 全双工：任意时刻，信号双向传输信号。是一种点到点连接方式，支持全双工的以太网拓扑结构一定是星形。 10Mbps与100Mpbs速率自动协商功能，只能用于使用双绞线的以太网，需要在500ms内完成。 中继器 中继器是网络物理层上面的连接设备。通过对数据信号的重新发送或转发，来扩大网络传输的设备。 543规则：是以太网标准中规定了以太网只允许出现5个网段，最多使用4个中继器，其中3段可以连接计算机 集线器 多端口的中继器，区别仅在于中继器只是连接两个网段，而集线器能够提供更多端口服务，采用CSMA/CD介质访问控制方法。连接一个集线器的所有节点共享一个冲突域。 串联一个集线器可以监听该链路中的数据包。 连接到一个集线器的节点，不能同时发送数据帧，但能同时接收 网桥 工作在数据链路层的设备。局域网互联，交换数据和共享资源 特征：能互联两个采用不同数据链路层协议、不同传输介质、不同传输速率的网络。网桥以接收、储存、地址过滤和转发实现连接。 网桥最重要的维护工作是构建和维护MAC地址表。MAC地址表记录了不同的节点的物理地址与网桥转发端口的关系。 为避免网桥互联时的环状结构，透明网桥使用生成树算法。 生成树协议：其能够逻辑地阻断网络中存在地冗余链路，以消除路径中地环路，活动链路出现故障时，重新激活冗余链路来恢复网络的连接。 交换机 交换机可以在他的多个端口之间建立并发连接，交换式以太网是典型地交换式局域网，它的核心部件是以太网交换机。 交换机与网桥地主要区别：网桥一般只有一个CPU，通过软件方法完成网桥地接收、存储、地址过滤与转发等。 交换机使用为帧转发设计地专用集成电路芯片ASIC。或采取多个CPU并发工作地计算机结构 综合布线系统子系统设计 工作区子系统设计：指从设备出线到信息插座地整个区域 确定信息插座地数量和类型：信息插座分为，嵌入式安装插座（暗盒）、表面安装插座（明盒）、多介质信息插座（光纤和铜缆） 适配器的选用：设备连接处用的不同信息插座，可用专用电缆和适配器。挡在单一信息插座上，进行两项服务，应用“Y”型适配器。选用电缆类型不同与设备所需的电缆类型时，以及在连接使用不同信号的数模转换货数据速率转换，应采用适配器。 水平子系统设计 采用5类或超5类4对非屏蔽双绞线，90m以内 管理子系统设计 干线子系统设计 建筑物主馈电缆 建筑群子系统 两个或以上建筑物之间，由电缆、光缆和入楼处线缆上过流过压的电器保护设备 最好的是——管道布线法 6： 局域网交换机6.1 基础知识6.1.1 局域网交换机的基本功能交换机的基本概念：工作在数据链路层的网络设备。交换机根据进入端口数据帧中的MAC地址，过滤、转发数据帧。独占数据通道、独享信道带宽，同时允许多对站点进行通信、系统带宽等于所有端口带宽之和。 交换机的功能： 建立和维护一个表示MAC地址与交换机端口对应关系的交换表。 在发送节点和接收节点之间建立一个虚连接。 完成数据帧的转发和过滤。 交换机分析每一个进来的数据帧，根据帧中的目的MAC地址，通过查询交换表，确定是丢弃还是转发。 6.1.2 局域网交换机的工作原理交换机的工作原理与网桥相似，通过自学习的方式。 6.1.3 交换表内容的建立和维护交换表的内容：目的MAC地址、该地址所对应的交换机端口号以及所在的虚拟子网。 交换表的建立，初始时是空的，通过学习建立。 交换表的维护，一定时间后，表项未被更新，则被删除 交换结构： 软件交换结构，串/并转换-&gt;RAM-&gt;并/串转换； 矩阵交换结构，根据源端口与目的端口打开交换矩阵中相应的开关； 总线交换结构，数据帧都按时隙在总线上传输， 交换模式：快速转发、碎片丢弃、存储转发 快速转发模式，一旦检测到6个字节，目的地址就立即进行转发操作。无法经过校验、纠错即被直接转发。 存储转发模式，先存储起来，然后进行循环冗余码校验检查，再对错误帧进行处理，才去除数据帧的目的地址，进行转发操作。延时大，支持不同速度的端口间转发。 碎片丢弃交换模式，检测数据帧是否冲突碎片，判断数据帧是否为64字节 6.1.3 虚拟局域网VLAN技术以交换式网络为基础，把网络上的用户终端被划分为多个逻辑工作组。逻辑组设立一个独立的逻辑网段和广播域。不受用户所在的物理位置和物理网段的限制。通过软件完成。 VLAN工作在OSi参考模型的第2层，数据链路层。 其广播的信息只能发送给该VLAN的节点 唯一不同的子网号，VLAN只能通过第三层路由才能通信 VLAN的标识：VLAN ID或VLAN name VLAN ID由IEEE 802.1Q标准规定12位二进制，1~1000用于以太网。 VLAN name由32位字符表示，可以是字母或数字 VLAN Trunk（虚拟中继）：主干线路上传输多个VLAN的信息，连接主干线路的两台交换机端口，应具有Trunk功能 6.1.4 生成树协议STPBPDU报文，每两秒或是再网络发生故障、网络拓扑变化时，发送新的BPDU。 BPDU两种类型，配置BPDU（不超过35个字节），拓扑变化通知BPDU（不超过4字节） 6.2 实训任务 使用console配置交换机，超级端口设置参数9600bps，8位数字 telnet命令配置，再windows“运行”输入指令telnet x.x.x.x:端口号 使用浏览器配置交换机，计算机已安装TCP/IP协议，计算机和交换机都有IP地址；计算机安装有JAVA的WEB浏览器；交换机有管理权限的用户密码；交换机支持http服务，并启用。 7：路由器及其配置考点：路由器基础与基本命令、接口配置、Pos接口配置、访问控制列表、静态路由、RIP协议、OSPF协议配置 7.1 基础知识7.1.1 路由器概述工作在网络层的设备，选择最佳路径，将数据从源主机传送到目的端主机。路由器具有异构网络、广域网互联、隔离广播的能力。 7.1.2 路由器工作原理 路由选择，路由器依据目的IP地址的网络地址，通过路由算法，确定一条最佳路径。 分组转发，根据最佳路径信息，将其转发给下一跳路由器、目的端口或是缺省路由器。 缺省路由也称缺省网关。分组转发的思想，目的IP地址不变，目的MAC地址，逐跳修改。 路由表，目的网络地址及其对应端口，下一跳路由器的名字，缺省路由信息 7.1.3 路由器的结构 中央处理器 非易失性随机存储器NVRAM：存储路由器的启动配置文件 闪存FLASH：保存操作系统的映像文件和一些微代码 接口：局域网接口、广域网接口 配置接口：console控制接口和AUX辅助接口。AUX通过拨号方式实现远程访问 路由器接口名字和编号 f 0/5，f：FastEthernet；mod/port，模块号/端口 7.1.4 路由器的工作模式 用户模式 通过控制台或Telnet登陆路由器后，用户可以浏览路由器的某些信息。默认提示符：router&gt; 特权模式 用户模式后输入enable。可以管理系统时钟、错误检测、查看和保存配置文件、清除内存、重启。提示符：router# 全局配置模式 在特权模式下，输入configure terminal。配置路由器全局性参数（主机名、口令、TFTP服务器、静态路由）。提示符：router（config）# 其他配置模式 包括接口配置模式、虚拟终端配置模式、路由配置模式等。 设置模式 用户创建第一次的配置文件 RXBOOT模式 路由器的维护模式，恢复密码 7.2 实训任务 路由器的操作 AUX通过远程拨号配置路由器 路由器的配置 router(config)#line vty 0 15 router(config-line)#password zzz *** 使用TFTP配置路由器 广域网接口配置： 配置异步串行口（为用户提供拨号上网服务） interface a1。封装格式只能为ppp 配置同步串行口 用于DDN专线、帧中继、卫星 interface s1/1；Bandwidth 2048（带宽2M，单位为kb）；封装hdlc或ppp协议，hdlc为缺省 配置POS接口 interface POS3/0；Crc 32（校验位16和32）；Posframing sdh（可选帧格式是SDH和SONET） loopback接口配置 一个虚拟接口，接口号有效值为0~2147483647，主要用为管理地址，永远处于激活状态。子网掩码为255.255.255.255。int loopback 0 路由器的静态路由配置： 静态路由的配置方法： Router(config)#p route &lt;目的网络地址&gt;&lt;子网掩码&gt;&lt;下一跳路由器的IP地址&gt; 静态默认路由配置方法 如果路由表中无匹配表项，且路由表中有默认路由，路由器按默认路由的吓一跳地址妆发数据 Router(config)#ip route 0.0.0.0 0.0.0.0 212.112.8.6 动态路由协议的配置 RIP动态路由协议的配置 RIP路由协议依据路由器的跳数(hop数)。最大跳数为15。不可带子网掩码 配置被动接口，只收不发 配置路由过滤 配置管理距离 定义邻居路由器 OSPF动态路由协议的配置 OSPF的基本配置 使用network定义参与OSPF的子网地址 Router(config)# router ospf 63 Router(config-router)# network 131.107.25.1 0.0.0.0 area 0（0.0.0.0为反掩码或通配符） Router(config-router)# area 0 range 131.107.25.1 255.255.255.255 参数配置 配置被动接口、配置路由过滤、配置管理地址、配置引入外部路由到OSPF的参数 路由器的DHCP功能及其配置 IP地址分配有动态和静态两种方式。 工作原理：DHCP采用C/S工作模式，一，建立和管理IP地址池，二，接收并处理DHCP客户端提出的请求。 DHCP服务器配置 配置IP地址池的名称，并进入DHCP Pool配置模式 Router(config)# ip dhcp pool ttt 配置IP地址池 配置不用于动态分配的IP地址 配置IP地址池的缺省网关 配置IP地址池的域名系统 配置IP地址池的地址租约时间 取消地址冲突记录日志 路由器IP访问控制列表的功能 主要功能：ACL可以当作一种网络控制工具，用来过滤流入和流出接口的数据包","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"网络技术","slug":"网络技术","permalink":"https://sci.ci/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}]},{"title":"微信小程序学习笔记","slug":"微信小程序学习笔记","date":"2020-04-07T19:48:51.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/04/07/微信小程序学习笔记/","link":"","permalink":"https://sci.ci/2020/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1：简介 用户扫一扫或搜索一下即可打开应用。 微信有海量用户，粘性高 开发适配成本低 2：目录结构小程序结构目录 pages index logs utils app.js app.json project.config.json sitemap.json //某些页面是否能被微信检索 开发者文档：https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html 全局配置app.json 12345678910111213141516171819202122&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;,//第一个页面 &quot;pages/logs/logs&quot; ], &quot;window&quot;: &#123; &quot;backgroundTextStyle&quot;: &quot;light&quot;,//下拉刷新文字，需开通下拉刷新 &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot; &#125;, &quot;tabBar&quot;: &#123; //页面下面的菜单 &quot;list&quot;: [&#123; //list至少需要两项 &quot;pagePath&quot;: &quot;pagePath&quot;, &quot;text&quot;: &quot;text&quot;, &quot;iconPath&quot;: &quot;iconPath&quot;, &quot;selectedIconPath&quot;: &quot;selectedIconPath&quot; &#125;] &#125;, &quot;style&quot;: &quot;v2&quot;, &quot;sitemapLocation&quot;: &quot;sitemap.json&quot;&#125; 3:数据绑定1&lt;view&gt; &#123;&#123;msg&#125;&#125;&lt;/view&gt; 12345Page(&#123; data:&#123; msg:&quot;hello world&quot; &#125;&#125;) 4：数组和对象循环 12345678Page(&#123; data:&#123; list:&#123; id:0, name:&quot;猪八戒&quot; &#125; &#125;&#125;) 12345&lt;view&gt; &lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot; wx:key=&quot;id&quot;&gt; 索引：&#123;&#123;index&#125;&#125;--&#123;&#123;item.name&#125;&#125; &lt;/view&gt;&lt;/view&gt; wx:key可以提高循环检索效率。 key必须是唯一的值 wx:key =”*this” 表示数组是一个普通数组 wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;可以省略 对象循环wx:for=&quot;&#123;&#123;对象&#125;&#125;&quot; wx:for-item=&quot;对象的值（键值）&quot; wx:for-index=&quot;对象的属性（键名）&quot; 12345Person&#123; name:&quot;起飞&quot;, age:22, height:174&#125; 5：block标签 占位符的标签 写代码的时候可以看到这个存在 渲染时会移除掉 将view换成block，可将标签去掉，最终循环变量可在一行展示 6：条件渲染 wx:if=&quot;&#123;&#123;ture/false&#125;&#125;&quot; hidden 应用场景： 当标签不是频繁切换显示，优先使用wx:if 直接把标签从页面结构中删除 频繁切换用hidden 使用display:none属性。 1234567891011&lt;view&gt; &lt;view&gt;条件&lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;display&lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;if&lt;/view&gt; &lt;view wx:elis=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;elif&lt;/view&gt; &lt;view wx:else&gt;else&lt;/view&gt; &lt;view hidden&gt;hidden&lt;/view&gt; &lt;view hidden=&quot;&quot;&#123;&#123;true&#125;&#125;&quot;&quot;&gt;&lt;/view&gt;&lt;/view&gt; 7：事件绑定 12345678&lt;input type=&quot;text&quot; bindinput=&quot;handelInput&quot;/&gt;&lt;button bindtap=&quot;handletap&quot; data-opt=&quot;&#123;&#123;1&#125;&#125;&quot;&gt; +&lt;/button&gt;&lt;button bindtap=&quot;handletap&quot; data-opt=&quot;&#123;&#123;-1&#125;&#125;&quot;&gt; -&lt;/button&gt;&lt;view&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt; 1234567891011Pages(&#123; data:&#123; num:0; &#125;, handelInput(e)&#123; this.setDate(&#123;num:e.detail.value&#125;) &#125;, handletap(e)&#123; e.currentTaget.opt &#125;&#125;) 8：样式 在750x屏幕中 750px=750rpx 把屏幕改为375 375px=750rpx 1rpx=0.5px. 样式导入 utils下新建文件夹styles，文件夹里新建common.wxss 引用：@import &quot;../../styles/common.wxss&quot; 选择器 小程序不支持通配符 9：常见组件 view text 文本标签 只有此标签可长按复制 解码decode 1&lt;text selectable&gt;长按复制 &amp;nbsp(这是空格)&lt;/text&gt; 图片 本地图片不能超过2M，所以都使用外链图片 src：来源 mode：图片裁剪缩放格式//scaleToFill lazy-load：懒加载，当图片在上下三屏范围类，图片会预加载 swiper 轮播图 autoplay:自动播放 circular：轮播 interva：间隔时间。单位ms indicator-dots：显示分页指示器 12345&lt;swiper autoplay&gt; &lt;swiper-item&gt;&lt;image src=&quot;&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt; &lt;swiper-item&gt;&lt;image src=&quot;&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt; &lt;swiper-item&gt;&lt;image src=&quot;&quot;&gt;&lt;/image&gt;&lt;/swiper-item&gt;&lt;/swiper&gt; navigator 导航栏 块级元素 url：跳转某个页面 target：跳转到其他小程序 open-type：navigate，保留当前页面，不能跳转tabbar里的页面，默认值；redirect，不保留当前页面；switchTab：跳转tabbar，关闭其他页面；reLauch：关闭所有页面，打开应用某个页面 1&lt;navigator url=&quot;&quot;&gt;&lt;/navigator&gt; rich-text 富文本标签 1&lt;rich-text nodes=&quot;&#123;&#123;html&#125;&#125;&quot;&gt;&lt;/rich-text&gt; 12345678910111213141516171819Page(&#123; data:&#123; html:[ name:&quot;div&quot;, attr:&#123; class:&quot;my_div&quot;, style:&quot;color:red&quot; &#125;, children:[&#123; name:&quot;p&quot;, attr:&#123;&#125;, children:[&#123; type:&quot;text&quot;, text:&quot;hellp&quot; &#125;] &#125;] ] &#125;&#125;) button 按钮 open-type:contact：打开客服，在小程序官网，功能-客服。添加；share：分享小程序，不能分享朋友圈；getPhonNumber：获取用户手机号码，需要结合事件使用，只有企业小程序有权限使用，绑定事件bindgetphonenumber，获取回调函数；getUserInof：获取用户信息，需绑定事件，处理函数；openSetting：用户查看更改小程序能获得的权限 icon 图标 type：图标类型，sucess、warning等参数 size：大小 color：颜色 radio 单选框 必须和父元素radio-group一起使用 value选中的单选框值 12345&lt;radio-group bindchange=&quot;handelchange&quot;&gt; &lt;radio value=&quot;male&quot;&gt;男&lt;/radio&gt; &lt;radio value=&quot;female&quot;&gt;女&lt;/radio&gt;&lt;/radio-group&gt;&lt;view&gt;你选中的值是：&#123;&#123;gender&#125;&#125;&lt;/view&gt; 12345678910Page(&#123; data:&#123; gender:&quot;&quot; &#125;, handleChange(e)&#123; let gender=e.detail.value; this.setData(&#123;gender&#125;) &#125; &#125;) checkbox 复选框 需和checkbox-group一起使用 10：自定义组件 slot标签，占位标签，内容传递过来时，替代 自定义组件中： 12345&lt;tabs&gt; &lt;slot&gt; &lt;/slot&gt;&lt;/tabs&gt; 父组件中： 123&lt;tabs&gt; 你好啊&lt;/tabs&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://sci.ci/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信公众号开发","slug":"微信公众号开发","date":"2020-04-01T19:01:15.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/04/01/微信公众号开发/","link":"","permalink":"https://sci.ci/2020/04/01/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/","excerpt":"","text":"1：微信公众号简介给个人、企业和组织提供服务和用户管理的全新服务平台。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"https://sci.ci/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"Bootstrap学习笔记","slug":"Bootstrap学习笔记","date":"2020-03-01T15:34:13.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/03/01/Bootstrap学习笔记/","link":"","permalink":"https://sci.ci/2020/03/01/Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"0：入门例子12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;Bootstrap&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;网站天下&lt;/h1&gt; &lt;p&gt;hello-world&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; lang=&quot;zh-CN&quot;修改网站文字为中文文字。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;设置网站为自适应屏幕尺寸网站，缩放比例为不缩放。 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt;导入本地bootstrap.css样式。 1：容器.container+tab=&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;固定宽度居中显示 .container-fluid全宽容器 变化容器中一行一共包含12个格子。建立一个列表，每三个小格（col-xl-3）为一大格，需要一共4个大格可将其填满。 12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xl-3&quot; style=&quot;background-color: #0c5460&quot;&gt;111&lt;/div&gt; &lt;div class=&quot;col-xl-3&quot; style=&quot;background-color: #005cbf&quot;&gt;222&lt;/div&gt; &lt;div class=&quot;col-xl-3&quot; style=&quot;background-color: #1e7e34&quot;&gt;333&lt;/div&gt; &lt;div class=&quot;col-xl-3&quot; style=&quot;background-color: #6c757d&quot;&gt;444&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 栅格等级：col特小、col-sm-*小、col=md-*中、col-lg-*大、col-xl-*超宽。 各尺寸表示在不同尺寸屏幕上的显示方式，比如使用，col-xl则在屏幕宽度变为1000像素左右时，原来的栅格就换行显示，每个栅格占据一行。 若直接使用col来修饰，那么，即便在很小的屏幕上，栅格也不会换行。相当于网页直接缩放。不推荐使用。 栅格后的数字非必须。不添加数字则采用flexbox布局 设置一列宽度 col-6占6/12 col-auto可变宽度，随内容变化，变化的单位为1小格 混合布局 col-sm-6 col-lg-3大屏时每行四个，中屏每行2个，小屏每行一个。 对齐 垂直对齐align-items-center、align-items-xl-end 水平对齐justify-content-start/center/end/around/between 消除内边距 &lt;div class=&quot;row no-gutters&quot;&gt; 排序 order-**值越小排序越前。默认为0 偏移 offset-*偏移*个格子，也可加断点 margin移动 mr-auto``ml-auto 2：排版12345678910111213141516171819202122232425262728293031323334&lt;h1&gt; 主标题&lt;small&gt; 小号字体&lt;/small&gt;&lt;/h1&gt;&lt;div class=&quot;display-1&quot;&gt;比标题字体大&lt;/div&gt;&lt;div class=&quot;leader&quot;&gt;变大强调&lt;/div&gt;&lt;p&gt;&lt;mark&gt;高亮&lt;/mark&gt;&lt;/p&gt;&lt;p&gt;普通&lt;span class=&quot;mark&quot;&gt;高亮&lt;/span&gt;文本&lt;/p&gt;&lt;p&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;/p&gt;&lt;p&gt;&lt;s&gt;删除线&lt;/s&gt;&lt;/p&gt;&lt;p&gt;&lt;ins&gt;下划线&lt;/ins&gt;&lt;/p&gt;&lt;p&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;粗体&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;/p&gt;&lt;p&gt;&lt;abbr title=&quot;请输入你的邮箱&quot; class=&quot;initialism&quot;&gt;email&lt;/abbr&gt;&lt;/p&gt;&lt;blockquote class=&quot;blockquote&quot;&gt; 引用在此&lt;/blockquote&gt;&lt;code&gt;代码块&lt;/code&gt;&lt;var&gt;变量斜体&lt;/var&gt;&lt;kbd&gt;用户输入，黑色背景白色字体&lt;/kbd&gt; 3：图片和图片框1234567891011121314&lt;img src=&quot;../img/lg.img&quot; alt=&quot;&quot; class=&quot;img-fluid img-thumbnail w-100&quot;&gt;&lt;div&gt; &lt;img src=&quot;&quot; class=&quot;rounded float-left&quot;&gt;//圆角 &lt;img src=&quot;&quot; class=&quot;rounded float-right&quot;&gt; &lt;img src=&quot;&quot; class=&quot;rounded d-block mx-auto&quot;&gt;//转为块级元素，然后居中对齐&lt;/div&gt;&lt;picture&gt; &lt;source srcset=&quot;../images/lg.jpg&quot; media=&quot;(min-width:992px)&quot;&gt; &lt;source srcset=&quot;../images/md.jpg&quot; media=&quot;(min-width:576px)&quot;&gt; &lt;img src=&quot;../images/sm.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt;&lt;!--设置不同屏幕显示不同尺寸图片--&gt; 4：表格12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;br&gt; &lt;div class=&quot;table-responsive&quot;&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;HeadingHeadingHeading&lt;/th&gt; &lt;th&gt;HeadingHeadingHeading&lt;/th&gt; &lt;th&gt;HeadingHeadingHeading&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;CellCellCell&lt;/td&gt; &lt;td&gt;CellCellCell&lt;/td&gt; &lt;td&gt;CellCellCell&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 条纹状表格：使用.table-striped样式定义&lt;tbody&gt;可以产生逐行交替变化的背景色。同.table-dark结合使用改变变化背景色为黑夜主题。 表格边框：使用。table-bordered产生表格边框与间隙。table-borderless无边界表格。 悬停效果：table-hover悬停时，背景高亮。 缩紧表格：table—sm可以将表格padding值缩减为原来的一般。 Caption表格辅助标题：&lt;caption&gt;默认是隐藏的，协助屏幕阅读用户找到表格，了解表格内容，并决定是否阅读它。 字体和背景色：table-dark、table-primary、table-secondary、table-warnung、table-success、table-danger、table-info为浅色字体色，将table替换为bg则改为背景色。能加在tr或td上。 响应式滚动条：在table上层添加&lt;div class=&quot;table-responsive&quot;&gt; 5：边框123&lt;span class=&quot;border-top border-secondary rounded-top&quot;&gt;&lt;/span&gt;&lt;span class=&quot;rounded-circle&quot;&gt;圆形或椭圆边框&lt;/span&gt;&lt;span class=&quot;rounded-pill&quot;&gt;圆形或胶囊型&lt;/span&gt; border-top-0清除边框。 6：颜色—Display显示属性12&lt;div class=&quot;d-inline&quot;&gt;&lt;/div&gt;&lt;div class=&quot;d-xl-none&quot;&gt;断点，当屏幕过大时不显示&lt;/div&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://sci.ci/tags/Bootstrap/"}]},{"title":"Linux操作系统","slug":"Linux操作系统学习笔记","date":"2020-02-20T16:40:28.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/02/20/Linux操作系统学习笔记/","link":"","permalink":"https://sci.ci/2020/02/20/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1：Linux简介开源软件： 使用自由 研究自由 散布及改良的自由 LAMP：Linux+Apache+Mysql+PHP 网络配置： 桥接：像一台真实电脑一样直接连接互联网 NAT：类似于使用真实电脑的热点 host only：只允许和真实机通行 ifconfig eth0 192.168.118.2//配置网卡和ip，如果配置为桥接，需要设置为局域网相同网段。此设置重启后失效。 注意事项： Linux严格区分大小写 Linux所有内容以文件形式保存，包括硬件。 Linux目录的作用 目录名 目录的作用 /bin/ 存放系统命令的目录，普通和超级用户都可以执行 /sbin/ 保存和系统环境设置相关的指令，只有超级用户root能使用，但普通用户可以查看 /usr/bin/ 单用户模式下不能使用，类似于win的安全模式 /usr/sbin/ 超级用户才能使用 /boot/ 系统启动目录，保存系统启动相关文件，如内核文件和启动引导程序 /dev/ 设备文件保存位置， /etc/ 配置文件，默认保存在这 /home/ 普通用户的家目录 /lib/ 系统调用的函数库 /lost+found/ 当系统意外崩溃或关机，产生一些文件碎片放在这里。系统启动时，fsck工具会检测这里。每个分区下都有自己的此文件 /media/ 挂载目录，媒体设备 /mnt/ 挂在如优盘、移动硬盘 /misc/ 挂在NFS服务的共享目录 /opt/ 第三方安装的软件保存位置。现在的习惯是，放在/usr/local/，类似于win中的Program Files文件夹。 /proc/ 虚拟文件系统。存放在内存中，保存系统的内核、今后曾、外部设备状态、网络状态。不要再这里面写东西 /sys/ 虚拟文件系统。内存中，保存内核相关 /root/ 超级用户的家目录。普通用户在/home/ /srv/ 服务数据目录。 /tmp/ 临时目录。可以清空 /usr/ 系统软件资源目录。unix software resource /var/ 动态数据保存目录。保存缓存、日志以及软件运行产生的文件。 2：Linux常用命令命令格式 命令 [-选项] [参数] 例： ls -la /etc 说明： 个别命令不遵守此格式 当有多个选项时，可以写在一起 简写选项与完整选项 -a 等于 –all 2.1 目录处理命令2.1.1 展示子目录：ls命令名称：ls 命令原意：list 1234567ls #显示当前目录的非隐藏文件ls -a #all，显示隐藏文件和非隐藏文件，隐藏文件文件名格式：.abcls / #查看根目录，/+文件路径可以查看任意位置ls -l #long，长格式显示，显示文件的详细信息ls -h #human,比如将文件大小单位列出来，人性化显示ls -d #direct，只显示目录本身ls -i #inode，展示i节点，文件的唯一身份标识 ls -l的结果： 123total 31056-rwxr-xr-x 1 root root 3612 Jun 23 19:17 Aria2Drive.sh权限 引用次数 文件所有者 文件所属组 文件大小(单位字节) 文件最近修改时间 文件名 权限：-rw-r–r– 权限第一个参数： - d l 文件 文件夹 软连接 剩余九个参数： rw- r– r– u所有者权限 g所属组权限 o其他人 r读 w写 x执行 2.1.2 新建目录：mkdir命令名称：mkdir 命令原意：创建文件目录 123mkdir /tmp/123mkdir -p /tmp/japan/123 #递归创建目录，japan目录原来也没有mkdir -p /tmp/japan/123 /temp/japan/456 #创建多个目录 2.1.3 切换目录：cd123cd /tmp/japan/123 #切换到指定目录cd . #表示当前目录cd .. #回到上级目录 2.1.4 展示当前完整路径：pwd1pwd #显示当前位置的完整路径 2.1.5 删除空目录：rmdir1rmdir /tmp/japan/123 2.1.6 复制：cp12345cp /etc/grab.conf /root #复制文件cp -r /tmp/japan/123 /root #复制目录cp /tmp/japan/123.log /tmp/japan/456.log /tmp #复制多个文件cp -p /tmp/abc.log /tmp #保存文件的属性不变，比如最近修改的时间。cp /tmp/japan/abc.log /tmp/gaiming.log #拷贝并改名 2.1.7 移动、剪切：mv123mv /tmp/japan/123 /tmp #把123移动到/tmp目录下mv /tmp/japan/123 /tmp/us #移动并改名mv 123 456 #当前目录下移动并改名，则是重命名 2.1.8 删除：rm123rm grab.conf #删除文件rm -f grab.conf #强制删除文件，不会询问是否确认。rm -r /tmp/japan #删除目录 2.2 文件处理命令2.2.1 新建文件：touch12touch japanlovestory.list #新建文件touch &quot;program files&quot; #创建带空格文件，不推荐带空格文件名 2.2.2 浏览短文件：cat12cat /etc/issue #显示内容cat -n /etc/issue #显示行号 2.2.3 按行反向显示浏览：tac2.2.4 分页浏览长文件：more1more /etc/services #空格或f向下翻页，按行向下翻，按q退出，帮助信息都是调用more命令。 不能往上翻。 2.2.5 可向上分页浏览：less123less /etc/services #向下翻页和more相同，按pgup向上翻页，上箭头向上一行。#搜索功能，浏览状态，输入“/service”，按“n”向下找搜索结果。 2.2.6 浏览文件前几行：head12head /etc/services #默认显示前十行head -n 7 /etc/services #显示前七行 2.2.7 浏览文件末尾几行：tail123tail /etc/services #显示末尾几行tail -n 7 /etc/services #显示指定行tail -f /var/log/messages #动态显示文件末尾几行 2.3 链接命令生成链接文件：ln 12ln -s /etc/issue /tmp/issue.soft #创建文件的软连接ln /etc/issue /tmp/issue.hard #创建文件的硬链接 软连接：类似windows的快捷方式 硬链接：硬链接和源文件属性相同，且同步更新，可以向硬链接中写入内容，删除源文件后，硬链接任然存在。硬链接的i节点与源文件相同。 硬链接不能跨分区，生成对象不能是目录 2.4 权限管理命令2.4.1 文件权限变更：chmod命令名称：chmod（change the permissions mode of a file） 语法： chmod [{ugoa}]{+-=}[文件或目录] ​ [mode=421][文件或目录] ​ -R 递归修改 权限只有管理员root和所有者可以修改。 12chmod g+w,o-r japan.list #所属组加读权限，其他人减少读权限chmod g=rwx japn.list 数字表述法： r w x 4 2 1 rwxrw-r–对应权限：(4+2+1)(4+2)(4)=764 1chmod -R 777 /tmp/abc #修改/tmp/abc及其下面的的所有文件的权限为777 root用户创建的644权限文件，其他用户能否删除？ 答案取决于用户是否具有文件所属的目录的写权限。 比如：一个目录/temp权限为777 文件/temp/testfile的权限为644。 那么普通用户任然可以删除/temp/testfile，因为所有人都有/tmp目录的写权限，所以可以再/temp目录下新建文件、目录、删除目录和删除文件。 r读权限 w写权限 x执行权限 file cat/more/less/head/tail vim script command directory ls touch/mkdir/rmdir/rm cd 2.4.2 文件所有者变更：chown语法： chown [用户] [文件或目录] 12useradd shenchao #添加一个用户chown shenchao /tmp/japan #改变所有者 2.4.3 文件所属组变更：chgrp12groupadd lampbrother #新建组chgrp lampbrother /tmp/japan #更改所属组 2.4.4 显示新建文件的缺省权限：umask123umask -S #显示新建目录缺省权限umask #显示新建目录缺省权限的与值umask 077 #修改新建文件的缺省权限为700.原理为，777与077得700 0022 0：特殊权限 022：— -w- -w- 则目录的权限为：777和022逻辑与的结果，等于755 2.5 文件搜索命令2.5.1 文件搜索命令：find语法：find [搜索范围] [匹配条件] 1234find /etc -name init #在/etc目录下搜索名为init的文件，initab不能被搜索到。find /etc -name *init* #名字包含init就会被搜索，*作为通配符find /etc -name int??? #?find /etc -iname init??? #搜索名字不区分大小写。 1find / -size +204800 #查找大于100MB文件，按数据块算，一个数据块=0.5K。204800个数据块=100MB 1find / -user shenchao #根据所有者查找 123find /etc -cmin -5 #根据文件属性5分钟内被改的文件查找 changefind /etc -amin -5 #根据访问时间 accessfind /etc -mmin -5 #根据文件内容被改变 modify 12find /etc -size +163840 -a -size -204800 #查找大于80MB并且小于100MB的文件find /etc -size +163840 -o -size -204800 #查找大于80MB或者小于100MB的文件 1find /etc -name init* -a -type f #查找类型为文件的init*对象 -exec/-ok 对搜索结果进行处理。-ok比-exec多了询问是否操作过程 1find /etc -name inittab -exec ls -l &#123;&#125; \\; #-exec 命令 &#123;&#125; \\;为固定格式 12find /etc -inum 3442 #根据i节点查找文件find /etc -inum 3442 -exec rm &#123;&#125; \\; #删除i节点为3442的文件。可用于名字奇怪的文件 2.5.2 其他文件搜索命令：locate在文件资料库中查找文件，速度非常快。但是不能及时更新。 12locate inittab #查找inittab的位置locate -i inittab #查找时不区分大小写 更新资料库 1updatedb locate无法收录/tmp目录下的文件 2.5.3 命令文件搜索命令：which对命令使用 1which cp #查找命令绝对路径的位置，并且得到命令是否有别命 2.5.4 命令文件搜索命令：whereis1whereis rm #找到命令绝对路径，和命令的帮助文档所在位置 2.5.5 文件内容搜索命令：grep 参数 作用 -i 不区分大小写 -v 排除指定字串 12grep multiuser /etc/inittab #查找文件中multiuser所在的行。grep -v ^# /etc/inittab #排除指定字串所在的行，即以#开头的行，不希显示。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/tags/Linux/"}]},{"title":"Kali Linux的学习和使用","slug":"Kali-Linux的学习和使用","date":"2020-02-19T11:05:29.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/02/19/Kali-Linux的学习和使用/","link":"","permalink":"https://sci.ci/2020/02/19/Kali-Linux%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"0：Kali简介Kali作为最常用的网络渗透系统，内置了网络安全人员和黑客最常用的各类工具。 1：Kali安装安装途径： 在VMWare虚拟机上安装Kali，Kali Linux 系统安装详细教程 在Vultr上上传自定义的IOS。将Kali部署到服务器上。 常见问题： 切换图形界面和命令界面，当主机内存小于2g时，使用图形界面体验更好。 切换命令界面：Ctrl+Alt+F3 切换图形界面：Ctrl+Alt+F1 在新版本Kali Linux2020中默认系统登陆为非超级管理员权限，也就是说不是root权限。在安装过程中，只有普通用户的用户名和密码设置。不会涉及root密码的设置。现在为root设置密码。 命令界面输入sudo passwd root 输入新密码，重复输入新密码。密码设置完成。 开启SSH，如果你在服务器中安装了Kali，这个操作是必须的，他能让你使用其他终端，登陆Kali。 命令界面输入sudo vim /etc/ssh/sshd_config。 修改部分内容为如下： 123456#AuthenticationLoginGraceTime 2mPermitRoootLogin yesStrictModes yesMaxAuthTries 0MaxSessions 10 保存退出 重启ssh service ssh restart 查看ssh是否启动，service ssh status 如果显示active则已生效，现在可以使用ssh登陆了。 3：被动信息收集3.1 常用查询指令和工具Ctrl+L:清屏 ping sci.ci:查看域名的访问速度 nslookup baidu.com:域名服务器查询。 dig @8.8.8.8 baidu.com any:查询，@8.8.8.8域名服务器记录的baidu.com域名解析记录。any:查询所有记录。不加只查A记录。+noall +answer只输出域名记录结果。 dig -x 35.201.203.235：查询反向解析，ptr记录，需要有解析记录才行 dig txt chaos VERSION.BIND @ns3.dnsv4.com:查询Dns服务器版本。通过版本信息查找漏洞 whois baidu.com:查询注册信息 查询接口： 备案信息：http://www.beianbeian.com 天眼查：https://www.tianyancha.com 3.2 子域名挖掘 子域名挖掘工具：Maltego子域名挖掘机 搜索引擎：site:qq.com 第三方网站：http://tool.chinaz.com/subdomain、https://dnsdumpster.com 3.3 Maltego使用3.4 Shodan搜索技巧https://www.shodan.io 搜索技巧： webcam//网络摄像头 city:beijing webcam//位于北京的摄像头 net:35.201.203.235//查询到ip绑定的域名等信息 port:9200//搜索开启9200端口的服务器 3.5 Google搜索引擎的使用技巧 inurl:qq.txt文件 inurl:admin_login.asp登陆界面 intitle:index.of .bash_history表示网站目录对我们开放，我i们可以看到该目录下所有文件的信息。.文件名表示隐藏目录。 查找mysql的配置文件，my.cnf 查找discuz论坛中储存mysql密码的配置文件confg_global.php cache:baidu.com搜索缓存的页面，虽然某些页面被删了 Kali filetype:torrentKali时关键词，搜索Kali相关的指定文件类型 apache site:baidu.com 某网站下的关键词 intext:user.sql intitle:index.of查询包含user.sql用户信息数据的网站，并且网站目录可见 s3 site:amazonaws.com filetype:xls passwords3关键字，亚马逊的一种服务器类型。 总结：谷歌黑客数据库：https://www.exploit-db.com/google-hacking-database 4: 信息收集4.1 主动采集 ping 192.168.1. -c 1-c 1发一个ping包就停止，默认一直发 traceroute baidu.com检测路由 ARP：将ip解析为MAC物理地址 使用apring命令查看局域网中的IP是否有冲突 如何在Kali中排查黑客是否冒充网关进行中间攻击？ 伪装机配置：ifconfig ens33 192.168.1.1 Kali探测：arping 192.168.1.1 -c 1//查看局域网中是否存在arp攻击，出现两个MAC地址对应IP地址，就有ARP攻击了。 netdiscover -i eth0 -r 192.168.1.0/27查看局域网中存活的设备。 -i 是网络设备，网卡。-r 表示扫描范围 4.2 被动采集netdiscover -p扫描局域网中的设备，不容易被管理员发现 4.3 用Hping3对服务器进行DOS攻击hping3 -c 1000 -d 120 -s -w 64 -p 80 --flood --rand-source baidu.com -c 发送包的数量 -d 发送到目标机器的每个数据包的大小。单位是字节 -s 只发送SYN数据包 -w TCP窗口大小 -p 目的地端口（80是web端口） –flood 洪水攻击模式，尽可能快地发送数据包 –rand-source 使用随机性的源头ip地址。只是在局域中伪造 4.4 使用Nmap进行半连接扫描nmap -sS 101.200.128.35 -p 80,81,21,25,110,443看某个端口是否开启 nmap -sS 101.200.128.35查看其打开的端口，但不会完全扫描65535个端口 nmap -sS 101.200.128.35 -p 1-1024指定端口范围 4.5使用nc扫描端口nc -nv -w 1 -z 192.168.1.1 1-100 实现任意TCP/UDP端口的监听，nc可以作为server以TCP或UDP方式监听指定端口。 端口的扫描，nc可以作为client发起TCOP或UDP连接。 机器之间传输文件。 机器之间网络测速 nc参数： -nv 表示扫描的目标是个IP地址不做域名解析 -w 表示超时时间，超过时间则不再扫描 -z 表示进行端口扫描 4.6 Scapy定制ARP和ICMP协议数据包伪装网络报文 scapy如果报错弹出：Wont be able to plot apt install python-matplotlib exti()//退出Scapy ARP().display()//列出arp相关参数","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://sci.ci/tags/Kali-Linux/"}]},{"title":"Flutter学习记录","slug":"Flutter学习记录","date":"2020-02-15T16:32:32.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/02/15/Flutter学习记录/","link":"","permalink":"https://sci.ci/2020/02/15/Flutter%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1：Flutter介绍 市面上有很多混合开发框架，比如ReactNative、lonic，但都是针对前端开发。 Flutter针对全部开发者的混合框架。 需要Dart语言基础。 2：Flutter目录结构、入口、自定义Widget、Center等组件 目录：ios，android，build，lib，text，pubspec.yaml（配置依赖），main.dart 入口文件、方法：再main.dart中 12345678910111213141516171819202122232425262728293031323334353637383940import &#x27;package:flutter/material.dart&#x27;;void main()&#123; runApp(new MyApp())//new 再Dart中可以省略&#125;//void main()=&gt;runApp(MyApp());//自定义组件class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return MaterialApp( home:Scaffold( appBar:AppBar( title:Text(&#x27;Flutter Demo&#x27;) ), body:HomeContent(), ), theme:ThemeData( primarySwatch:Colors.blue ), ) &#125;&#125;class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context)&#123; return Center(//内容居中的LinearLayout child:Text( &#x27;Hello Flutter&#x27;， textDirection:TextDirection.ltr,//文字方向从左到右 style:TextStyle( fontSize:40.0, color:Colors.yellow, //color:Color.formRGBO(244,233,121,0.5), ), ) ); &#125;&#125; 3：Container组件、Text组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#x27;package:flutter/material.dart&#x27;;void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; return MaterialApp( home:Scaffold( appBar: AppBar( title: Text(&quot;flutter demo&quot;), ), body: HomeContent(), ) ); &#125;&#125;class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Center( child: Container( child: Text(&#x27;各位同学大家好，我是珠江老师阿发是否你好吗&#x27;, textAlign: TextAlign.left, style: TextStyle( fontSize: 16, color: Colors.red, fontWeight: FontWeight.w800,//加粗 fontStyle: FontStyle.italic,//斜线 decoration: TextDecoration.lineThrough, decorationColor: Colors.white, decorationStyle: TextDecorationStyle.dashed, letterSpacing: 5 ), overflow: TextOverflow.ellipsis, maxLines: 2, textScaleFactor: 1.2,//size scale 2 times ), height: 300, width: 300, decoration: BoxDecoration( color: Colors.yellow, border: Border.all( color: Colors.blue, width: 2 ), borderRadius: BorderRadius.all( Radius.circular(20) ) ), padding: EdgeInsets.all(10), margin: EdgeInsets.all(10), //transform: Matrix4.translationValues(100, 0, 0), transform: Matrix4.rotationZ(0.3), alignment: Alignment.bottomLeft, ), ); &#125; &#125; 4：图片组件Image、本地图片、远程图片、图片裁剪4.1 网络图片和样式 网络图片： 123456789101112131415161718192021class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Center( child: Container( child: Image.network(&quot;https://i0.hdslb.com/bfs/archive/9377fda78c8a873085bd133e4fc54699ab56746d.jpg@336w_190h.webp&quot;, alignment: Alignment.center, //color: Colors.yellow, //colorBlendMode: BlendMode.screen, fit: BoxFit.cover,//cover：拉伸剪切，但不变形。最常用 //repeat: ImageRepeat.repeatX,//X轴平铺 ), width: 300, height: 300, decoration: BoxDecoration( color: Colors.lightBlue ), ), ); &#125; 容器装饰图片 12345678910111213141516171819class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Center( child: Container( width: 300, height: 300, decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(150), image: DecorationImage( image: NetworkImage(&quot;https://i0.hdslb.com/bfs/archive/b13bfd82fdea672001554eca19c6bf7135e2f692.jpg@336w_190h.webp&quot;), fit: BoxFit.cover ) ), ), ); &#125; ClipOval 123456789101112131415161718class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Center( child: Container( child: ClipOval( child: Image.network(&quot;https://i0.hdslb.com/bfs/archive/b13bfd82fdea672001554eca19c6bf7135e2f692.jpg@336w_190h.webp&quot;, height: 100, width: 100, fit: BoxFit.cover, ), ), ), ); &#125; &#125; 4.2 引入本地图片 在项目根目录下新建文件夹images build images 2.0x 3.0x 4.0x 在文件夹里放入图片，会根据屏幕分辨率配置不同图片 在pubspec.yaml中配置 123assets:- images/2.0x/a.jpeg- images/3.0x/a.jpeg 在代码中使用 12345678910class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Center( child: Container( child: Image.asset(&#x27;images/a.jpeg&#x27;), ), ); &#125; 5：ListView组件5.1 基本列表 垂直列表 ListTile组件 123456789101112131415161718192021222324252627282930class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return ListView( padding: EdgeInsets.all(10), children: &lt;Widget&gt;[ ListTile( leading: Icon(Icons.settings,color: Colors.red,),//前置图标 title: Text(&quot;1你好列表组件&quot;,style: TextStyle( fontSize: 24 ),), subtitle: Text(&quot;1你好我是二级标题&quot;), ), ListTile( title: Text(&quot;1你好列表组件&quot;), subtitle: Text(&quot;1你好我是二级标题&quot;), trailing: Icon(Icons.home,size: 30,),//后置图标 ), ListTile( leading: Image.network(&quot;https://i0.hdslb.com/bfs/sycp/creative_img/202002/849753c8234f501092c0b8ae6af5b679.jpg&quot;), title: Text(&quot;你好列表组件&quot;), subtitle: Text(&quot;你好我是二级标题&quot;), ), ], ); &#125; &#125; 垂直图文列表 1234567891011121314151617181920212223class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return ListView( padding: EdgeInsets.all(10), children: &lt;Widget&gt;[ Image.network(&quot;https://i0.hdslb.com/bfs/sycp/creative_img/202002/849753c8234f501092c0b8ae6af5b679.jpg&quot;), Container( child: Text(&quot;i am title&quot;,textAlign: TextAlign.center,style: TextStyle(fontSize: 18),), height: 40, padding: EdgeInsets.fromLTRB(0, 10, 0, 10), ), Image.network(&quot;https://i0.hdslb.com/bfs/sycp/creative_img/202002/849753c8234f501092c0b8ae6af5b679.jpg&quot;), Container( child: Text(&quot;i am title&quot;,textAlign: TextAlign.center,style: TextStyle(fontSize: 18),), height: 40, padding: EdgeInsets.fromLTRB(0, 10, 0, 10), ), ], ); &#125;&#125; 水平列表 1234567891011121314151617181920212223242526272829303132333435363738class HomeContent extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Container( height: 180, child: ListView( padding: EdgeInsets.all(10), scrollDirection: Axis.horizontal, children: &lt;Widget&gt;[ Container( width: 180, height: 180, color: Colors.red, ), Container( width: 180, height: 180, color: Colors.orange, child: ListView( children: &lt;Widget&gt;[ Image.network(&quot;https://i0.hdslb.com/bfs/sycp/creative_img/202002/849753c8234f501092c0b8ae6af5b679.jpg&quot;), Text(&quot;i am text&quot;) ], ), ), Container( width: 180, height: 180, color: Colors.blue, ), ], ), ); &#125; &#125; scrollDirection 5.2 ListView列表组件、动态列表 展示一个列表中的数据 1234567891011121314151617181920class HomeContent extends StatelessWidget&#123; //自定义方法 List&lt;Widget&gt; _getData()&#123; List&lt;Widget&gt; list=new List(); for(var i=0;i&lt;20;i++)&#123; list.add(ListTile( title: Text(&quot;iam $i list&quot;), )); &#125; return list; &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return ListView( children: _getData() ); &#125; &#125; ListView.builder 1234567891011121314151617181920212223class HomeContent extends StatelessWidget&#123; List list=new List(); HomeContent()&#123; for(var i=0;i&lt;20;i++) &#123; list.add(ListTile( title: Text(&quot;iam $i list&quot;), )); &#125; &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return ListView.builder( itemCount: this.list.length, itemBuilder: (context,index)&#123; return ListTile( title: Text(this.list[index]), ); &#125; ); &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://sci.ci/tags/Flutter/"}]},{"title":"Vue、Vuejs学习记录","slug":"Vue、Vuejs学习记录","date":"2020-02-15T16:31:51.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/02/15/Vue、Vuejs学习记录/","link":"","permalink":"https://sci.ci/2020/02/15/Vue%E3%80%81Vuejs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"0：ES6补充0.1 块级作用域12345678910111213141516171819202122232425&lt;script&gt; //变量作用域：变量在什么范围内可用 &#123; var name = &#x27;why&#x27;; console.log(name); &#125; console.log(name);//在大括号外也能打开。 //没有块级作用域会导致什么问题 var btns = document.getElementsByTagName(&#x27;button&#x27;); for(var i = 0; i&lt;btns.length;i++)&#123; btns[i].addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;第&#x27;+i+&#x27;个按钮被点击&#x27;) &#125;) &#125; //显示的按钮被点击不准确。使用闭包解决此问题 for(var i = 0; i&lt;btns.length;i++)&#123; (function(num)&#123; btns[num].addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;第&#x27;+num+&#x27;个按钮被点击&#x27;) &#125;) &#125;)(i) &#125;&lt;/script&gt; 1：Vue初体验1.1 认识Vuejs作为时下流行的前端框架，Vuejs是很多中小型企业开发项目的首选框架。 Vue是一个渐进式的框架。 渐进式意味着可以将Vue作为应用的一部分嵌入进去，带来更丰富的交互体验。 Vue特点和Web开发中的高级功能 解耦视图和数据 可复用的组件 前端路由 状态管理 虚拟DOM 学习前提 不需要Angular、React、jQuery 需要HTML、CSS、JavaScript基础 1.2 Vue.js安装方式一：直接CDN引入 方式二：下载和引入 安装教程 https://cn.vuejs.org 开发环境 https://vuejs.org/js/vue.js 生产环境 https://vuejs.org/js/vue.min.js 方式三：NPM安装 通过webpack和CLI 1.3 Hello VuejsVue的响应式 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt; &#123;&#123;name&#125;&#125; &lt;/h1&gt; &#123;&#123;message&#125;&#125; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //let(变量)/const(常量) //编程范式：声明式编程 const app = new Vue(&#123; el:&#x27;#app&#x27;,//用于挂在要管理的元素 data:&#123;//定义数据 message:&#x27;你好啊！&#x27;,//在div中显示message内容 name:&#x27;coderwhy&#x27; &#125; &#125;) //原始js的做法（编程范式：命令式编程） //1.创建div元素，设置id属性 //2.定义一个变量叫message //3.将message变量放在div元素中显示 //4.修改messge的数据 //5.将修改后的数据替换到div元素 &lt;/script&gt; &lt;/body&gt; 1.4 Vue列表显示1234567891011121314151617&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in movies&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; message:&#x27;你好啊&#x27;， movies:[&#x27;海王&#x27;,&#x27;大话西游&#x27;,&#x27;星际穿越&#x27;,&#x27;少年派&#x27;] &#125; &#125;) &lt;/script&gt;&lt;/body&gt; app.movies.push(&#39;盗梦空间&#39;)//添加数据 使用v-for指令遍历数组元素 案例展示：计数器 当前计数：0 + - //语法糖：简写 const app = new Vue({ el:'#app', data:{ counter:0 } }) 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2&gt; 当前计数：&#123;&#123;counter&#125;&#125; &lt;/h2&gt; &lt;!--&lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;--&gt; &lt;!--&lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt;--&gt; &lt;button v-on:click=&quot;add&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;min&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; counter:0 &#125;, methods:&#123; add:function()&#123; console.log(&#x27;add被执行&#x27;)； this.counter++; &#125;, min:function()&#123; console.log(&#x27;min被执行&#x27;)； this.counter--; &#125; &#125; &#125;) //原始js //1.拿buttom元素 //2.添加监听时间 &lt;/script&gt;&lt;/body&gt; 新属性：methods，该属性用于Vue对象中定义方法。 新指令：@click，该指令用于监听某个元素的点击事件。 1.5 Vue中的MVVM什么是MVVM？ Model View ViewModel 1.6 创建Vue实例传入的options目前掌握的选项 el： 字符型String|HTMLElement 决定Vue管理哪一个DOM data： Object|Funtion()（组件当中必须是一个函数） Vue实例对应的数据对象。 methods： {[key:string] Function} 定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用 1.7 Vue的生命周期生命周期：事物从诞生到消亡的整个过程 123456789&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:obj, methods:&#123;&#125;, created:function()&#123;&#125;, mounted:function()&#123;&#125; &#125;)&lt;/script&gt; 1.8 Vue的生命周期函数12345678910&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:obj, methods:&#123;&#125;, beforeCreate:function()&#123;&#125;,//Hook:钩子函数 created:function()&#123;&#125;, mounted:function()&#123;&#125; &#125;)&lt;/script&gt; 生命周期函数：beforeCreate,create,beforeMounte,mounted,beforeUpdate,updated,beforDestroy,destroyed 2：插值的操作2.1 Mustache语法，插值的操作Mustache语法：双大括号//mustache胡须 123456789101112131415161718192021222324&lt;div&gt; &lt;h2&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt; &lt;h2&gt; &#123;&#123;firstName+&#x27; &#x27;+lastName&#125;&#125; &lt;/h2&gt; &lt;h2&gt; &#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; &lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter*2&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; message:&#x27;nihao&#x27;, firstName:&#x27;kobe&#x27;, lastName:&#x27;bryant&#x27;, counter:100 &#125;, &#125;)&lt;/script&gt; mustache语法不仅可以直接写变量，还可以写语法。 2.2 插值操作–其他指令使用 v-once: 不想改变DOM值，使DOM变成非响应式。 123&lt;h2 v-once&gt; &#123;&#123;message&#125;&#125;&lt;!--message不会随数据更新而改变--&gt;&lt;/h2&gt; v-html:直接展示html代码，而不是展示其字符串 1234567891011&lt;div&gt; &lt;h2 v-html=&quot;url&quot;&gt;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; url=&#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;&#x27; &#125; &#125;)&lt;/script&gt; 输出结果：百度一下 v-text：和作用相同，但会覆盖&lt;h2&gt;代码块中的字符会被覆盖掉，不灵活。 12345678910111213141516&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2 v-text=&quot;message&quot;&gt;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;,//用于挂在要管理的元素 data:&#123;//定义数据 message:&#x27;你好啊！&#x27; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; v-pre：将例如大括号显示出来，不渲染数据 123&lt;h2 v-pre&gt; &#123;&#123;message&#125;&#125;&lt;/h2&gt; 输出结果： v-cloak：当js延迟加载出来时，不显示dom渲染之前的值。不会在渲染之前出现//cloak斗篷 12345678910111213&lt;!--&lt;head&gt; &lt;style&gt; [v-cloak]&#123; display:none; &#125; &lt;/style&gt;&lt;/head&gt;--&gt;&lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt; ...&lt;/script&gt; 3：动态绑定属性3.1 v-bind，动态绑定DOM属性 v-bind的基本使用 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img v-bind:src=&quot;imgURL&quot; alt=&quot;&quot;&gt; &lt;a v-bind:href=&quot;aHref&quot;&gt;&lt;/a&gt; &lt;!--语法糖的写法--&gt; &lt;img :src=&quot;imgURL&quot; alt=&quot;&quot;&gt; &lt;a :href=&quot;aHref&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;,//用于挂在要管理的元素 data:&#123; aHref=&quot;https://www.baidu.com&quot;, imgURL:&#x27;https://i0.hdslb.com/bfs/sycp/creative_img/202002/1e9bfa663a93374c8e10c3933cfc78f8.jpg&#x27; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; v-bind简写/语法糖：: v-bind对象用法： 123456789101112&lt;div&gt; &lt;h2 class=&quot;title&quot; :class=&quot;&#123;class1:isClass1,class2:isClass2&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; data:&#123; message:&quot;showClassExample&quot; isClass1:true, isClass2:false &#125; &#125;)&lt;/script&gt; //title类固定，动态更改class1和class2 &#123;类名:布尔值,类名：布尔值&#125; v-bind数组语法 1234567891011121314151617&lt;div&gt; &lt;h2 class=&quot;title&quot; :class=&quot;getClasses()&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; data:&#123; message:&quot;showClassExample&quot;, isClass1:true, isClass2:false &#125; methods:&#123; getClasses:function()&#123; return&#123;class1:this.isClass1,class2:this.isClass2&#125; &#125; &#125; &#125;)&lt;/script&gt; 注意：v-on中函数省略了()，但v-bind需要添加() 123456789101112&lt;div&gt; &lt;h2 class=&quot;title&quot; :class=&quot;[class1,class2]&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; data:&#123; message:&quot;showClassExample&quot;, class1:&#x27;class1&#x27;, class2:&#x27;class2&#x27; &#125; &#125;)&lt;/script&gt; 3.2 作业，结合v-for和v-bind作业：使用v-for显示一个电影名称列表，设置监听点击事件，当某个电影被点击，改变此电影名称字体颜色为红色。 答案： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .red&#123;color:red&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(m, index) in movies&quot; @click=&quot;clickItem=index&quot; :class=&quot;&#123;red:clickItem==index&#125;&quot;&gt;&#123;&#123;m&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;, data: &#123; movies: [&#x27;复仇者联盟&#x27;, &#x27;生化危机&#x27;, &#x27;星际大战&#x27;, &#x27;钢铁侠&#x27;], clickItem:99, &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.3 v-bind动态绑定样式 样式的对象用法 12345678910111213&lt;div&gt; &lt;h2 :style=&quot;&#123;fontSize:&#x27;50px&#x27;,color:finalColor&#125;&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; data:&#123; message:&#x27;abc&#x27;, finalColor:&#x27;red&#x27; &#125; &#125;)&lt;/script&gt; 注意：{fontSize:50px}为错误表达，50px会被解析为一个变量，50px必须加单引号 样式的数组用法 123456789101112131415&lt;div&gt; &lt;h2 :style=&quot;[style1,style2]&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; message:&#x27;abc&#x27;, style1:&#123;fontSize:&#x27;100px&#x27;&#125;, style2:&#123;color:&#x27;red&#x27;&#125; &#125; &#125;)&lt;/script&gt; 4：计算属性4.1 计算属性的基本用法123456789101112131415161718192021222324252627282930&lt;div id=&quot;app&quot;&gt; &lt;h2&gt; &#123;&#123;firstName+&quot; &quot;+lastName&#125;&#125; &lt;/h2&gt; &lt;h2&gt; &#123;&#123;getFullName()&#125;&#125; &lt;/h2&gt; &lt;h2&gt; &#123;&#123;fullName&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; firstName:&#x27;Lebron&#x27;, lastName:&#x27;James&#x27; &#125;, computed:&#123; fullName:function()&#123; return this.fistName+&#x27; &#x27;+this.lastName; &#125; &#125;,//计算属性 methods:&#123; getFullName()&#123; return this.fistName+&#x27; &#x27;+this.lastName; &#125; &#125; &#125;)&lt;/script&gt; computed:计算属性的使用 4.2 计算属性的复杂使用1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;app&quot;&gt; &lt;h2&gt; 总价格：&#123;&#123;totalPrice&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; books:&#123; &#123;id:110,name:&#x27;Unix编程&#x27;,price:119&#125;, &#123;id:111,name:&#x27;代码大全&#x27;,price:89&#125;, &#123;id:112,name:&#x27;现代操作系统&#x27;,price:81&#125; &#125; &#125;, computed:&#123; totalPrice:function()&#123; for(let i=0;i&lt;this.books.length;i++)&#123; result += this.books[i].price; &#125; /* for(let i in this.books)&#123; result += this.books[i].price; &#125; for(let book of this.books)&#123; result += book.price; &#125; */ return result; &#125; &#125;,//计算属性 &#125;)&lt;/script&gt; 4.3 计算属性setter和getter1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;h2&gt; &#123;&#123;fullName&#125;&#125; &lt;/h2&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; firstName:&#x27;Kobe&#x27;, lastName:&#x27;Bryant&#x27; &#125;, computed:&#123; /* fullName:&#123;//fullName为一个对象 //一般属性没有set方法，为只读属性 set:function()&#123;&#125;,//通过控制板，app.fullName=&#x27;ABC&#x27;会调用此方法 get:function()&#123; return this.firstName+&#x27; &#x27;+this.lastName; &#125; &#125; */ //上述方法简写为 fullName:function()&#123; return this.firstName+&#x27; &#x27;+this.lastName; &#125; &#125;,//计算属性 &#125;)&lt;/script&gt; 4.4 计算属性和methods对比方法每次调用，程序都会重复执行；计算属性第一次计算出来，结果就保存在内存中。下次再调用，程序不会重复执行。 需要多次调用的计算结果，采用计算属性性能会更低。 4.5 跑马灯项目一句文字实现，点击按钮，文字滚动播放，再点击文字停止滚动。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;lang&quot;&gt;浪起来&lt;/button&gt; &lt;button @click=&quot;di&quot;&gt;低调&lt;/button&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt;&lt;/div&gt;&lt;script&gt; //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data: &#123; msg:&#x27;猥琐发育。别浪~~！&#x27;, intervalId:null &#125;, methods:&#123; lang()&#123; //函数里的this.变量无法指向函数外部的变量 /* setInterval(function()&#123; let start = this.msg.substring(0,1);//获取第一个字符 let end = this.msg.substring(1);//获取第一个字符后的所有字符 this.msg=end+start;//将第一个字符放到最后，实现跑马灯效果 &#125;,400) */ //使用箭头函数解决函数内部this问题 if(this.intervalId!=null) return; this.intervalId = setInterval(()=&gt; &#123; let start = this.msg.substring(0,1);//获取第一个字符 let end = this.msg.substring(1);//获取第一个字符后的所有字符 this.msg=end+start;//将第一个字符放到最后，实现跑马灯效果 &#125;,400) &#125;, di()&#123; clearInterval(this.intervalId); this.intervalId=null;//清楚定时器后需要重新把internalId设为null &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5: 常用指令5.1 v-for的四种使用方式 循环数组 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;item in list&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/p&gt; &lt;p v-for=&quot;(item,index) in list&quot;&gt; &#123;&#123;item+&quot;-----&quot;+index&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; list:[1,2,3,4,5] &#125;, &#125;)&lt;/script&gt; 循环对象数组 1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;item in list&quot;&gt; &#123;&#123;item.id&#125;&#125;--&#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; list:[ &#123;id: 1, name :&#x27;zs1&#x27;&#125;, &#123;id: 2, name :&#x27;zs2&#x27;&#125;, &#123;id: 3, name :&#x27;zs3&#x27;&#125;, &#123;id: 4, name :&#x27;zs4&#x27;&#125;, ] &#125;, &#125;)&lt;/script&gt; 循环对象 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(val,key,index) in user&quot;&gt; &#123;&#123;val&#125;&#125;--&#123;&#123;key&#125;&#125;--&#123;&#123;index&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; user:&#123; id:1, name:&#x27;tuoni&#x27;, gender:&#x27;nan&#x27; &#125; &#125;, &#125;)&lt;/script&gt; 迭代数字 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;!--in后面可以使数组，对象数组，对象，还可以使数字。若为数字，count从1开始--&gt; &lt;p v-for=&quot;count in 10&quot;&gt; 第&#123;&#123;count&#125;&#125;次循环 &lt;/p&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123;&#125;, &#125;)&lt;/script&gt; 注意：count从1开始计数 v-for循环中key属性的使用 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;/label&gt; &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;p v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;input type = &quot;checkbox&quot; &gt; &#123;&#123;item.id&#125;&#125;--&#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;script&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; id:&#x27;&#x27;, name:&#x27;&#x27;, list:[ &#123;id:1,name:&#x27;lisi&#x27;&#125;, &#123;id:2,name:&#x27;yinzheng&#x27;&#125;, &#123;id:3,name:&#x27;zhaogao&#x27;&#125;, &#123;id:4,name:&#x27;hanfei&#x27;&#125;, &#123;id:5,name:&#x27;kongzi&#x27;&#125;, ] &#125;, methods:&#123; add()&#123; this.list.push(&#123;id:this.id,name:this.name&#125;); //this.list.unshift(&#123;id:this.id,name:this.name&#125;); &#125; &#125; &#125;)&lt;/script&gt; 5.2 v-on指令123456789101112131415161718192021222324&lt;body&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; counter:0 &#125;, methods:&#123; show()&#123; alert(&#x27;Hello&#x27;); &#125; &#125; &#125;) //原始js //1.拿buttom元素 //2.添加监听时间 &lt;/script&gt;&lt;/body&gt; 事件修饰符 .stop 阻止冒泡//@click.stop设置再内部DOM。不会触发@click.stop外部DOM的点击事件 .prevent 阻止默认行为//@click.prevent。比如阻止a标签跳转到href地址 .capture 添加事件倾听器实现捕获模式//给外层DOM 添加@click.capture，会先处理外部点击事件。 .self 只当自身被点击才触发事件//给外部DOM添加@click.self，只有点击外部DOM时才能触发它。也可阻止冒泡 .once 只触发一次事件处理函数。 事件修饰符可以叠加使用 @click.prevent.once先后顺序无区别。 5.3 v-model可以实现表单元素的model中的数据双向绑定。v-model只能用在表单元素中，input(redio, text, address, email…),select , checkbox, textarea 1&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt; 简易计算器案例 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;+&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;-&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;*&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;/&quot;&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;button @click=&quot;calculate&quot;&gt;=&lt;/button&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt; const vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; n1:0, n2:0, result:0, opt:&#x27;+&#x27; &#125; methods:&#123; calculate()&#123; switch(this.opt)&#123; case &#x27;+&#x27;: this.result = parseInt(this.n1) + parseInt(this.n2); break; case &#x27;-&#x27;: this.result = parseInt(this.n1) - parseInt(this.n2); break; case &#x27;*&#x27;: this.result = parseInt(this.n1) * parseInt(this.n2); break; case &#x27;/&#x27;: this.result = parseInt(this.n1) / parseInt(this.n2); break; //this.result = eval(this.n1+this.opt+this.n2) //eval会解析字符串并执行 &#125; &#125; &#125; &#125;)&lt;/script&gt; 5.4 v-if和v-show的使用123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;flag=!flag&quot;&gt; 切换 &lt;/button&gt; &lt;h3 v-if=&quot;flag&quot;&gt; 这是v-if控制的元素 &lt;/h3&gt; &lt;h3 v-show=&quot;flag&quot;&gt; 这是v-show控制的元素 &lt;/h3&gt; &lt;/div&gt; &lt;script&gt; //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; flag:true &#125;, methods:&#123; &#125; &#125;) //原始js //1.拿buttom元素 //2.添加监听时间 &lt;/script&gt;&lt;/body&gt; v-if:会删除或创建元素 //v-if消耗切换性能，如果元素设计频繁的切换不要使用。 v-show：不会删除DOM，而是修改其可见属性dispaly:none //如果元素可能永远也不会显示出来，最好使用v-if 6：过滤器概念：Vue.js中允许自定义过滤器，可以用作一些常见的文本格式化。过滤器可以用在两个地方：mustache插值和v-bind 123456&lt;!--过滤器调用格式 &#123;&#123;name | nameope&#125;&#125;--&gt;&lt;script&gt; //过滤器定义语法 //过滤器中的function，第一个参数，永远是过滤器管道符（|）前面传过来的参数 Vue.filter(&#x27;过滤器名称&#x27;,function(data)&#123;&#125;)&lt;/script&gt; 注意:当全局和私有过滤器，使用相同名称时，优先调用私有过滤器 6.1 定义全局过滤器全局过滤器，就是所有的vm实例都能用 过滤器的基本使用 123456789101112131415161718192021222324252627282930&lt;body&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt; &#123;&#123; msg | msgFormat(&#x27;牛逼&#x27;) | test&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; //定义一个Vue全局过滤器 Vue.filter(&#x27;msgFormat&#x27;,function(msg, arg)&#123;//arg是msgFormat输入的参数。第一个为参数msg为默认的插值 return msg.replace(/傻子/g,arg)//正则替换，g表示全部替换 &#125;) //定义多个过滤器 Vue.filter(&#x27;test&#x27;,function(msg)&#123; return msg+&quot;这是第二个过滤器&quot; &#125;) //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; msg:&#x27;你是真的傻子哦,人是傻子，脑袋笨&#x27; &#125;, methods:&#123; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 6.2 定义私有过滤器123456789101112131415161718192021222324&lt;body&gt;&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt; &#123;&#123; msg | msgFormat(&#x27;牛逼&#x27;) | test&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt; //语法糖：简写 const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; msg:&#x27;你是真的傻子哦,人是傻子，脑袋笨&#x27; &#125;, methods:&#123;&#125;, filters:&#123; msgFormat:function(msg, arg)&#123; return msg.replace(/傻子/g,arg)//正则替换，g表示全部替换 &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 7：自定义7.1 自定义按键修饰符123&lt;label&gt;Name：&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.enter=&quot;add&quot;&gt;&lt;/label&gt; @keyup:绑定键盘 内置修饰符.enter .tab .delete .esc .space .up .down .left .right 其他的键可使用js定义的键盘码。比如**@keyup.113**表示F12 。 12345678&lt;label&gt;Name：&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f12=&quot;add&quot;&gt;&lt;/label&gt;&lt;script&gt; //自定义全局按键修饰符 Vue.config.keyCode.f12 = 113&lt;/script&gt; 7.2 自定义指令 定义全局指令 比如自定一个指令v-focus 12345678910111213141516171819&lt;script&gt; //使用Vue.directive()定义全局的指令 //其中：参数1：指令的名称，定义的时候，不要加v-前缀。但在调用的时候必须在指令名称前加v-前缀 //参数2是一个对象，对象身上有一些指令相关的函数，这些函数可以在特定的阶段执行相关操作 Vue.directive(&#x27;focus&#x27;,&#123; bind:function(el)&#123; //每当指令被绑定到元素上时，会执行这个函数。只执行一次 //第一个参数永远时el，表示被绑定了指令的那个元素，el是一个原生的JS对象。 //在元素刚绑定了指令的时候，还没有插入到DOM中去，这时调用focus方法没有作用。 //el.focus &#125;, inserted:function(el)&#123; //inserted表示元素插入到dom中时执行，只执行一次 el.focus &#125;, updated:function()&#123;&#125;,//当vNode更新的时候，会执行。可能多次触发 &#125;)&lt;/script&gt; .focus：JS方法，可以将焦点集中到DOM对象上，类似于，鼠标单击一次输入框。 使用钩子函数参数 el：指令绑定的元素，用来直接操作DOM binding：一个对象，包含以下属性： name:指令名称——color value:指令的绑定值。会计算比如v-color=”1+1”，binding.value=2 expression:指令绑定值，不会计算, binding.expression=’1+1’ 12345678910&lt;div v-color=&quot;&#x27;red&#x27;&quot;&gt; &lt;/div&gt;&lt;script&gt; Vue.directive(&#x27;color&#x27;,&#123; bind:function(el,binding)&#123; el.style.color = binding.value &#125; &#125;)&lt;/script&gt; 定义私有指令 123456789101112131415161718&lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; msg:&#x27;你是真的傻子哦,人是傻子，脑袋笨&#x27; &#125;, methods:&#123;&#125;, filters:&#123;&#125;, directives:&#123; &#x27;color&#x27;:&#123; bind:function(el,binding)&#123; el.style.color = binding.value &#125; &#125; &#125; &#125;)&lt;/script&gt; 简写： 大多数情况下，旨在bind和update钩子上做重复动作，可以简写 1234567&lt;script&gt; directives:&#123; &#x27;color&#x27;:function(el,binding)&#123;//等同于把方法同时写到bind和update中 el.style.color = binding.value &#125; &#125;&lt;/script&gt; 8：vue-resource实现get，post，jsonp请求vue-resource依赖于vue，需要在vue.js后导入vue-resource.js包。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./js/vue-resource.js&quot;&gt;&lt;/script&gt; &lt;div&gt; &lt;button @click=&quot;getInfo&quot;&gt; getInfo &lt;/button&gt; &lt;button @click=&quot;postInfo&quot;&gt; getInfo &lt;/button&gt; &lt;button @click=&quot;jsonpInfo&quot;&gt; getInfo &lt;/button&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; msg:&#x27;你是真的傻子哦,人是傻子，脑袋笨&#x27; &#125;, methods:&#123; getInfo()&#123; this.$http.get(&#x27;http://vue.studyit.io/api/getlunbo&#x27;).then(function(result)&#123; //result是返回的结果，包括头部、数据等 console.log(result.body) &#125;), postInfo()&#123; //手动发起的post请求没有表单数据 //通过post方法的第三个参数，设置提交内容类型为普通表单格式。 this.$http.post(&#x27;http://vue.studyit.io/api/post&#x27;,&#123;&#125;,&#123;emulateJSON:true&#125;).then(result=&gt;&#123; console.log(result.body) &#125;), jsonpInfo()&#123; this.$http.jsonp(&#x27;http://vue.studyit.io/api/jsonp&#x27;).then(result=&gt;&#123; console.log(result.body) &#125;) &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://sci.ci/tags/Vuejs/"}]},{"title":"个人推荐的一些优秀的安卓开源库","slug":"收集一些优秀的安卓开源库","date":"2020-02-01T21:54:53.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/02/01/收集一些优秀的安卓开源库/","link":"","permalink":"https://sci.ci/2020/02/01/%E6%94%B6%E9%9B%86%E4%B8%80%E4%BA%9B%E4%BC%98%E7%A7%80%E7%9A%84%E5%AE%89%E5%8D%93%E5%BC%80%E6%BA%90%E5%BA%93/","excerpt":"","text":"0：引言最近自己在写一个安卓软件，把我做的sci.ci这个网站接入到移动端来。在写这个软件的过程中，遇到了非常多优秀的开源库，这些库简化了我很多工作，在此将他们分享出来。 1：Kongzue Dialog V3自定义Toast对话框，仿IOS设计 项目地址：https://github.com/kongzue/DialogV3 1.1 引入1.1.1Support 版本Maven仓库： 123456&lt;dependency&gt; &lt;groupId&gt;com.kongzue.dialog_v3&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dialog&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1.8&lt;&#x2F;version&gt; &lt;type&gt;pom&lt;&#x2F;type&gt;&lt;&#x2F;dependency&gt; Gradle： 在dependencies{}中添加引用： 1implementation &#39;com.kongzue.dialog_v3:dialog:3.1.8&#39; 1.2 功能1.2.1 基本对话框 1.2.2 输入对话框 1.2.3等待提示对话框 1.2.4底部菜单 1.2.5通知 1.2.6分享对话框 1.2.7全屏 2：YCVideoPlayer视频播放器封装库，仿爱奇艺、优酷。 项目地址：https://github.com/yangchong211/YCVideoPlayer 2.1 引用应用build.gradle中引入 1compile &#39;cn.yc:YCVideoPlayerLib:2.4.9&#39; 2.2 功能A基础功能 A.1.1 能够自定义视频加载loading类型，设置视频标题，设置视频底部图片，设置播放时长等基础功能 A.1.2 可以切换播放器的视频播放状态，播放错误，播放未开始，播放开始，播放准备中，正在播放，暂停播放，正在缓冲等等状态 A.1.3 可以自由设置播放器的播放模式，比如，正常播放，全屏播放，和小屏幕播放。其中全屏播放支持旋转屏幕。 A.1.4 可以支持多种视频播放类型，比如，原生封装视频播放器，还有基于ijkPlayer封装的播放器。 A.1.5 可以设置是否隐藏播放音量，播放进度，播放亮度等，可以通过拖动seekBar改变视频进度。还支持设置n秒后不操作则隐藏头部和顶部布局功能 A.1.6 可以设置竖屏模式下全屏模式和横屏模式下的全屏模式，方便多种使用场景 A.1.7 top和bottom面版消失和显示：点击视频画面会显示、隐藏操作面板；显示后不操作会5秒后自动消失【也可以设置】 B高级功能 B.1.1 支持一遍播放一遍缓冲的功能，其中缓冲包括两部分，第一种是播放过程中缓冲，第二种是暂停过程中缓冲 B.1.2 基于ijkPlayer的封装播放器，支持多种格式视频播放 B.1.3 可以设置是否记录播放位置，设置播放速度，设置屏幕比例 B.1.4 支持滑动改变音量【屏幕右边】，改变屏幕亮度【屏幕左边】，屏幕底测左右滑动调节进度 B.1.5 支持list页面中视频播放，滚动后暂停播放，播放可以自由设置是否记录状态。并且还支持删除视频播放位置状态。 B.1.6 切换横竖屏：切换全屏时，隐藏状态栏，显示自定义top(显示电量)；竖屏时恢复原有状态 B.1.7 支持切换视频清晰度模式 B.1.8 添加锁屏功能，竖屏不提供锁屏按钮，横屏全屏时显示，并且锁屏时，屏蔽手势处理 C拓展功能【这块根据实际情况选择是否需要使用，一般视频付费App会有这个工鞥】 C1产品需求：类似优酷，爱奇艺视频播放器部分逻辑。比如如果用户没有登录也没有看视频权限，则提示试看视频[自定义布局]；如果用户没有登录但是有看视频权限，则正常观看；如果用户登录，但是没有充值会员，部分需要权限视频则进入试看模式，试看结束后弹出充值会员界面；如果用户余额不足，比如余额只有99元，但是视频观看要199元，则又有其他提示。 C2自身需求：比如封装好了视频播放库，那么点击视频上登录按钮则跳到登录页面；点击充值会员页面也跳到充值页面。这个通过定义接口，可以让使用者通过方法调用，灵活处理点击事件。 C.1.1 可以设置试看模式，设置试看时长。试看结束后就提示登录或者充值…… C.1.2 对于设置视频的宽高，建议设置成4：3或者16：9或者常用比例，如果不是常用比例，则可能会有黑边。其中黑边的背景可以设置 C.1.3 可以设置播放有权限的视频时的各种文字描述，而没有把它写在封装库中，使用者自己设定 C.1.4 锁定屏幕功能 D待添加功能 D.1.1 可以支持屏幕截图功能，视频添加水印效果 D.1.2 支持弹幕功能 D.1.3 后期待定，视频拖拽 3：Android-SpinKit加载中样式。 项目地址：https://ybq.github.io/Android-SpinKit 如果第一章的kongzue等待对话框还不足以满足个性化需求，那这个加载库应该足够了。 3.1 引用123dependencies &#123; implementation &#39;com.github.ybq:Android-SpinKit:1.4.0&#39;&#125; 3.2 样式 4：AgentWeb基于安卓原生Webview的浏览器，自动实现视频全屏播放，加入了网页加载进度条 项目地址：https://github.com/Justson/AgentWeb 引入Gradle 123api &#39;com.just.agentweb:agentweb:4.1.2&#39; &#x2F;&#x2F; (必选)api &#39;com.just.agentweb:filechooser:4.1.2&#39;&#x2F;&#x2F; (可选)api &#39;com.download.library:Downloader:4.1.2&#39;&#x2F;&#x2F; (可选) 效果图","categories":[{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/categories/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"安卓开源库","slug":"安卓开源库","permalink":"https://sci.ci/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E6%BA%90%E5%BA%93/"}]},{"title":"创建一个简单的API项目","slug":"创建一个简单的API项目","date":"2020-01-26T21:01:17.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/01/26/创建一个简单的API项目/","link":"","permalink":"https://sci.ci/2020/01/26/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84API%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"0：简介API（应用程序接口），我现在正在做一个安卓项目，需要将mysql数据库里的数据，通过api接口以json格式导出，然后再安卓上解析和使用。 API项目基于php服务器和laravel框架，这个框架听说比较适合做api，当然由于项目简单，我做的API省去了很多验证相关的内容，普通的框架类似thinkphp也能做，这里用laravel为了方便后期补足API的相关内容。 1：域名和LAMP专用于api的域名建议采用类似于api.example.com这样的三级域名，LAMP这四个网站服务器是必须的。 2：laravel安装使用宝塔面板安装好的php，已经自带composer，若没有composer需要先安装。 没有数据库需要先创建数据库。 然后在网站目录下例如/var/www，运行指令 composer create-project laravel/laravel MyProject &quot;5.1.*&quot; 安装laravel。根据提示连接数据库。 3：新建laravel控制器控制器就是当我们访问url时，服务器将运行控制器内的程序，然后返回给浏览器一个内容，这个内容可以是html代码，当然也可以时xml或者json。 在laravel安装目录运行php artisan make:controller Api/LinkController 新建一个名叫LinkController控制器，此时在将在app/Http/Controllers/Api目录下生成一个LinkController.php`文件。打开文件编辑我们想要的程序。 123456789101112131415161718192021222324252627&lt;?php]()namespace App\\Http\\Controllers\\Api;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;use DB;class LinkController extends Controller&#123; //方法一，从数据库获取某一数据 //url中有参数情况，例如https://api.example.com/linkcontroller/searchlinks?type=电影&amp;kw=中国机长 public function searchlinks(Request $request)&#123; $type=$request-&gt;input(&#x27;type&#x27;);//使用request获取url中参数 $kw=$request-&gt;input(&#x27;kw&#x27;); $linksresult = DB::table(&#x27;my_zhlinks&#x27;)-&gt;where(&#x27;type&#x27;, $type)-&gt;get();//从已连接的数据库，找到表单“my_zhlinks”，获取type和带入参数type相同的项。将这些数据保存到linkresult变量中。 //数据库表单my_zhlinks是我自己创建的。 return json_encode($linksresult);//返回一个json数组，不是json对象。 &#125; //方法二，url中不带参数 public function alltype()&#123; $alltypes=DB::table(&#x27;my_zhpreg&#x27;)-&gt;select(&#x27;type&#x27;)-&gt;get(); return json_encode($alltypes); &#125;&#125; 4：修改路由在上面注释中我们看到，要通过searchlinks方法返回一个json数组，url为https://api.example.com/linkcontroller/searchlinks?type=电影&amp;kw=中国机长非常的长，而且不利于我们后期管理api版本。 在routes目录下的api.php是专门用来写Api接口的路由，打开它 123456789101112131415161718&lt;?php]()use Illuminate\\Http\\Request;/*|--------------------------------------------------------------------------| API Routes|--------------------------------------------------------------------------|| Here is where you can register API routes for your application. These| routes are loaded by the RouteServiceProvider within a group which| is assigned the &quot;api&quot; middleware group. Enjoy building your API!|*/Route::namespace(&#x27;Api&#x27;)-&gt;prefix(&#x27;v1&#x27;)-&gt;group(function()&#123; Route::get(&#x27;search&#x27;,&#x27;LinkController@searchlinks&#x27;)-&gt;name(&#x27;search.links&#x27;); Route::get(&#x27;type&#x27;,&#x27;LinkController@alltype&#x27;)-&gt;name(&#x27;type.all&#x27;);&#125;); namespace(&#39;Api&#39;)指定了命名空间，控制器命名空间只要不是在App\\Http\\Controllers下，都需要进一步指明其命名空间，比如LinkController命名空间为App\\Http\\Controllers\\Api。prefix为前缀，我们用来控制版本，group表示，后面的地址拥有相同的命名空间和前缀。修改后的带参数url变为https://api.example.com/api/v1/search?type=电影&amp;kw=中国机长 不带参数的url变为https://api.example.com/api/v1/type 5：总结修改路由后，通过访问链接https://api.example.com/api/v1/search?type=电影&amp;kw=中国机长就可以获得从数据库获取的值了。 下篇讲解使用okhttp和gson获取并解析api里的json数组。","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"API","slug":"API","permalink":"https://sci.ci/tags/API/"}]},{"title":"使用Magento创建电商网站记录","slug":"使用Magento创建电商网站记录","date":"2020-01-24T22:00:48.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2020/01/24/使用Magento创建电商网站记录/","link":"","permalink":"https://sci.ci/2020/01/24/%E4%BD%BF%E7%94%A8Magento%E5%88%9B%E5%BB%BA%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95/","excerpt":"","text":"0：绪论安装教程使用magento中国官网的提示，教程原地址为https://www.magentochina.org/blog/magento-guide/install-magento-2-1-with-composer.html 我是用composer安装magento，composer在宝塔面板安装php时已默认安装了，所以能直接用。若未使用宝塔面板需优先安装composer。使用以下命令下载运行composer。若已有则跳过。 curl -sS https://getcomposer.org/installer | php 使用以下命令将composer添加至全局，以便在任意目录下使用composer指令 mv composer.phar /usr/local/bin/composer 1：php环境配置一下内容的操作，在宝塔控制面板，软件商店，运行环境，php设置里能找到 Magento安装时PHP环境需要检查以下扩展： PHP Extension curl. PHP Extension iconv. PHP Extension mbstring. PHP Extension dom. PHP Extension hash. PHP Extension openssl. PHP Extension xmlwriter. PHP Extension pcre. PHP Extension gd. PHP Extension bcmath. PHP Extension simplexml. PHP Extension spl. PHP Extension xsl. PHP Extension intl. PHP Extension ctype. PHP Extension pdo_mysql. PHP Extension soap. PHP Extension zip. PHP Extension phar. PHP Extension libxml. 取消函数禁用 openlog、syslog、symlink、exec等 还有些函数需要取消禁用，可根据安装时的错误提示操作 2：开始安装打开xshell或其他ssh面板，在使用cd指令，进入网站根目录，例如/var/www，输入指令 composer create-project --repository-url=https://repo.magento.com/ magento/project-community-edition magento2 其中magento2指，网站将被放在/var/www/magento2目录下，删除此字段，magento会放在/var/www目录下。 提示输入username和password。 首先您先登录Magento的官方商店。 点击“Sign In”登录到您的账号，如果还没有账号,需要先注册。 当登录之后，点击”My Access Keys”.如果找不到，可以使用CTRL+F键进行搜索. 点击“Create a New Access Key”后，找到“Generate New”,为自己的Magento2生成一个Key. 记录下生成的Public key及Private key 其中public key是用户名，private key是密码。 完成安装后在网站目录下就没能看到magento2目录了，由于magento需要文件写权限。使用composer安装时，magetno文件的所有者是运行指令时的用户，也就是说通常是root。那么假定网站用户是www，则在运行安装程序时，www将无法对文件进行写操作，因此，需要更改文件权限，或者所有者。。不建议将文件权限修改，我们只需要修改文件所有者即可。。 使用宝塔面板可直接在文件里修改所有者。xshell使用chmod指令，详细方法请自行查阅。请注意：文件所有者不更改，打开http://域名/magento2，无法进入安装界面 修改完毕后就可以直接输入http://域名/magento2/setup进行安装了。如果你遇到这个问题 长时间安装不上，服务器cpu过载问题 请尝试使用指令安装 首先将magento添加到环境变量,请自行修改自己的magento2文件夹位置。 export PATH=$PATH:/var/www/html/magento2/bin 然后cd到magento2安装目录下 12345678910111213141516171819php setup&#x2F;index.php--db_host&#x3D;localhost \\--db_name&#x3D;magento2 \\--db_user&#x3D;root \\--db_pass&#x3D;canbempty \\--backend_frontname&#x3D;admin \\--admin_username&#x3D;username \\--admin_password&#x3D;password \\--admin_email&#x3D;admin@email.local \\--admin_firstname&#x3D;First \\--admin_lastname&#x3D;Last \\--base_url&#x3D;http:&#x2F;&#x2F;magento2.local&#x2F; \\--base_url_secure&#x3D;http:&#x2F;&#x2F;magento2.local&#x2F; \\--language&#x3D;en_US \\--currency&#x3D;USD \\--use_rewrites&#x3D;true \\--use_secure&#x3D;false \\--use_secure_admin&#x3D;false \\--cleanup_database 上面的参数请根据自己的需要进行修改,比如base_url就是您的网址,admin_*将是您后台管理员用户名或密码. 等待安装如果遇到提示 123ERROR 1419 (HY000): You do not have the SUPER privilege andbinary logging is enabled (you *might* want to use the less safelog_bin_trust_routine_creators variable) 请在你的系统中查找my.cnf文件，通常在/etc/my.cnf下，文件中 [mysqld] 标记后加一行内容为log-bin-trust-function-creators=1 然后运行 service mysql restart 重启mysql。然后重新php setup/index.php以及其后指令。完成安装。 123[SUCCESS]: Magento installation complete.[SUCCESS]: Magento Admin URI: &#x2F;admin_xgswztNothing to import. 出现此提示，则完成安装。 然后修改网站伪静态规则，Nginx： 12345678910111213141516171819202122location &#x2F; &#123; index index.html index.php; ## Allow a static html file to be shown first try_files $uri $uri&#x2F; @handler; expires 30d; &#125;location &#x2F;var&#x2F;export&#x2F; &#123; ## Allow admins only to view export folder auth_basic &quot;Restricted&quot;; ## Message shown in login window auth_basic_user_file htpasswd; ## See &#x2F;etc&#x2F;nginx&#x2F;htpassword autoindex on;&#125; location &#x2F;. &#123; ## Disable .htaccess and other hidden files return 404;&#125;location @handler &#123; ## Magento uses a common front handler rewrite &#x2F; &#x2F;index.php;&#125;location ~ .php&#x2F; &#123; ## Forward paths like &#x2F;js&#x2F;index.php&#x2F;x.js to relevant handler rewrite ^(.*.php)&#x2F; $1 last;&#125; 3： 宝塔面板安装失败建议不要采用宝塔面板安装，在使用宝塔面板进行安装后，网站无法运行，查看错误日志，提示http://域名/magento2/magento2文件不存在 修改网站根目录还是无法进入，提示 An error has happened during application run. See exception log for details.","categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Magento","slug":"Magento","permalink":"https://sci.ci/tags/Magento/"}]},{"title":"如何自己开发一个VPN App","slug":"如何自己开发一个VPN程序","date":"2019-12-12T20:34:16.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2019/12/12/如何自己开发一个VPN程序/","link":"","permalink":"https://sci.ci/2019/12/12/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAVPN%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"第一章 简介1.1 学习条件和要求学习条件： 你不用一定学习过JAVA或其他编程语言。 你不用一定了解或精通安卓编程。 你不用一定懂得Linux编程。 你需要自费支付服务器费用，国外服务器大概一个月30元，也可能有便宜的或更贵但性能更好的，你可自行选择，当然如果愿意用国内服务器练手，腾讯阿里的学生服务器一年只要120，当然这个服务器做出的VPN无法翻墙。 你需要消耗一定的时间和耐心。 如果你已经满足以上条件了，那么我希望你在浏览以下文章时，同意我的以下要求： 你保证不使用本教程制作的VPN进行牟利。 你保证不在中国大陆地区散播和分享制作的VPN。 你保证不使用此VPN进行其他违法犯罪活动或在外网发表对国家不利的言论。 若你已同意以上要求，请继续向下浏览，若你无法做到上述要求，请停止继续浏览。 1.2 功能介绍软件的实现原理，我不做介绍，有兴趣的同学可自行学习。 这里只教大家如何在我的软件基础上通过简单修改，制作一个自用VPN客户端。当然你也可以使用SS、SSR或V2ray等现成软件，并配置服务器后翻墙。 VPN功能： 可配置多条线路，以适用不同的服务器，或同一服务器上的不同用户。 客户端主动更改主题颜色。 推送更新通知，和推送广告。可在服务端更改是否推送广告。 本软件没有账户登陆等限定条件。只要安装软件，即可翻墙，当然前提条件是，你配置好了服务器。 下面展示我已经制作好的VPN程序截图，测试已能翻墙。 如此，我们便开始制作自己的VPN吧。 第二章 服务端配置2.1 VPS服务器购买这里我推荐给大家的是vultr.com。为什么这家服务器呢？这家服务器可以按小时收费，如果你不嫌麻烦，可以在需要的使用VPN的时候，再开启一台VPS。不需要的时候关闭，当然重新开启需要重新配置服务器等操作。只是我觉得性价比挺高。最重要的是支持支付宝微信付款！ 下面教大家购买VPS服务器。主要是没看到中文翻译，所以决定一步步教大家，毕竟有的人可能并不会。 点击链接打开vultr网站，www.vultr.com额外说明一句，通过我的链接打开注册，我和你都可以获得10美元的奖励费用，当然这笔钱，需要你购买服务器之后才会发放。只是给大家说明这点，当然如果大家有其他选择也是可以的。 创建账户。 填写邮箱，按要求设置密码，密码要求至少一个大写字母，一个小写字母，一个数字，和至少十个字符。点击“create acounnt”即可。 Vultr充值。 注册登录后会进入个人面板，左边栏选择 “Billing” ，选择支付方式和金额，付款即可。 Vultr 支持支付宝付款，很方便。但是个人更推荐有 Paypal 的使用 Paypal。 创建VPS 选择 “Servers” ，点击右边蓝色的 “**+**” 添加 VPS。 a.选择节点 日本距离最近，延迟最低，但太热门了，白天还好，晚上有时很慢；洛杉矶比日本稳些。 b.选择系统 选择系统。支持 Windows 和自己上传 ISO 系统镜像。这里请大家选择CentOS系统7x64 c.选择套餐 价格从 $2.5/mo 到 $640/mo，各种配置都有，最低 $2.5/mo 的套餐现在基本买不到了。要求必须有IPv4地址。 d.其他选项 有 IPv6，私密，主机名、标签等，无特殊需要全部默认即可。 选好后点击右下角的 “Deploy Now” ，开始安装 VPS。 e.查看VPS 已购买的 VPS 都会显示在 “Servers” 面板中，当显示 “Running” 时即表示安装完成。点击 “Manage” 进入 VPS 管理面板。 VPS 管理面板，这里需要记录下 IP 地址（IP Address）、用户名（Username）、密码（Password）供稍后连接 VPS 时使用。 连接VPS 使用 ssh 工具连接我们的 VPS，Windows 推荐 xshell，Mac 可使用自带的终端。 Xshell 网盘链接：https://pan.baidu.com/s/1pMbKLMb 密码：lwir Windows 安装 xshell，打开软件。 点击 “文件” —&gt; “新建” —&gt; “连接”，输入 “名称” 和 “主机” （即VPS ip）。 点击 “用户身份验证”，输入用户名（默认root）和密码。确认。 连接 VPS，接受并保存密匙。 出现 root@vultr:~# 即连接成功，可以输入代码了进行操作了。 很重要的一点，因为不是所有的VPS在国内都能ping通，有的IP地址已经被国内网络屏蔽了，所以如果VPS连接不上，请你到 [ping.chinaz.com]输入你的IP地址测试，若国内连接均提示超时且为红色，请你在vultr中删除vps并重新创建一个可用的ip地址。 Mac 打开终端，输入以下代码登录 VPS，其中 root 即用户名，将 ip 更改为 VPS 的 IP 地址，回车。 1ssh root@ip 输入 yes 确认，粘贴密码，回车。需要提醒的是，密码输入时并不会显示出来，直接复制粘贴，回车即可。出现 root@vultr:~# 即连接成功。 最近很忙，没时间更新了 项目地址：https://github.com/xieqifei/openvpn。然后有英语版本的readme。","categories":[{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/categories/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"https://sci.ci/tags/VPN/"}]},{"title":"JAVA安卓编程笔记","slug":"重温安卓编程","date":"2019-11-18T19:41:49.000Z","updated":"2021-02-20T19:54:00.000Z","comments":true,"path":"2019/11/18/重温安卓编程/","link":"","permalink":"https://sci.ci/2019/11/18/%E9%87%8D%E6%B8%A9%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/","excerpt":"","text":"第一章 前言大概在两年前，我第一次决定学习安卓编程，在大约两三周的学习之后，由于缺乏JAVA开发基础和经验，单纯的视频教程看得我云里雾里，不过在此期间学会了使用代码进行页面布局，这给我此后学习Web编程，使用html、css进行页面布局打下了基础。 两年前，我使用的还是联想的i5五系列cpu、机械硬盘、4g内存，这个电脑配置使得我当时用eplise开发安卓程序非常麻烦，打开一个安卓虚拟机需要花很长的时间。半年前，我更换了Surface，用上了8+128G内存+固态硬盘。也更新了最新的i5八系列cpu，电脑配置有了显著提高，运行安卓开发程序也游刃有余了。 而这次重启安卓学习之旅，我将使用AS进行安卓开发。虽然AS目前已支持C/C++做程序开发，但我仍将选择JAVA作为开发语言，以提高我的JAVA水平。 第二章 安装Android Studio从 https://developer.android.com/studio 下载IDE和SDK后，进行相应安装和配置。安装教程，从网课和CDSN论坛均可找到。不再赘述。 此处说明安装时遇到的坑。 SDK安装后，在SDK管理工具中添加SDK目录即andriod-sdk提示android sdk location should not contain whitespace 问题1解决后紧接着出现提示Target folder is neither empty nor does it point to an existing SDK installtion. 问题分析和解决办法： 提示意思为SDK的目录路径中出现空格。在我的问题中是，Program Files文件夹名称中间有空格，于是我在根路径重新创建了一个以Andriod为名的文件夹，并将andriod-sdk移到此路径下。 提示为，选择的文件夹既不是空的也不是sdk的文件夹，原因是我将sdk目录指向了Andriod为名的文件夹，正确的路径是上步创建Andriod文件下的andriod-sdk。 安装好SDK后，还要给AS安装虚拟机，运行AS后，在Tools菜单下找到AVD Manager（虚拟机管理器），添加合适分辨率、Andriod版本的虚拟机即可。 第三章 应用的资源访问3.1 认识Android目录 res资源 drawable-？dpi（l,h,m,x）：不同分辨率下的资源文件，如图片的大小。 values：安卓应用界面上需要显示的各类文本标签文字。 layout：界面布局文件。 menu：存放菜单 gen（ADT中）或JAVA（AS中） 由IDE自动生成的包文件 3.2 通用资源访问 基于Java代码访问资源 Java代码访问方式: 12[\\&lt;packge-name&gt;.]R. //R类所在包路径可省略&lt;resource_type&gt;.&lt;resource_name&gt; //resource_type：资源类型如color等。 Java访问示例 //从drawable目录中加载图片，设置为背景图片 1getWindow().setBackgroundDrawableResource(R.drawable.back) //从string设置字符串资源，设置为文本框的显示内容 12TextView title=(TextView)findViewById(R.id.title); title.setText(R.string.titleinfo); 在XML配置文件中访问资源 XML资源访问方式: 12@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; XML资源定义示例 12345&lt;resources&gt;&lt;color name=&quot; blue &quot; &gt;#ff00ff&lt;/color&gt;&lt;string name=&quot; title &quot; &gt;Confirmation&lt;/string&gt;&lt;/resources&gt; 在XML中使用资源示例 XML资源使用实例片段 123456&lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot; @string/title&quot; android:textColor=&quot; @color/blue&quot; /&gt;&lt;/EditText&gt; 3.3 安卓中字符串、颜色和尺寸应用 资源列表 字符串、颜色、尺寸资源，存放在XML文件内，位于/res/values目录下。 如字符串资源：/res/values/strings.xml。R类中名称：R.string 颜色表示方法 使用Color类的常量 如：int color = Color.BLUE;//创建一个蓝色 使用Color类的静态方法argb创建颜色 int color = Color.argb\\(127.255.0.255\\);//半透明紫色 在XML资源文件定义颜色值 12345&lt;resources&gt;&lt;color name=&quot; blue &quot; &gt;#ff00ff&lt;/color&gt;&lt;string name=&quot; title &quot; &gt;Confirmation&lt;/string&gt;&lt;/resources&gt; 使用示例 res和assets区别 res内的文件被映射到R.java，基于资源ID直接访问。 assets需通过资源管理器访问。 res下不可以创建子目录，assets可以有目录结构。 读取文件资源的方式不同 读取res/raw下的文件资源，通过当前Activity中的getResources()方法： 12InputStream is = getResources().openRawResource(R.id.filename); 读取assets下的文件资源，通过当前活动的资源管理器assetmanager读取相应的资源文件： 12AssetManager am = getAssets();//通过当前的Activity的getAsset()方法。InputStream is = am.open(&quot;filename&quot;);//基于文件名读取资源。 3.4 Drawable资源 Drawable资源 主要是需要绘制的资源，比如图片资源。 主要格式有*.png、*.jpg等。 图片放入/res/drawable-xxx目录下。 安卓SDK会在编译应用自动加载图片。 资源文件在R.java资源类中生成该资源的索引。 Drawable资源类型 StateListDrawable资源（动态切换背景） LayerDrawable资源（图层叠加） ShapeDrawable资源（绘图） ClipDrawable资源 AnimationDrawable资源（动画） 3.5 安卓项目布局文件 什么是安卓布局文件？ 定义用户界面上各个组建之间的组织结构。 XML格式文件，安卓系统负责初始化。 实现界面布局和逻辑代码的分离。 修改和更新界面非常简便，无需修改代码。 布局文件是树形结构，使用根节点。 一般在布局控件中放置界面显示组建LinearLayout中放入textview文本标签 通过节点属性设置显示界面组建的属性：大小、颜色和边距等。 布局示例 布局文件节点属性示例 android:id=&quot;@+id/button_id&quot; @表示XML解析器应该解析ID字符串把它作为ID资源。 +符号表示一个新的资源名字，会被创建且加入到资源列表中（R.java） @string/@color等可用于访问其他资源。 组建id在android应用中是唯一的。 主题 内容 资源位置 res/layout/my_layout.xml 布局XML文件格式 使用&lt;?xml version= “1.0”encoding=”utf-8” ?&gt;&lt;布局类xmlns:android=”http://schemas.android.Com/apk/res/android” id= “@id+/string_na&lt;br&gt;me”(属性)&gt;&lt;视图组件或者其他嵌套布局类&gt;&lt;requestFocus/&gt;&lt;/布局类&gt; 获得XML资源的方法 Activity.setContentView() 引用XML资源的格式 Java代码中：R.layout.my_layout。XML文件中：@[package:]layout/my_layout 资源位置 res/layout/my_layout.xml 3.6 AndroidManifest.xml项目配置文件 什么是AndroidManifest.xml 位于根目录下，文件名不可修改。 该文件中 &lt;manifest&gt;和 &lt;application&gt;是必需的且只能出现一次。 描述Android应用使用的组建和系统配置信息 应用使用的组建及其实现类（Activity/Service等） 需要使用的安卓系统权限。 声明其他应用程序与该应用程序交互需要的权限 该应用程序所需的安卓API版本。 列出该应用程序所需类库。 第四章 界面编程任务分析与设计4.1 循序渐进 Activity简介 安卓的视图组件，四大组件之一。 定义用户可以看到触摸到的界面。 活动内使用各种界面组件，实现交互动作。 通过活动，用户界面之间切换跳转、进行数据传递。 Activity概念 用来包装用户界面组件的容器，实现用户和界面组件之间的交互。 案列分析教学特点和注意事项 界面编程案例分析教学特点 案例：基于安卓系统的计算器 特点：案例驱动，实践先行 优势：在实践中学习抽象的概念 界面编程案例分析注意事项 知识要点：活动的概念和使用 分析技巧：如何将实际中的问题进行分析；分析问题和解决问题的方法 编码技巧：在案例中学习编码技巧 计算器案例 操作过程： 用户输入两个计算数； 选择计算类型； 点击计算按钮，进行计算 将结果展示给用户 4.2 活动的创建和使用 创建活动应用程序 应用程序通常由多个活动松耦合的组成 活动是界面上的组件在屏幕上展示的容器 活动通过布局文件展示界面布局的内容 活动的生命周期，利用周期的方法扩展 创建活动步骤 声明活动类名，继承于活动 实现onCreate(Bundle bundle)方法，在系统初始化完成活动对象之后，进行用户自定义的初始化活动 在onCreate(View view)设置用户界面的布局文件 通过活动中的findViewById(int id)获取各个界面组件，并基于其属性和方法进行相应的操作 如果需要在销毁活动进行处理，可以实现onDestroy()的方法。 4.3 活动的声明和配置 活动的声明和配置 活动定义后需在AndroidManifest.xml中声明 `&lt;application…/&gt;·节点内添加·&lt;activity…/&gt;·子元素 在&lt;activity&gt;子节点内定义Activity的类型（入口活动） 12345&lt;activity android:name=&quot;com.quck.android.calculator&quot;android:icon=&quot;@drawable/pic.png&quot;android:label=&quot;@string/app_name&quot; &gt;//略去其中内容&lt;/activity&gt; 配置活动——示例分析 活动的主要配置属性有如下三个： name：指定该活动的类名 icon：是定该活动对象的图标（可选） label：指定该活动的标签 在&lt;activity&gt;节点中指定一个或者多个&lt;intent-filter.../&gt;元素Intent的类型和Action决定活动是否会接收消息。 4.4 活动之间的数据交换和调用 活动之间的数据交换和调用 活动之间跳转，需传递数据信息 通过Intent来进行数据传递 数据需要放入Intent或者Bundle之内 什么是Bundle？ Bundle类是一个key-value对，一个映射，把字符串映射为各种类型。 数据交换 写入数据 putExtras(Bundle data)向Intent中放入需要携带的Bundle数据 putXXX(String key, Xxx data)向Bundle放入Int,Long,String等各种类型的数据 putSerializable(String key, Serialzable data):向Bundle中放入一份可序列化对象 读取数据 getExtras()从Intent中读取需要携带的Bundle数据 getXXX(String key)从Bundle，Intent读取int,Long,String等各种类型的数据 getSerializable(String key)从Bundle，Intent中读取一个可序列化的对象 活动交换示例 Intent vs Bundle 相同点：传递数据时，作用相同 不同点：在多个活动之间传递相同数据时，推荐使用Bundle来储存和传递数据，减少重复的读写操作 例：活动跳转A-&gt;B-&gt;C传递相同数据 如果使用Intent，则需要在A、B、C的Intent之间进行数据的复制 如果使用Bundle，则可直接传递Bundle对象即可 返回数据 startActivityForResult(Intent intent, int requestCode) 跳转到指定的活动 参数intent：指定目的活动类名 参数requestCode：由程序中自定义的识别码，用以区分不同的七点活动 setResult(int resultCode, Intent data) 设置resultCode表示结果的Activity，第二个参数保存传递的结果数据 onActivityResult(int requestCode, int resultCode, Intent data) 参数requestCode：起点活动定义唯一值 参数resultCode：目的活动定义的唯一标识值 参数data：从墓地活动返回的数据 数据使用步骤 起点活动，调用startActivityForResult()跳转目的活动 在目的活动中调用setResult() 在起点活动覆写onActivityResult()在方法内获取目的活动返回的数据 第五章 服务开发和广播事件5.1 循序渐进 案列：音乐播放器 任务概述 功能分析 界面设计 实现暂停、播放和停止 播放同时，显示歌手和音乐名称 用户界面设计 主界面 技术要点 服务的创建、调用 服务和活动之间的通信 Intent对象的使用 案例演示 案例任务分析和设计 音乐播放器界面分析 核心代码设计和实现 核心代码编写步骤： 创建安卓项目MusicBox 在res/loyout目录，创建播放器的主界面布局文件 定义一个MusicBoxContant的常量类存放程序中用到的静态或不变的信息 创建音乐播放器的服务类 在全局配置文件中，声明服务类 定义实现音乐播放器的主界面 定义事项ActicityReciver事件接收器，接受音乐服务状态变化广播事件的接收器 定义实现按钮事件接收器，播放和停止按钮，发送广播事件 5.2 安卓中的系统服务 安卓将诸多常用功能内置为系统服务 提供简单的获取系统服务的方式 系统服务涵盖了安卓绝大部分常用功能，如，拨打电话，发送短信 安卓中获取系统服务 获取系统服务代码示例 TelephonyManager phoneManager=(TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); 强制类型转化 在程序运行过程中，将父类型对象转化为子类型对象。 由于子类型相比父类型的内涵丰富，属性方法更多，所以要把父类型转化为子类型时，需要强制转化，成为强制类型转换。 并不是所有父类型都可以转化为子类型，要根据具体的使用情况来做具体的判断。 5.3 广播接收机制 广播消息 广播是一种在应用程序之间传输信息的计指 BroadcastReceiver广播接收者 广播消息Intent（消息载体） 被订阅广播的多个广播接收者接收 消息订阅者不了解发送者 广播接收者 BroadcastReceiver对发出的广播事件进行过滤，应用程序通知其他应用程序某些数据已经下载完毕。 广播接收者没有图形界面 广播可以有多个接收者，彼此不知晓。广播接收者之间匿名 监听广播机制 广播和事件监听器是分离的 通过安卓系统进行广播、接收广播事件 注册和移除监听通过安卓系统来完成 安卓系统提供很多广播定义在android.content.Intent类中 广播方法 sendBroadcast():普通模式 所有注册了广播的接收者会获得事件通知 接收者接受顺序不确定并发地在各自的应用进程中执行 接收者和发送者不知晓 sendOrderedBroadcast():有序广播模式 接收者依照设定的优先级高低依次接受 高优先级接收者可以中断后续广播的接收，BroadcastReceiver.abortBroadcast()终止这个广播事件的传播，低优先级的触发器组件不再有机会接收 高优先级接收者可添加额外信息给后续接收者 BroadcastReceiver.setResult() 监听广播实现 获取广播事件的消息接口名称 事件定制的广播接收器，添加相应的处理逻辑 注册广播接收器到安卓系统中 监听广播实现示例 1234567891011public class MyBroadcastReceiver extends BroadcastReceiver&#123;//action名称，此为固定的字符String SMS_RECEIVED=&quot;android.provider.Telephony.SMS_RECEIVED&quot;;@Overridepublic void onReceive(COntext context, Intent intent)&#123;//如事件有短信接收，则执行if(intent.getAction().quals(SMS_RECEIVED))&#123;//进行短信接收到之后的逻辑处理&#125;&#125;&#125; 监听广播注册 在manifest中注册监听器 1234567891011&lt;!--声明接收器--&gt;&lt;receiver android:name = &quot;.MyBroadReceiver&quot;&gt; &lt;!--接收事件的过滤条件声明和优先级--&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;!--支持接收的事件类型--&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;!--监听系统级事件，需要相应的权限：接收者和发送短信的权限--&gt;&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 在运行代码中注册广播监听器 123456//创建监听器对象MyBroadcastReceiver myMsgInfoReceiver=new MyBroadcastReceiver();//声明IntentFilter，描述可以接收的广播消息IntentFilter intentFilter=new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIED&quot;);//调用Activity的方法，注册监听器registerReceiver(mBatteryInfoReceiver,intentFilter) 广播事件生命周期 广播消息到来，新建BroadcastReceiver对象 调用onReceive()方法，执行操作 操作完成后，对象被销毁 事件出发—&gt;创建事件监听器对象—&gt;调用监听器的onReceiver()—&gt;销毁事件监听器的对象—&gt;结束操作，返回 广播事件注意事项 在广播接收器中响应逻辑中不能执行比较耗时的操作 在onReceive()方法中执行超过10秒，就会弹出无响应对话框。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/tags/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"网站编程","slug":"网站编程","permalink":"https://sci.ci/categories/%E7%BD%91%E7%AB%99%E7%BC%96%E7%A8%8B/"},{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/categories/%E7%88%AC%E8%99%AB/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://sci.ci/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"人工智能","slug":"人工智能","permalink":"https://sci.ci/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://sci.ci/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/categories/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"},{"name":"Python","slug":"Python","permalink":"https://sci.ci/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/categories/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"其他","slug":"其他","permalink":"https://sci.ci/categories/%E5%85%B6%E4%BB%96/"},{"name":"Windows","slug":"Windows","permalink":"https://sci.ci/categories/Windows/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://sci.ci/tags/Javascript/"},{"name":"Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://sci.ci/tags/%E7%88%AC%E8%99%AB/"},{"name":"ESP8266","slug":"ESP8266","permalink":"https://sci.ci/tags/ESP8266/"},{"name":"Arduino","slug":"Arduino","permalink":"https://sci.ci/tags/Arduino/"},{"name":"MPU6050","slug":"MPU6050","permalink":"https://sci.ci/tags/MPU6050/"},{"name":"人工智能","slug":"人工智能","permalink":"https://sci.ci/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"AI","slug":"AI","permalink":"https://sci.ci/tags/AI/"},{"name":"ADB","slug":"ADB","permalink":"https://sci.ci/tags/ADB/"},{"name":"Java","slug":"Java","permalink":"https://sci.ci/tags/Java/"},{"name":"-Python","slug":"Python","permalink":"https://sci.ci/tags/Python/"},{"name":"-TWRP","slug":"TWRP","permalink":"https://sci.ci/tags/TWRP/"},{"name":"Mitmproxy","slug":"Mitmproxy","permalink":"https://sci.ci/tags/Mitmproxy/"},{"name":"Pandas","slug":"Pandas","permalink":"https://sci.ci/tags/Pandas/"},{"name":"数据处理","slug":"数据处理","permalink":"https://sci.ci/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Volantis","slug":"Volantis","permalink":"https://sci.ci/tags/Volantis/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://sci.ci/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://sci.ci/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://sci.ci/tags/Numpy/"},{"name":"Linux","slug":"Linux","permalink":"https://sci.ci/tags/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://sci.ci/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Selenium","slug":"Selenium","permalink":"https://sci.ci/tags/Selenium/"},{"name":"Nginx","slug":"Nginx","permalink":"https://sci.ci/tags/Nginx/"},{"name":"博客","slug":"博客","permalink":"https://sci.ci/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://sci.ci/tags/Hexo/"},{"name":"Vlantis","slug":"Vlantis","permalink":"https://sci.ci/tags/Vlantis/"},{"name":"音乐播放器","slug":"音乐播放器","permalink":"https://sci.ci/tags/%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"},{"name":"电商","slug":"电商","permalink":"https://sci.ci/tags/%E7%94%B5%E5%95%86/"},{"name":"电商系统","slug":"电商系统","permalink":"https://sci.ci/tags/%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F/"},{"name":"Cookie","slug":"Cookie","permalink":"https://sci.ci/tags/Cookie/"},{"name":"JSON","slug":"JSON","permalink":"https://sci.ci/tags/JSON/"},{"name":"Git","slug":"Git","permalink":"https://sci.ci/tags/Git/"},{"name":"JsDelivr","slug":"JsDelivr","permalink":"https://sci.ci/tags/JsDelivr/"},{"name":"YAAW","slug":"YAAW","permalink":"https://sci.ci/tags/YAAW/"},{"name":"Oneindex","slug":"Oneindex","permalink":"https://sci.ci/tags/Oneindex/"},{"name":"Rclone","slug":"Rclone","permalink":"https://sci.ci/tags/Rclone/"},{"name":"Aria2","slug":"Aria2","permalink":"https://sci.ci/tags/Aria2/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://sci.ci/tags/TensorFlow/"},{"name":"深度学习","slug":"深度学习","permalink":"https://sci.ci/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"PyTorch","slug":"PyTorch","permalink":"https://sci.ci/tags/PyTorch/"},{"name":"SSR","slug":"SSR","permalink":"https://sci.ci/tags/SSR/"},{"name":"haproxy","slug":"haproxy","permalink":"https://sci.ci/tags/haproxy/"},{"name":"负载均衡","slug":"负载均衡","permalink":"https://sci.ci/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"name":"移动网络","slug":"移动网络","permalink":"https://sci.ci/tags/%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"},{"name":"网站优化","slug":"网站优化","permalink":"https://sci.ci/tags/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"name":"Stunnel","slug":"Stunnel","permalink":"https://sci.ci/tags/Stunnel/"},{"name":"Squid","slug":"Squid","permalink":"https://sci.ci/tags/Squid/"},{"name":"Mysql","slug":"Mysql","permalink":"https://sci.ci/tags/Mysql/"},{"name":"Stunnel代理","slug":"Stunnel代理","permalink":"https://sci.ci/tags/Stunnel%E4%BB%A3%E7%90%86/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://sci.ci/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"name":"ShopXO","slug":"ShopXO","permalink":"https://sci.ci/tags/ShopXO/"},{"name":"机器学习","slug":"机器学习","permalink":"https://sci.ci/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"网络技术","slug":"网络技术","permalink":"https://sci.ci/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://sci.ci/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"微信公众号","slug":"微信公众号","permalink":"https://sci.ci/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://sci.ci/tags/Bootstrap/"},{"name":"Kali Linux","slug":"Kali-Linux","permalink":"https://sci.ci/tags/Kali-Linux/"},{"name":"Flutter","slug":"Flutter","permalink":"https://sci.ci/tags/Flutter/"},{"name":"Vuejs","slug":"Vuejs","permalink":"https://sci.ci/tags/Vuejs/"},{"name":"安卓开源库","slug":"安卓开源库","permalink":"https://sci.ci/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E6%BA%90%E5%BA%93/"},{"name":"API","slug":"API","permalink":"https://sci.ci/tags/API/"},{"name":"Magento","slug":"Magento","permalink":"https://sci.ci/tags/Magento/"},{"name":"VPN","slug":"VPN","permalink":"https://sci.ci/tags/VPN/"},{"name":"安卓编程","slug":"安卓编程","permalink":"https://sci.ci/tags/%E5%AE%89%E5%8D%93%E7%BC%96%E7%A8%8B/"}]}